CompPresAd.c://#define __GPU
CompPresAd.c://#define __NOPROTO
CompPresAd.c:#include "fargo3d.h"
CompPresAd.c:void ComputePressureFieldAd_cpu () {
CompPresAd.c:  INPUT(Energy);
CompPresAd.c:  OUTPUT(Pressure);
CompPresAd.c:  real* e   = Energy->field_cpu;
CompPresAd.c:  real* pres = Pressure->field_cpu;
CompPresAd.c:  int stride = Stride_cpu;
CompPresAd.c:  int size_x = Nx+2*NGHX;
CompPresAd.c:  int size_y = Ny+2*NGHY;
CompPresAd.c:  int size_z = Nz+2*NGHZ;
CompPresAd.c:// real GAMMA(1);
CompPresAd.c:#ifdef Z
CompPresAd.c:  for (k=0; k<size_z; k++) {
CompPresAd.c:#endif
CompPresAd.c:#ifdef Y
CompPresAd.c:    for (j=0; j<size_y; j++) {
CompPresAd.c:#endif
CompPresAd.c:#ifdef X
CompPresAd.c:      for (i=0; i<size_x; i++ ) {
CompPresAd.c:#endif
CompPresAd.c:	pres[ll] = (GAMMA-1.0)*e[ll];
CompPresAd.c:#ifdef X
CompPresAd.c:#endif
CompPresAd.c:#ifdef Y
CompPresAd.c:#endif
CompPresAd.c:#ifdef Z
CompPresAd.c:#endif
CompPresIso.c://#define __GPU
CompPresIso.c://#define __NOPROTO
CompPresIso.c:#include "fargo3d.h"
CompPresIso.c:void ComputePressureFieldIso_cpu () {
CompPresIso.c:  INPUT(Energy);
CompPresIso.c:  INPUT(Density);
CompPresIso.c:  OUTPUT(Pressure);
CompPresIso.c:  real* dens = Density->field_cpu;
CompPresIso.c:  real* cs   = Energy->field_cpu;
CompPresIso.c:  real* pres = Pressure->field_cpu;
CompPresIso.c:  int stride = Stride_cpu;
CompPresIso.c:  int size_x = Nx+2*NGHX;
CompPresIso.c:  int size_y = Ny+2*NGHY;
CompPresIso.c:  int size_z = Nz+2*NGHZ;
CompPresIso.c:#ifdef Z
CompPresIso.c:  for (k=0; k<size_z; k++) {
CompPresIso.c:#endif
CompPresIso.c:#ifdef Y
CompPresIso.c:    for (j=0; j<size_y; j++) {
CompPresIso.c:#endif
CompPresIso.c:#ifdef X
CompPresIso.c:      for (i=0; i<size_x; i++ ) {
CompPresIso.c:#endif
CompPresIso.c:	pres[ll] = dens[ll]*cs[ll]*cs[ll];
CompPresIso.c:#ifdef X
CompPresIso.c:#endif
CompPresIso.c:#ifdef Y
CompPresIso.c:#endif
CompPresIso.c:#ifdef Z
CompPresIso.c:#endif
CompPresPoly.c://#define __GPU
CompPresPoly.c://#define __NOPROTO
CompPresPoly.c:#include "fargo3d.h"
CompPresPoly.c:void ComputePressureFieldPoly_cpu () {
CompPresPoly.c:  INPUT(Energy);
CompPresPoly.c:  INPUT(Density);
CompPresPoly.c:  OUTPUT(Pressure);
CompPresPoly.c:  real* dens = Density->field_cpu;
CompPresPoly.c:  real* cs   = Energy->field_cpu;
CompPresPoly.c:  real* pres = Pressure->field_cpu;
CompPresPoly.c:  int stride = Stride_cpu;
CompPresPoly.c:  int size_x = Nx+2*NGHX;
CompPresPoly.c:  int size_y = Ny+2*NGHY;
CompPresPoly.c:  int size_z = Nz+2*NGHZ;
CompPresPoly.c:  real gamma = GAMMA;
CompPresPoly.c:#ifdef Z
CompPresPoly.c:  for (k=0; k<size_z; k++) {
CompPresPoly.c:#endif
CompPresPoly.c:#ifdef Y
CompPresPoly.c:    for (j=0; j<size_y; j++) {
CompPresPoly.c:#endif
CompPresPoly.c:#ifdef X
CompPresPoly.c:      for (i=0; i<size_x; i++ ) {
CompPresPoly.c:#endif
CompPresPoly.c:	pres[ll] = cs[ll]*pow(dens[ll],gamma);
CompPresPoly.c:#ifdef X
CompPresPoly.c:#endif
CompPresPoly.c:#ifdef Y
CompPresPoly.c:#endif
CompPresPoly.c:#ifdef Z
CompPresPoly.c:#endif
Compute_Mean.c:#include "fargo3d.h"
Compute_Mean.c:/* This function only runs on the CPU in its present state. */
Compute_Mean.c:real ComputeMean(Field *F) {
Compute_Mean.c:  real total = 0.;
Compute_Mean.c:  real volume = 0., dvol;
Compute_Mean.c:  real grandvolume=0., grandtotal = 0.;
Compute_Mean.c:  real *f;
Compute_Mean.c:  f = F->field_cpu;
Compute_Mean.c:#ifdef Z
Compute_Mean.c:#endif
Compute_Mean.c:#ifdef Y
Compute_Mean.c:#endif
Compute_Mean.c:#ifdef X
Compute_Mean.c:#endif
Compute_Mean.c:	volume += dvol;
Compute_Mean.c:#ifdef X
Compute_Mean.c:#endif
Compute_Mean.c:#ifdef Y
Compute_Mean.c:#endif
Compute_Mean.c:#ifdef Z
Compute_Mean.c:#endif
Compute_Mean.c:#ifdef FLOAT
Compute_Mean.c:  MPI_Allreduce(&total, &grandtotal, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
Compute_Mean.c:  MPI_Allreduce(&volume, &grandvolume, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
Compute_Mean.c:#else
Compute_Mean.c:  MPI_Allreduce(&total, &grandtotal, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
Compute_Mean.c:  MPI_Allreduce(&volume, &grandvolume, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
Compute_Mean.c:#endif
Compute_Mean.c:  return grandtotal/grandvolume;
LowTasks.c:#include "fargo3d.h"
LowTasks.c:void prs_exit(int numb) {
LowTasks.c:  MPI_Finalize();
LowTasks.c:  exit(numb);
LowTasks.c:void prs_error(char *string){
LowTasks.c:  fprintf(stderr, "%s\n", string);
LowTasks.c:  prs_exit(1);
LowTasks.c:int PrimitiveVariables () {
LowTasks.c:#ifdef ADIABATIC
LowTasks.c:#endif
LowTasks.c:#ifdef X
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#endif
LowTasks.c:#ifdef MHD
LowTasks.c:  if(Fluidtype==GAS){
LowTasks.c:#endif
LowTasks.c:  return var;
LowTasks.c:inline real Swap(real f) {
LowTasks.c:    real value;
LowTasks.c:#ifndef FLOAT
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:  } value1, value2;
LowTasks.c:  value1.value = f;
LowTasks.c:#ifdef FLOAT
LowTasks.c:  value2.b[0] = value1.b[3];
LowTasks.c:  value2.b[1] = value1.b[2];
LowTasks.c:  value2.b[2] = value1.b[1];
LowTasks.c:  value2.b[3] = value1.b[0];
LowTasks.c:#else
LowTasks.c:  value2.b[0] = value1.b[7];
LowTasks.c:  value2.b[1] = value1.b[6];
LowTasks.c:  value2.b[2] = value1.b[5];
LowTasks.c:  value2.b[3] = value1.b[4];
LowTasks.c:  value2.b[4] = value1.b[3];
LowTasks.c:  value2.b[5] = value1.b[2];
LowTasks.c:  value2.b[6] = value1.b[1];
LowTasks.c:  value2.b[7] = value1.b[0];
LowTasks.c:#endif
LowTasks.c:  return value2.value;
LowTasks.c:void Check_CUDA_Blocks_Consistency () {
LowTasks.c:  boolean problem = NO;
LowTasks.c:#ifdef GPU
LowTasks.c:  #ifndef X
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("You have CUDA blocks that are larger than 1 in X,\n");
LowTasks.c:    mastererr ("but the dimension X does not exist in your setup. Fix this !!\n");
LowTasks.c:    problem = YES;
LowTasks.c:  #endif
LowTasks.c:  #ifndef Y
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("You have CUDA blocks that are larger than 1 in Y,\n");
LowTasks.c:    mastererr ("but the dimension Y does not exist in your setup. Fix this !!\n");
LowTasks.c:    problem = YES;
LowTasks.c:  #endif
LowTasks.c:  #ifndef Z
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("ERROR  ---  ERROR   ---- ERROR\n");
LowTasks.c:    mastererr ("You have CUDA blocks that are larger than 1 in Z,\n");
LowTasks.c:    mastererr ("but the dimension Z does not exist in your setup. Fix this !!\n");
LowTasks.c:    problem = YES;
LowTasks.c:  #endif
LowTasks.c:  if (problem == YES) {
LowTasks.c:    mastererr ("The code would produce undetermined  results in this case.\n");
LowTasks.c:    mastererr ("You must edit the file setups/%s/%s.opt\n", xstr(SETUPNAME), xstr(SETUPNAME));
LowTasks.c:    mastererr ("then rebuild the code\n");
LowTasks.c:    prs_exit (1);
LowTasks.c:#endif
LowTasks.c:void MakeDir (char *string) {
LowTasks.c:  int temp;
LowTasks.c:  /* Each processor tries to create the directory, sequentially */
LowTasks.c:  /* Silent if directory exists */
LowTasks.c:  /* If all processes see the same partition, only the first process
LowTasks.c:     will create the directory. Alternatively, they will create as
LowTasks.c:     many directories as necessary. For instance, if we have say 4 PEs per node
LowTasks.c:     and each node sees its own scratchdir, nbprocesses/4 
LowTasks.c:     mkdir() commands will be issued */
LowTasks.c:  if (CPU_Rank) MPI_Recv (&foo, 1, MPI_INT, CPU_Rank-1, 53, MPI_COMM_WORLD, &fargostat);
LowTasks.c:  dir = opendir (string);
LowTasks.c:    closedir (dir);
LowTasks.c:  } else {
LowTasks.c:    fprintf (stdout, "Process %d created the directory %s\n", CPU_Rank, string);
LowTasks.c:    temp = system (command);
LowTasks.c:  if (CPU_Rank < CPU_Number-1) MPI_Send (&foo, 1, MPI_INT, CPU_Rank+1, 53, MPI_COMM_WORLD);
LowTasks.c:FILE *fopen_prs (char *string, char *mode) {
LowTasks.c:  f = fopen (string, mode);
LowTasks.c:    /* This should be redundant with the call to MakeDir () at the
LowTasks.c:       beginning, from main.c; this is not a problem however */
LowTasks.c:      MakeDir (dir);
LowTasks.c:    f = fopen (string, "w");	/* "w" instead of mode: at this stage we know the file does not exist */
LowTasks.c:      printf ("Process %d could not open %s\n", CPU_Rank, string);
LowTasks.c:      printf ("Tried to create %s\n", dir);
LowTasks.c:      fprintf (stdout, "Still could not open %s.\n", string);
LowTasks.c:      fprintf (stdout, "You should check that the permissions are correctly set.\n");
LowTasks.c:      fprintf (stdout, "Run aborted\n");
LowTasks.c:      prs_exit (1);
LowTasks.c:  return f;
LowTasks.c:FILE *master_fopen (char *filename, char *mode) {
LowTasks.c:  boolean Abort = NO;
LowTasks.c:    f = fopen (filename, mode);
LowTasks.c:      mastererr ("Could not open file %s\n", filename);
LowTasks.c:    prs_exit (EXIT_FAILURE);
LowTasks.c:  return f;
LowTasks.c:void masterfprintf(FILE *f, const char *template, ...) {
LowTasks.c:  if (!CPU_Master) return;
LowTasks.c:  va_start(ap, template);
LowTasks.c:  vfprintf(f, template, ap);
LowTasks.c:  va_end(ap);
LowTasks.c:void masterprint(const char *template, ...) {
LowTasks.c:  if (!CPU_Master) return;
LowTasks.c:  va_start(ap, template);
LowTasks.c:  vfprintf(stdout, template, ap);
LowTasks.c:  va_end(ap);
LowTasks.c:void mastererr(const char *template, ...) {
LowTasks.c:  if (!CPU_Master) return;
LowTasks.c:  va_start(ap, template);
LowTasks.c:  vfprintf(stderr, template, ap);
LowTasks.c:  va_end(ap);
LowTasks.c:void InitSpace() {
LowTasks.c:  real dx,dy, dz;
LowTasks.c:  real x0;
LowTasks.c:  real ymin, zmin, xmin;
LowTasks.c:  real temp1;
LowTasks.c:  boolean already_x=NO;
LowTasks.c:  boolean already_y=NO;
LowTasks.c:  boolean already_z=NO;
LowTasks.c:  int temp, relay;
LowTasks.c:  if (*SPACING=='F') { //Fixed spacing
LowTasks.c:#ifdef X
LowTasks.c:    masterprint("Warning: zone spacing will be taken from the files domain_i.dat.\n");
LowTasks.c:    domain = fopen(domain_out, "r");
LowTasks.c:      masterprint("Warning: x spacing taken from domain_x.dat file!\n");
LowTasks.c:#ifdef FLOAT
LowTasks.c:	temp = fscanf(domain, "%f\n", &temp1);
LowTasks.c:#else
LowTasks.c:	temp = fscanf(domain, "%lf\n", &temp1);
LowTasks.c:#endif
LowTasks.c:	Xmin(i) = temp1;
LowTasks.c:      already_x = YES;
LowTasks.c:    fclose(domain);
LowTasks.c:#endif    
LowTasks.c:#ifdef Y
LowTasks.c:    domain = fopen(domain_out, "r");
LowTasks.c:      masterprint("Warning: y spacing taken from domain_y.dat file!\n");
LowTasks.c:#ifdef FLOAT
LowTasks.c:	temp = fscanf(domain, "%f\n", &temp1);
LowTasks.c:#else
LowTasks.c:	temp = fscanf(domain, "%lf\n", &temp1);
LowTasks.c:#endif
LowTasks.c:	  Ymin(j-Y0) = temp1;
LowTasks.c:      already_y = YES;
LowTasks.c:    fclose(domain);
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:    domain = fopen(domain_out, "r");
LowTasks.c:      masterprint("Warning: z spacing taken from domain_z.dat file!\n");
LowTasks.c:#ifdef FLOAT
LowTasks.c:	temp = fscanf(domain, "%f\n", &temp1);
LowTasks.c:#else
LowTasks.c:	temp = fscanf(domain, "%lf\n", &temp1);
LowTasks.c:#endif
LowTasks.c:	  Zmin(k-Z0) = temp1;
LowTasks.c:      already_z = YES;
LowTasks.c:    fclose(domain);
LowTasks.c:#endif
LowTasks.c: else if (*SPACING=='N') {
LowTasks.c:#ifdef X
LowTasks.c:      Xmin(i) = bisect(Xmin(i-1), 1.1*XMAX, Nx+2*NGHX+1, ux, 0);
LowTasks.c:    // calcualte constants to optimize RamComputeUstar.c
LowTasks.c:    compute_ux_constants();
LowTasks.c:#endif //X
LowTasks.c:#ifdef Y
LowTasks.c:  real ymin_global;
LowTasks.c:    if (j_global > NGHY) ymin_global = bisect(ymin_global, 1.1*YMAX, NY+1, uy, 0);
LowTasks.c:  // Fill ghost zones using the fact that du is constant and we bisect in reverse order
LowTasks.c:      Ymin(NGHY - (j+1)) = bisect(0.5*YMIN, Ymin(NGHY-j), NY+1, uy, 1);
LowTasks.c:      Ymin(Ny+NGHY+j+1) = bisect(Ymin(Ny+NGHY+j), 1.5*YMAX, NY+1, uy, 0);
LowTasks.c:#endif //Y
LowTasks.c:#ifdef Z
LowTasks.c:#endif //Z
LowTasks.c:  else {
LowTasks.c:#ifdef X
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:  if (((toupper(*SPACING)) == 'L') && ((toupper(*(SPACING+1))) == 'O')) { //Logarithmic
LowTasks.c:      masterprint("Warning: The Y spacing is logarithmic.\n");
LowTasks.c:	Ymin(j) = exp(log(YMIN) + dy*(j+Y0-NGHY));
LowTasks.c:    else {  //Linear
LowTasks.c:      masterprint("Warning: The Y spacing is linear (default).\n");
LowTasks.c:#ifdef Y
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef X
LowTasks.c:#else
LowTasks.c:#endif	
LowTasks.c:    Xmed(i) = 0.5*(Xmin(i+1)+Xmin(i));
LowTasks.c:    Ymed(j) = 0.5*(Ymin(j+1)+Ymin(j));
LowTasks.c:    Zmed(k) = 0.5*(Zmin(k+1)+Zmin(k));
LowTasks.c:    InvDiffXmed(i) = 1./(Xmed(i)-Xmed(i-1));
LowTasks.c:  InvDiffXmed(0) = 1./( Xmed(0)- (Xmed(Nx-1)-(XMAX-XMIN) ));
LowTasks.c:  MPI_Barrier(MPI_COMM_WORLD);
LowTasks.c:  if (!already_x) {
LowTasks.c:    if(CPU_Master) {
LowTasks.c:      domain = fopen(domain_out, "w");
LowTasks.c:  if (!already_y) {
LowTasks.c:    if (CPU_Rank > 0) { // Force sequential write
LowTasks.c:      MPI_Recv (&relay, 1, MPI_INT, CPU_Rank-1, 42, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
LowTasks.c:    if(CPU_Master)  {
LowTasks.c:      domain = fopen(domain_out, "w");
LowTasks.c:    else {
LowTasks.c:	domain = fopen(domain_out, "a");
LowTasks.c:      fclose(domain);
LowTasks.c:    if (CPU_Rank < CPU_Number-1) {  // Force sequential write
LowTasks.c:      MPI_Send (&relay, 1, MPI_INT, CPU_Rank+1, 42, MPI_COMM_WORLD);
LowTasks.c:  MPI_Barrier (MPI_COMM_WORLD);
LowTasks.c:  if (!already_z) {
LowTasks.c:    if (CPU_Rank > 0) { // Force sequential read
LowTasks.c:      MPI_Recv (&relay, 1, MPI_INT, CPU_Rank-1, 43, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
LowTasks.c:    if(CPU_Master)  {
LowTasks.c:      domain = fopen(domain_out, "w");
LowTasks.c:    else {
LowTasks.c:	domain = fopen(domain_out, "a");
LowTasks.c:      fclose(domain);
LowTasks.c:    if (CPU_Rank < CPU_Number-1) {  // Force sequential read
LowTasks.c:      MPI_Send (&relay, 1, MPI_INT, CPU_Rank+1, 43, MPI_COMM_WORLD);
LowTasks.c:    MPI_Barrier (MPI_COMM_WORLD);
LowTasks.c:void InitSurfaces() {
LowTasks.c:#ifdef X
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef CARTESIAN
LowTasks.c:#ifdef Y
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else 
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:#ifdef CYLINDRICAL
LowTasks.c:#if !defined(Y)
LowTasks.c:    masterprint("Error! In simulations w/ cylindrical geometry, Y must be activated!\n");
LowTasks.c:    exit(0);
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:#ifdef SPHERICAL
LowTasks.c:#if !defined(Y)
LowTasks.c:    masterprint("Error! In simulations w/ spherical geometry, Y must be activated!\n");
LowTasks.c:    exit(0);
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#else
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:#ifdef DEBUG
LowTasks.c:    masterprint("SURFACES OK\n");
LowTasks.c:#endif
LowTasks.c:void SelectFluid(int n) {
LowTasks.c:  //Function for selecting the current fluid
LowTasks.c:  Fluidtype = Fluids[n]->Fluidtype;
LowTasks.c:  Density = Fluids[n]->Density;
LowTasks.c:  Energy = Fluids[n]->Energy;
LowTasks.c:  VxMed = Fluids[n]->VxMed;
LowTasks.c:#ifdef X
LowTasks.c:  Vx_temp = Fluids[n]->Vx_temp;
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:  Vy_temp = Fluids[n]->Vy_temp;
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:  Vz_temp = Fluids[n]->Vz_temp;
LowTasks.c:#endif
LowTasks.c:#ifdef STOCKHOLM
LowTasks.c:  Density0 = Fluids[n]->Density0;
LowTasks.c:  Energy0 = Fluids[n]->Energy0;
LowTasks.c:#endif
LowTasks.c:void CreateFields() {
LowTasks.c:  Reduction2D = CreateField2D ("Reduction2D", YZ);
LowTasks.c:#if (defined(X) || defined(MHD))
LowTasks.c:  Mpx              = CreateField   ("Moment_Plus_X" , 0, 1,0,0);
LowTasks.c:  Mmx              = CreateField   ("Moment_Minus_X", 0, 1,0,0);
LowTasks.c:  Vxhy             = CreateField2D ("Vxhy"    , YZ);
LowTasks.c:  Vxhyr            = CreateField2D ("Vxhyr"   , YZ);
LowTasks.c:  Vxhz             = CreateField2D ("Vxhz"    , YZ);
LowTasks.c:  Vxhzr            = CreateField2D ("Vxhzr"   , YZ);
LowTasks.c:  Nshift = CreateFieldInt2D ("Nshift");
LowTasks.c:  Nxhy   = CreateFieldInt2D ("Nxhy");
LowTasks.c:  Nxhz   = CreateFieldInt2D ("Nxhz");
LowTasks.c:#endif
LowTasks.c:#if (defined(Y) || defined(MHD))
LowTasks.c:  Mpy     = CreateField("Moment_Plus_Y" , 0,0,1,0);
LowTasks.c:  Mmy     = CreateField("Moment_Minus_Y", 0,0,1,0);
LowTasks.c:#endif
LowTasks.c:#if (defined(Z) || defined(MHD))
LowTasks.c:  Mpz     = CreateField("Moment_Plus_Z" , 0,0,0,1);
LowTasks.c:  Mmz     = CreateField("Moment_Minus_Z", 0,0,0,1);
LowTasks.c:#endif
LowTasks.c:  Pot     = CreateField("potential", 0,0,0,0);
LowTasks.c:  Slope   = CreateField("Slope"    , 0,0,0,0);
LowTasks.c:  DivRho  = CreateField("DivRho"   , 0,0,0,0);  // This field cannot
LowTasks.c:						// be aliased wherever
LowTasks.c:						// reductions are
LowTasks.c:						// needed
LowTasks.c:  DensStar      = CreateField("DensStar"     , 0,0,0,0);
LowTasks.c:  Qs            = CreateField("Qs"           , 0,0,0,0);
LowTasks.c:  Pressure      = CreateField("Pressure"     , 0,0,0,0);
LowTasks.c:  Total_Density = CreateField("Total_Density", 0,0,0,0);
LowTasks.c:  QL      = CREATEFIELDALIAS("QLeft", Pressure, 0);
LowTasks.c:  QR      = CreateField("QRight", 0,0,0,0);
LowTasks.c:#ifdef RAM  
LowTasks.c:  PhiStarmin = CreateField("PhiStarmin", 0,0,0,0);
LowTasks.c:  UStarmin   = CreateField("UStarmin", 0,0,0,0);
LowTasks.c:#endif
LowTasks.c:#ifdef PPA_STEEPENER
LowTasks.c:  LapPPA  = CreateField("LapPPA", 0,0,0,0);
LowTasks.c:#endif
LowTasks.c:#ifdef DUSTDIFFUSION
LowTasks.c:#ifdef Z
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:#ifdef MHD
LowTasks.c:  Bx      = CreateField("bx", BX,1,0,0);
LowTasks.c:  By      = CreateField("by", BY,0,1,0);
LowTasks.c:  Bz      = CreateField("bz", BZ,0,0,1);
LowTasks.c:  V1_star = CREATEFIELDALIAS("V1_star" , Pressure , 0);
LowTasks.c:  Slope_b1= CREATEFIELDALIAS("Slope_b1", Mpx      , 0);
LowTasks.c:  Slope_v1= CREATEFIELDALIAS("Slope_v1", Mmy      , 0);
LowTasks.c:  Slope_b2= CREATEFIELDALIAS("Slope_b2", DensStar , 0);
LowTasks.c:  Slope_v2= CREATEFIELDALIAS("Slope_v2", Qs       , 0);
LowTasks.c:  Emfy    = CREATEFIELDALIAS("Emfy", Slope , EMFY);
LowTasks.c:  Emfz    = CREATEFIELDALIAS("Emfz", DivRho, EMFZ); // Legal ?? we cannot alise DivRho it seems...
LowTasks.c:#if (defined(HALLEFFECT) || defined(AMBIPOLARDIFFUSION))
LowTasks.c:  Jx      = CreateField("Jx"     ,0,0,0,0);
LowTasks.c:  Jy      = CreateField("Jy"     ,0,0,0,0);
LowTasks.c:  Jz      = CreateField("Jz"     ,0,0,0,0);
LowTasks.c:#endif
LowTasks.c:#ifdef OHMICDIFFUSION
LowTasks.c:  EtaOhm = CreateField("EtaOhm",0,0,0,0);
LowTasks.c:#endif
LowTasks.c:#ifdef HALLEFFECT
LowTasks.c:  EmfxH   = CreateField("EmfxH"  ,0,0,0,0);
LowTasks.c:  EmfyH   = CreateField("EmfyH"  ,0,0,0,0);
LowTasks.c:  EmfzH   = CreateField("EmfzH"  ,0,0,0,0);
LowTasks.c:  BxH     = CreateField("BxH"    ,0,0,0,0);
LowTasks.c:  ByH     = CreateField("ByH"    ,0,0,0,0);
LowTasks.c:  BzH     = CreateField("BzH"    ,0,0,0,0);
LowTasks.c:  EtaHall = CreateField("EtaHall",0,0,0,0);
LowTasks.c:#endif
LowTasks.c:#ifdef AMBIPOLARDIFFUSION
LowTasks.c:  EtaAD = CreateField("EtaAD",0,0,0,0);
LowTasks.c:#endif
LowTasks.c:  //Claim ownership of storage area
LowTasks.c:  *(Emfx->owner) = Emfx;
LowTasks.c:  *(Emfy->owner) = Emfy;
LowTasks.c:  *(Emfz->owner) = Emfz;
LowTasks.c:  Divergence = CreateField("divb", 0, 0,0,0);  
LowTasks.c:#endif
LowTasks.c:real ComputeMass() {
LowTasks.c:  real mass = 0;
LowTasks.c:  real totalmass;
LowTasks.c:  real *rho;
LowTasks.c:  INPUT (Density);
LowTasks.c:  rho = Density->field_cpu;
LowTasks.c:#ifdef Z
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:#endif
LowTasks.c:#ifdef X
LowTasks.c:#endif
LowTasks.c:#ifdef X
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:#endif
LowTasks.c:#ifdef FLOAT
LowTasks.c:  MPI_Allreduce(&mass, &totalmass, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
LowTasks.c:  masterprint("TotalMass = %3.10f \n", totalmass );
LowTasks.c:#else
LowTasks.c:  MPI_Allreduce(&mass, &totalmass, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
LowTasks.c:  masterprint("TotalMass = %3.10lf \n", totalmass );
LowTasks.c:#endif
LowTasks.c:  return totalmass;
LowTasks.c:void SaveState () {
LowTasks.c:  Field *current;
LowTasks.c:  real *backup;
LowTasks.c:  int size;
LowTasks.c:  current = ListOfGrids;
LowTasks.c:  size = sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ);
LowTasks.c:  while (current != NULL) {
LowTasks.c:    if (current->backup == NULL) {
LowTasks.c:      // No space has been reserved yet for the backup. We take care of that below
LowTasks.c:      backup = (real *)malloc(size);
LowTasks.c:	prs_error ("Insufficient memory for check point creation\n");
LowTasks.c:      current->backup = backup;
LowTasks.c:    if (*(current->owner) == current) {
LowTasks.c:      INPUT (current);
LowTasks.c:      memcpy (current->backup, current->field_cpu, size);
LowTasks.c:    current = current->next;
LowTasks.c:  masterprint("\n\n******\nCheck point created\n******\n\n");
LowTasks.c:void SaveStateSecondary () {
LowTasks.c:  Field *current;
LowTasks.c:  real *backup;
LowTasks.c:  int size;
LowTasks.c:  current = ListOfGrids;
LowTasks.c:  size = sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ);
LowTasks.c:  while (current != NULL) {
LowTasks.c:    if (current->secondary_backup == NULL) {
LowTasks.c:      // No space has been reserved yet for the secondary backup. We take care of that below
LowTasks.c:      backup = (real *)malloc(size);
LowTasks.c:	prs_error ("Insufficient memory for check point creation\n");
LowTasks.c:      current->secondary_backup = backup;
LowTasks.c:    if (*(current->owner) == current) {
LowTasks.c:      INPUT (current);
LowTasks.c:      memcpy (current->secondary_backup, current->field_cpu, size);
LowTasks.c:    current = current->next;
LowTasks.c:  masterprint("\n\n******\nSecondary Check point created\n******\n\n");
LowTasks.c:void RestoreState () {
LowTasks.c:  Field *current;
LowTasks.c:  int size;
LowTasks.c:  current = ListOfGrids;
LowTasks.c:  while (current != NULL) {
LowTasks.c:    if (current->backup == NULL) {
LowTasks.c:      prs_error ("Cannot restore state: no check point ever created\n");
LowTasks.c:    size = sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ);
LowTasks.c:    if (*(current->owner) == current) {
LowTasks.c:      memcpy (current->field_cpu, current->backup, size);
LowTasks.c:      OUTPUT (current);
LowTasks.c:    current = current->next;
LowTasks.c:  masterprint("\n\n******\nCheck point restored\n*******\n\n");
LowTasks.c:int RestartSimulation(int n) {
LowTasks.c:  int begin;
LowTasks.c:  masterprint("Restarting simulation...\n");
LowTasks.c:#ifndef MPIIO
LowTasks.c:    __Restart = RestartVTK;
LowTasks.c:  else
LowTasks.c:    __Restart = RestartDat;
LowTasks.c:    Merge = YES;
LowTasks.c:    __Restart = RestartDat;
LowTasks.c:    Merge = YES;
LowTasks.c:    __Restart = RestartVTK;
LowTasks.c:  __Restart(Density, n);
LowTasks.c:#ifdef X
LowTasks.c:  __Restart(Vx, n);
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:  __Restart(Vy, n);
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:  __Restart(Vz, n);
LowTasks.c:#endif
LowTasks.c:      if(Fluidtype != DUST) __Restart(Energy, n);
LowTasks.c:#ifdef MHD
LowTasks.c:  __Restart(Bx, n);
LowTasks.c:  __Restart(By, n);
LowTasks.c:  __Restart(Bz, n);
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:#ifdef MPIIO
LowTasks.c:  MPI_Offset offset;
LowTasks.c:  offset = 0; //We start at the begining of the file
LowTasks.c:  offset = ParallelIO(Density, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:  if(Fluidtype != DUST)  offset = ParallelIO(Energy, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:#ifdef X
LowTasks.c:  offset = ParallelIO(Vx, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:#endif
LowTasks.c:#ifdef Y
LowTasks.c:  offset = ParallelIO(Vy, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:#endif
LowTasks.c:#ifdef Z
LowTasks.c:  offset = ParallelIO(Vz, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:#endif
LowTasks.c:#ifdef MHD //MHD is 3D.
LowTasks.c:  if(Fluidtype == GAS){
LowTasks.c:    offset = ParallelIO(Bx, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:    offset = ParallelIO(By, n, MPI_MODE_RDONLY, offset,FALSE);
LowTasks.c:    offset = ParallelIO(Bz, n, MPI_MODE_RDONLY, offset,FALSE);    
LowTasks.c:#endif
LowTasks.c:#endif
LowTasks.c:  begin = n*NINTERM;
LowTasks.c:  if (PostRestart)
LowTasks.c:    PostRestartHook ();
LowTasks.c:  return begin;
LowTasks.c:void RestartVTK(Field *f, int n) {
LowTasks.c:  char filename[200];
LowTasks.c:  char *name;
LowTasks.c:  char line[MAXLINELENGTH*max3(NX,NY,NZ)];
LowTasks.c:  real temp1;
LowTasks.c:  int temp;
LowTasks.c:  int relay;
LowTasks.c:  name = f->name;
LowTasks.c:  if (Restart) {
LowTasks.c:    sprintf(filename, "%s%s%d_%d.vtk", OUTPUTDIR, name, n, CPU_Rank);
LowTasks.c:    fi = fopen(filename, "r");
LowTasks.c:      masterprint("Error reading %s\n", filename);
LowTasks.c:      exit(1);
LowTasks.c:    masterprint("Reading %s\n", filename);
LowTasks.c:    while(1) {
LowTasks.c:      temp = fscanf(fi, "%s\n", line);
LowTasks.c:      if (strcmp(line,"LOOKUP_TABLE") == 0){
LowTasks.c:	temp = fscanf(fi, "%s\n", line);
LowTasks.c:	break;
LowTasks.c:#ifndef SPHERICAL
LowTasks.c:	  temp = fread(&temp1, sizeof(real), 1, fi);
LowTasks.c:	  f->field_cpu[l] = Swap(temp1);
LowTasks.c:#else
LowTasks.c:	  temp = fread(&temp1, sizeof(real), 1, fi);
LowTasks.c:	  f->field_cpu[l] = Swap(temp1);
LowTasks.c:#endif
LowTasks.c:  if (Restart_Full) {
LowTasks.c:    sprintf(filename, "%s%s%d.vtk", OUTPUTDIR, name, n);
LowTasks.c:    fi = fopen(filename, "r");
LowTasks.c:      masterprint("Error reading %s\n", filename);
LowTasks.c:      exit(1);
LowTasks.c:    masterprint("Reading %s\n", filename);
LowTasks.c:    while(1) {
LowTasks.c:      temp = fscanf(fi, "%s\n", line);
LowTasks.c:      if (strcmp(line,"LOOKUP_TABLE") == 0){
LowTasks.c:	temp = fscanf(fi, "%s\n", line);
LowTasks.c:	curpos = ftell(fi);
LowTasks.c:	break;
LowTasks.c:#ifndef SPHERICAL
LowTasks.c:	fseek(fi, curpos+(origin+(i-NGHX)*NY+(k-NGHZ)*NX*NY)*sizeof(real), SEEK_SET);
LowTasks.c:	  temp = fread(&temp1, sizeof(real), 1, fi);
LowTasks.c:	  f->field_cpu[l] = Swap(temp1);
LowTasks.c:#else
LowTasks.c:	fseek(fi, curpos+(origin+(i-NGHX)*NY+(k-NGHZ)*NX*NY)*sizeof(real), SEEK_SET);
LowTasks.c:	  temp = fread(&temp1, sizeof(real), 1, fi);
LowTasks.c:	  f->field_cpu[l] = Swap(temp1);
LowTasks.c:#endif
LowTasks.c:    fclose(fi);
LowTasks.c:void RestartDat(Field *field, int n) {
LowTasks.c:  real *f;
LowTasks.c:  char *name;
LowTasks.c:  char filename[200];
LowTasks.c:  int temp;
LowTasks.c:  f = field->field_cpu;
LowTasks.c:  name = field->name;
LowTasks.c:  if(Restart == YES) {
LowTasks.c:    sprintf(filename, "%s%s%d_%d.dat", OUTPUTDIR, name, n, CPU_Rank);
LowTasks.c:    fi = fopen(filename, "r");
LowTasks.c:      masterprint("Error reading %s\n", filename);
LowTasks.c:      exit(1);
LowTasks.c:    masterprint("Reading %s\n", filename);
LowTasks.c:	temp = fread(f+j*(Nx+2*NGHX)+k*Stride+NGHX, sizeof(real), Nx, fi);
LowTasks.c:    masterprint("%s OK\n", filename);
LowTasks.c:    fclose(fi);
LowTasks.c:    if(Restart_Full == YES) {
LowTasks.c:      masterprint("Only one restart option must be enabled.\n");
LowTasks.c:      MPI_Finalize();
LowTasks.c:  MPI_Barrier(MPI_COMM_WORLD);
LowTasks.c:  if(Restart_Full == YES) {
LowTasks.c:    sprintf(filename, "%s%s%d.dat", OUTPUTDIR, name, n);
LowTasks.c:    fi = fopen(filename, "r");
LowTasks.c:      masterprint("Error reading %s\n", filename);
LowTasks.c:      exit(1);
LowTasks.c:    masterprint("Reading %s\n", filename);
LowTasks.c:    origin = (z0cell)*NX*NY + (y0cell)*NX; //z0cell and y0cell are global variables.
LowTasks.c:      fseek(fi, (origin+(k-NGHZ)*NX*NY)*sizeof(real), SEEK_SET); // critical part
LowTasks.c:	temp = fread(f+k*Stride+j*(Nx+2*NGHX)+NGHX, sizeof(real), Nx, fi);
LowTasks.c:    masterprint("%s OK\n", filename);
LowTasks.c:    fclose(fi);
LowTasks.c:    if(Restart == YES) {
LowTasks.c:      masterprint("Only one restart option must be enabled.\n");
LowTasks.c:      MPI_Finalize();
ShearingPeriodicBC.c:#include "fargo3d.h"
ShearingPeriodicBC.c:static real SB_resi[2];
ShearingPeriodicBC.c:static real SlideVel;
ShearingPeriodicBC.c:// Below is a set of routines used for the shearing-periodic
ShearingPeriodicBC.c:// conditions. It shifts the outer and inner "radial" ghost zones,
ShearingPeriodicBC.c:// prior to a periodic type communication.
ShearingPeriodicBC.c:/* This routine is in Beta version and should not be used without
ShearingPeriodicBC.c:   intensive prior testing */
ShearingPeriodicBC.c:/* These boundary conditions only run on the CPU at the present time,
ShearingPeriodicBC.c:   which somehow impacts performance */
ShearingPeriodicBC.c:void ShearBC (int var) {
ShearingPeriodicBC.c:  FARGO_SAFE(ShearingPeriodicCondition()); // Determine integer and
ShearingPeriodicBC.c:  //fractional shifts at inner and outer boundaries
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Density));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vx));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vy));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vz));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vx_temp));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vy_temp));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Vz_temp));
ShearingPeriodicBC.c:#ifdef ADIABATIC
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Energy));
ShearingPeriodicBC.c:#endif
ShearingPeriodicBC.c:#ifdef MHD
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Emfx));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Emfy));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Emfz));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Bx));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (By));
ShearingPeriodicBC.c:    FARGO_SAFE(SB_slide (Bz));
ShearingPeriodicBC.c:#endif
ShearingPeriodicBC.c:void SB_slide (Field *F) {
ShearingPeriodicBC.c:  FARGO_SAFE(SlideResShearingBoundary (F));
ShearingPeriodicBC.c:  FARGO_SAFE(SlideIntShearingBoundary (F));
ShearingPeriodicBC.c:void ShearingPeriodicCondition () {
ShearingPeriodicBC.c:  real shift_total, nfrac;
ShearingPeriodicBC.c:  SlideVel = 2.*(YMAX-YMIN)*OORTA;
ShearingPeriodicBC.c:  shift_total = SlideVel*PhysicalTime;
ShearingPeriodicBC.c:  while (shift_total < 0.0)  shift_total += XMAX-XMIN;
ShearingPeriodicBC.c:  while (shift_total >= XMAX-XMIN) shift_total -= XMAX-XMIN;
ShearingPeriodicBC.c:  nfrac = ((real)Nx*shift_total/(XMAX-XMIN));
ShearingPeriodicBC.c:  SB_resi[1] = nfrac - SB_nint[1];
ShearingPeriodicBC.c:  while (shift_total < 0.0)  shift_total += XMAX-XMIN;
ShearingPeriodicBC.c:  nfrac = ((real)Nx*shift_total/(XMAX-XMIN));
ShearingPeriodicBC.c:  SB_resi[0] = nfrac - SB_nint[0];
ShearingPeriodicBC.c:void SlideIntShearingBoundary (Field *F) {
ShearingPeriodicBC.c:  int i,j,k,side,ii,exception_by=0;
ShearingPeriodicBC.c:  real *f;
ShearingPeriodicBC.c:  static real buffer[MAX1D];
ShearingPeriodicBC.c:  f = F->field_cpu;
ShearingPeriodicBC.c:  if (F->type == BY)
ShearingPeriodicBC.c:    exception_by = 1;
ShearingPeriodicBC.c:  for (side = 0; side < 2; side++) {
ShearingPeriodicBC.c:    if (((side == 0) && (J == 0)) || ((side == 1) && (J == Ncpu_x-1))) {
ShearingPeriodicBC.c:	for (j = side*(Ny+NGHY)+side*exception_by; j < side*(Ny+NGHY)+NGHY; j++) {
ShearingPeriodicBC.c:	    ii = i+SB_nint[side];
ShearingPeriodicBC.c:	    while (ii >= Nx) ii -= Nx;
ShearingPeriodicBC.c:	    while (ii < 0) ii += Nx;
ShearingPeriodicBC.c:	    buffer[ii] = f[l];
ShearingPeriodicBC.c:	    f[l] = buffer[i];
ShearingPeriodicBC.c:void SlideResShearingBoundary (Field *Q) {
ShearingPeriodicBC.c:  int i,j,k,side;
ShearingPeriodicBC.c:  real dqm, dqp, work, diff, cord, ksi;
ShearingPeriodicBC.c:  real *q;
ShearingPeriodicBC.c:  static real qs[MAX1D], slope[MAX1D], qL[MAX1D], qR[MAX1D], qH[MAX1D];
ShearingPeriodicBC.c:  boolean IsVx=NO;
ShearingPeriodicBC.c:  int exception_by=0;
ShearingPeriodicBC.c:  q  = Q->field_cpu;
ShearingPeriodicBC.c:  if (((Q->type == VX) || (Q->type == VXTEMP)) && (VxIsResidual == NO))
ShearingPeriodicBC.c:  if (Q->type == BY)
ShearingPeriodicBC.c:    exception_by = 1;
ShearingPeriodicBC.c:  for (side = 0; side < 2; side++) {
ShearingPeriodicBC.c:    if (((side == 0) && (J == 0)) || ((side == 1) && (J == Ncpu_x-1))) {
ShearingPeriodicBC.c:	for (j=(Ny+NGHY)*side+side*exception_by; j<NGHY+(Ny+NGHY)*side; j++) { //Inner or outer radial ghost
ShearingPeriodicBC.c:	    if(dqp*dqm<=0.0)  slope[i] = 0.0;
ShearingPeriodicBC.c:	    else { // Monotonized centered slope limited
ShearingPeriodicBC.c:	      slope[i] = 0.5*(q[lxp]-q[lxm]);
ShearingPeriodicBC.c:	      work = fabs(slope[i]);
ShearingPeriodicBC.c:	      if (slope[i] < 0) slope[i] = -work;
ShearingPeriodicBC.c:	      else slope[i] = work;
ShearingPeriodicBC.c:	  for (i=0; i<Nx; i++)	// Now we compute q_j+1/2
ShearingPeriodicBC.c:	    qH[i] = q[l]+0.5*(q[lxp]-q[l])-1.0/6.0*(slope[ixp]-slope[i]);
ShearingPeriodicBC.c:	  for (i=0; i<Nx; i++) {  // Now we compute qRight & qLeft
ShearingPeriodicBC.c:	  /* -> Modify qRight & qLeft */
ShearingPeriodicBC.c:	  /* Now we've got qRight & qLeft */
ShearingPeriodicBC.c:	  /* Switch back to Stone & Norman paper */
ShearingPeriodicBC.c:	    if (SB_resi[side] > 0.0) {
ShearingPeriodicBC.c:	      ksi = SB_resi[side];
ShearingPeriodicBC.c:	    } else {
ShearingPeriodicBC.c:	      ksi = -SB_resi[side];
ShearingPeriodicBC.c:	  for (i = 0; i<Nx; i++) { // Final update
ShearingPeriodicBC.c:	    q[l] += (qs[i]-qs[ixp])*SB_resi[side];
ShearingPeriodicBC.c:	      q[l] += (real)(2*side-1)*2.0*OORTA*(YMAX-YMIN);
addviscosity_cart.c://#define __GPU
addviscosity_cart.c://#define __NOPROTO
addviscosity_cart.c:#include "fargo3d.h"
addviscosity_cart.c:void addviscosity_cart_cpu(real dt) {
addviscosity_cart.c:  INPUT(Density);
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:  INPUT(Vx_temp);
addviscosity_cart.c:  OUTPUT(Vx_temp);
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:  INPUT(Vy_temp);
addviscosity_cart.c:  OUTPUT(Vy_temp);
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:  INPUT(Vz_temp);
addviscosity_cart.c:  OUTPUT(Vz_temp);
addviscosity_cart.c:#endif
addviscosity_cart.c:  real* rho = Density->field_cpu;
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:  real* vx = Vx_temp->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:  real* vy = Vy_temp->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:  real* vz = Vz_temp->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:  real* tauxx = Mmx->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:  real* tauyy = Mmy->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:  real* tauzz = Mmz->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(X) && defined(Z)
addviscosity_cart.c:  real* tauxz = Mpx->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(Y) && defined(X)
addviscosity_cart.c:  real* tauyx = Mpy->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(Z) && defined(Y)
addviscosity_cart.c:  real* tauzy = Mpz->field_cpu;
addviscosity_cart.c:#endif
addviscosity_cart.c:  int stride = Stride_cpu;
addviscosity_cart.c:  int size_x = XIP;
addviscosity_cart.c:  int size_y = Ny+2*NGHY-2;
addviscosity_cart.c:  int size_z = Nz+2*NGHZ-2;
addviscosity_cart.c:// real xmin(Nx+1);
addviscosity_cart.c:// real InvDiffXmed(Nx+1);
addviscosity_cart.c:// real ymin(Ny+2*NGHY+1);
addviscosity_cart.c:// real zmin(Nz+2*NGHZ+1);
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:  for(k=1; k<size_z; k++) {
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:    for(j=1; j<size_y; j++) {
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:      for(i=XIM; i<size_x; i++) {
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:  vx[l] += 2.0*(tauxx[l]-tauxx[lxm])/((rho[l]+rho[lxm]))*dt*Inv_zone_size_xmed(i,j,k);
addviscosity_cart.c:#if defined(Y) && defined(X)
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(X) && defined(Z)
addviscosity_cart.c:#endif
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:	vy[l] += 2.0*(tauyy[l]-tauyy[lym])/((ymed(j)-ymed(j-1))*(rho[l]+rho[lym]))*dt;
addviscosity_cart.c:#if defined(Y) && defined(X)
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(Z) && defined(Y)
addviscosity_cart.c:#endif
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:	vz[l] += 2.0*(tauzz[l]-tauzz[lzm])/((zmed(k)-zmed(k-1))*(rho[l]+rho[lzm]))*dt;
addviscosity_cart.c:#if defined(Z) && defined(X)
addviscosity_cart.c:#endif
addviscosity_cart.c:#if defined(Z) && defined(Y)
addviscosity_cart.c:#endif
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef X
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Y
addviscosity_cart.c:#endif
addviscosity_cart.c:#ifdef Z
addviscosity_cart.c:#endif
addviscosity_cyl.c://#define __GPU
addviscosity_cyl.c://#define __NOPROTO
addviscosity_cyl.c:#include "fargo3d.h"
addviscosity_cyl.c:void addviscosity_cyl_cpu(real dt) {
addviscosity_cyl.c:  INPUT(Density);
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:  INPUT(Vx_temp);
addviscosity_cyl.c:  OUTPUT(Vx_temp);
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:  INPUT(Vy_temp);
addviscosity_cyl.c:  OUTPUT(Vy_temp);
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:  INPUT(Vz_temp);
addviscosity_cyl.c:  OUTPUT(Vz_temp);
addviscosity_cyl.c:#endif
addviscosity_cyl.c:  real* rho = Density->field_cpu;
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:  real* vx = Vx_temp->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:  real* vy = Vy_temp->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:  real* vz = Vz_temp->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:  real* tauxx = Mmx->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:  real* tauyy = Mmy->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:  real* tauzz = Mmz->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(X) && defined(Z)
addviscosity_cyl.c:  real* tauxz = Mpx->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(Y) && defined(X)
addviscosity_cyl.c:  real* tauyx = Mpy->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(Z) && defined(Y)
addviscosity_cyl.c:  real* tauzy = Mpz->field_cpu;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:  int stride = Stride_cpu;
addviscosity_cyl.c:  int size_x = XIP;
addviscosity_cyl.c:  int size_y = Ny+2*NGHY-2;
addviscosity_cyl.c:  int size_z = Nz+2*NGHZ-2;
addviscosity_cyl.c:// real xmin(Nx+1);
addviscosity_cyl.c:// real InvDiffXmed(Nx+1);
addviscosity_cyl.c:// real ymin(Ny+2*NGHY+1);
addviscosity_cyl.c:// real zmin(Nz+2*NGHZ+1);
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:  for(k=1; k<size_z; k++) {
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:    for(j=1; j<size_y; j++) {
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:      for(i=XIM; i<size_x; i++) {
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:	vx[l] += 2.0*(tauxx[l]-tauxx[lxm])*Inv_zone_size_xmed(i,j,k)/((rho[l]+rho[lxm]))*dt;
addviscosity_cyl.c:#if defined(Y) && defined(X)
addviscosity_cyl.c:	vx[l] += 2.0*(ymin(j+1)*ymin(j+1)*tauyx[lyp]-ymin(j)*ymin(j)*tauyx[l])/((ymin(j+1)-ymin(j))*ymed(j)*ymed(j)*(rho[lxm]+rho[l]))*dt;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(X) && defined(Z)
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:	vy[l] += 2.0*(ymed(j)*tauyy[l]-ymed(j-1)*tauyy[lym])/((ymed(j)-ymed(j-1))*(rho[l]+rho[lym])*ymin(j))*dt;
addviscosity_cyl.c:#if defined(Y) && defined(X)
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(X)
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(Z) && defined(Y)
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:	vz[l] += 2.0*(tauzz[l]-tauzz[lzm])/((zmed(k)-zmed(k-1))*(rho[l]+rho[lzm]))*dt;
addviscosity_cyl.c:#if defined(Z) && defined(X)
addviscosity_cyl.c:	vz[l] += 2.0*(tauxz[lxp]-tauxz[l])/(zone_size_x(i,j,k)*(rho[l]+rho[lzm]))*dt;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#if defined(Z) && defined(Y)
addviscosity_cyl.c:	vz[l] += 2.0*(ymin(j+1)*tauzy[lyp]-ymin(j)*tauzy[l])/((ymin(j+1)-ymin(j))*ymed(j)*(rho[l]+rho[lzm]))*dt;
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef X
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Y
addviscosity_cyl.c:#endif
addviscosity_cyl.c:#ifdef Z
addviscosity_cyl.c:#endif
addviscosity_sph.c://#define __GPU
addviscosity_sph.c://#define __NOPROTO
addviscosity_sph.c:#include "fargo3d.h"
addviscosity_sph.c:void addviscosity_sph_cpu(real dt) {
addviscosity_sph.c:  INPUT(Density);
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:  INPUT(Vx_temp);
addviscosity_sph.c:  OUTPUT(Vx_temp);
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:  INPUT(Vy_temp);
addviscosity_sph.c:  OUTPUT(Vy_temp);
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:  INPUT(Vz_temp);
addviscosity_sph.c:  OUTPUT(Vz_temp);
addviscosity_sph.c:#endif
addviscosity_sph.c:  real* rho = Density->field_cpu;
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:  real* vx = Vx_temp->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:  real* vy = Vy_temp->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:  real* vz = Vz_temp->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:  real* tauxx = Mmx->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:  real* tauyy = Mmy->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:  real* tauzz = Mmz->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(X) && defined(Z)
addviscosity_sph.c:  real* tauxz = Mpx->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(Y) && defined(X)
addviscosity_sph.c:  real* tauyx = Mpy->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(Z) && defined(Y)
addviscosity_sph.c:  real* tauzy = Mpz->field_cpu;
addviscosity_sph.c:#endif
addviscosity_sph.c:  int stride = Stride_cpu;
addviscosity_sph.c:  int size_x = XIP;
addviscosity_sph.c:  int size_y = Ny+2*NGHY-2;
addviscosity_sph.c:  int size_z = Nz+2*NGHZ-2;
addviscosity_sph.c:// real xmin(Nx+1);
addviscosity_sph.c:// real InvDiffXmed(Nx+1);
addviscosity_sph.c:// real ymin(Ny+2*NGHY+1);
addviscosity_sph.c:// real zmin(Nz+2*NGHZ+1);
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:  for(k=1; k<size_z; k++) {
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:    for(j=1; j<size_y; j++) {
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:      for(i=XIM; i<size_x; i++) {
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:	vx[l] += 2.0*(tauxx[l]-tauxx[lxm])*Inv_zone_size_xmed(i,j,k)/((rho[l]+rho[lxm]))*dt;
addviscosity_sph.c:#if defined(Y) && defined(X)
addviscosity_sph.c:	vx[l] += 2.0*(ymin(j+1)*ymin(j+1)*tauyx[lyp]-ymin(j)*ymin(j)*tauyx[l])/((ymin(j+1)-ymin(j))*ymed(j)*ymed(j)*(rho[lxm]+rho[l]))*dt;
addviscosity_sph.c:	vx[l] += (tauyx[lyp]+tauyx[l])/((rho[lxm]+rho[l])*ymed(j))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(X) && defined(Z)
addviscosity_sph.c:	vx[l] += 2.0*(tauxz[lzp]-tauxz[l])/(zone_size_z(j,k)*(rho[lxm]+rho[l]))*dt;
addviscosity_sph.c:	vx[l] += 2.0*(tauxz[lzp]+tauxz[l])*cos(zmed(k))/(sin(zmed(k))*ymed(j)*(rho[lxm]+rho[l]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:	vy[l] += 2.0*(ymed(j)*ymed(j)*tauyy[l]-ymed(j-1)*ymed(j-1)*tauyy[lym])/((ymed(j)-ymed(j-1))*(rho[l]+rho[lym])*ymin(j)*ymin(j))*dt;
addviscosity_sph.c:#if defined(Y) && defined(X)
addviscosity_sph.c:  vy[l] += 2.0*(tauyx[lxp]-tauyx[l])/( (xmin(i+1)-xmin(i))*ymin(j)*sin(zmed(k))*(rho[l]+rho[lym]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(X)
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(Z)
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(Z) && defined(Y)
addviscosity_sph.c:	vy[l] += 2.0*(tauzy[lzp]*sin(zmin(k+1))-tauzy[l]*sin(zmin(k)))/((zmin(k+1)-zmin(k))*ymin(j)*sin(zmed(k))*(rho[l]+rho[lym]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:	vz[l] += 2.0*(tauzz[l]*sin(zmed(k))-tauzz[lzm]*sin(zmed(k-1)))/((zmed(k)-zmed(k-1))*ymed(j)*sin(zmin(k))*(rho[l]+rho[lzm]))*dt;
addviscosity_sph.c:#if defined(Z) && defined(X)
addviscosity_sph.c:	vz[l] += 2.0*(tauxz[lxp]-tauxz[l])/(edge_size_x_middley_lowz(i,j,k)*(rho[l]+rho[lzm]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(Z) && defined(Y)
addviscosity_sph.c:	vz[l] += 2.0*(ymin(j+1)*ymin(j+1)*ymin(j+1)*tauzy[lyp]-ymin(j)*ymin(j)*ymin(j)*tauzy[l])/((ymin(j+1)-ymin(j))*ymed(j)*ymed(j)*ymed(j)*(rho[l]+rho[lzm]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#if defined(X)
addviscosity_sph.c:	vz[l] -= (tauxx[l]+tauxx[lzm])*cos(zmin(k))/(ymed(j)*sin(zmin(k))*(rho[l]+rho[lzm]))*dt;
addviscosity_sph.c:#endif
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef X
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Y
addviscosity_sph.c:#endif
addviscosity_sph.c:#ifdef Z
addviscosity_sph.c:#endif
advect_shift.c://#define __GPU
advect_shift.c:#include "fargo3d.h"
advect_shift.c:void AdvectSHIFT_cpu (Field *F, FieldInt2D *NS) {
advect_shift.c:  DRAFT(Pressure);
advect_shift.c:  real* f     = F->field_cpu;
advect_shift.c:  real* aux   = Pressure->field_cpu;
advect_shift.c:  int* nshift = NS->field_cpu;
advect_shift.c:  int stride  = Stride_cpu;
advect_shift.c:  int size_x  = Nx+2*NGHX;
advect_shift.c:  int size_y  = Ny+2*NGHY;
advect_shift.c:  int size_z  = Nz+2*NGHZ;
advect_shift.c:  int i; //Variables reserved
advect_shift.c:  int j; //for the topology
advect_shift.c:  int k; //of the kernels
advect_shift.c:  int itarget;
advect_shift.c:  int ltarget;
advect_shift.c:  for (k = 0; k < size_z; k++) {
advect_shift.c:    for (j = 0; j < size_y; j++) {
advect_shift.c:      for (i = 0; i < size_x; i++) {
advect_shift.c:	itarget = i-nshift[l2D_int];
advect_shift.c:	while (itarget <  NGHX)  itarget += nx;
advect_shift.c:	while (itarget >= nx+NGHX) itarget -= nx;
advect_shift.c:	ltarget = ll-i+itarget;
advect_shift.c:	aux[ll] = f[ltarget];
advect_shift.c:#ifdef __GPU
advect_shift.c:  Dev2Dev3D(F,Pressure);
advect_shift.c:#else
advect_shift.c:  memcpy(f, aux, sizeof(real)*size_x*size_y*size_z);
advect_shift.c:#endif
algogas.c:#include "fargo3d.h"
algogas.c:TimeProcess t_Comm;
algogas.c:TimeProcess t_Hydro;
algogas.c:TimeProcess t_Mhd;
algogas.c:TimeProcess t_sub1;
algogas.c:TimeProcess t_sub1_x;
algogas.c:TimeProcess t_sub1_y;
algogas.c:TimeProcess t_sub1_z;
algogas.c:  InitSpecificTime (&t_Comm, "MPI Communications");
algogas.c:  GiveSpecificTime (t_Comm);
algogas.c:  FARGO_SAFE(boundaries()); // Always after a comm.
algogas.c:#if defined(Y)
algogas.c:  if (NY == 1)    /* Y dimension is mute */
algogas.c:    CheckMuteY();
algogas.c:#endif
algogas.c:#if defined(Z)
algogas.c:  if (NZ == 1)    /* Z dimension is mute */
algogas.c:    CheckMuteZ();
algogas.c:#endif
algogas.c:void Sources(real dt) {
algogas.c:  SetupHook1 (); //Setup specific hook. Defaults to empty function.
algogas.c:  //Equations of state-----------------------------------------------------------
algogas.c:#ifdef ADIABATIC
algogas.c:  FARGO_SAFE(ComputePressureFieldAd());
algogas.c:#endif
algogas.c:#ifdef ISOTHERMAL
algogas.c:  FARGO_SAFE(ComputePressureFieldIso());
algogas.c:#endif
algogas.c:#ifdef POLYTROPIC
algogas.c:  FARGO_SAFE(ComputePressureFieldPoly());
algogas.c:#endif
algogas.c:  InitSpecificTime (&t_Hydro, "Eulerian Hydro (no transport) algorithms");
algogas.c:#ifdef POTENTIAL
algogas.c:  FARGO_SAFE(compute_potential(dt));
algogas.c:    FARGO_SAFE(CorrectVtheta(Domega));
algogas.c:#endif
algogas.c:#if ((defined(SHEARINGSHEET2D) || defined(SHEARINGBOX3D)) && !defined(SHEARINGBC))
algogas.c:  FARGO_SAFE(NonReflectingBC(Vy));
algogas.c:#endif
algogas.c:#ifdef X
algogas.c:  FARGO_SAFE(SubStep1_x(dt));
algogas.c:#endif    
algogas.c:#ifdef Y
algogas.c:  FARGO_SAFE(SubStep1_y(dt));
algogas.c:#endif  
algogas.c:#ifdef Z
algogas.c:  FARGO_SAFE(SubStep1_z(dt));
algogas.c:#endif
algogas.c:#if (defined(VISCOSITY) || defined(ALPHAVISCOSITY))
algogas.c:  if (Fluidtype == GAS) viscosity(dt);
algogas.c:#endif
algogas.c:#ifndef NOSUBSTEP2
algogas.c:  FARGO_SAFE(SubStep2_a(dt));
algogas.c:  FARGO_SAFE(SubStep2_b(dt));
algogas.c:#endif
algogas.c:  // NOW: Vx INITIAL X VELOCITY, Vx_temp UPDATED X VELOCITY FROM SOURCE TERMS + ARTIFICIAL VISCOSITY
algogas.c:#ifdef ADIABATIC
algogas.c: if(Fluidtype == GAS) FARGO_SAFE(SubStep3(dt));
algogas.c:#endif
algogas.c:  GiveSpecificTime (t_Hydro);
algogas.c:#ifdef MHD //-------------------------------------------------------------------
algogas.c:  if(Fluidtype == GAS){
algogas.c:    InitSpecificTime (&t_Mhd, "MHD algorithms");
algogas.c:    FARGO_SAFE(copy_velocities(VTEMP2V));
algogas.c:#ifndef STANDARD // WE USE THE FARGO ALGORITHM
algogas.c:    FARGO_SAFE(ComputeVmed(Vx));
algogas.c:    FARGO_SAFE(ChangeFrame(-1, Vx, VxMed)); //Vx becomes the residual velocity
algogas.c:    VxIsResidual = YES;
algogas.c:#endif
algogas.c:    ComputeMHD(dt);
algogas.c:#ifndef STANDARD
algogas.c:    FARGO_SAFE(ChangeFrame(+1, Vx, VxMed)); //Vx becomes the total, updated velocity
algogas.c:    VxIsResidual = NO;
algogas.c:#endif //STANDARD
algogas.c:    FARGO_SAFE(copy_velocities(V2VTEMP));
algogas.c:    // THIS COPIES Vx INTO Vx_temp
algogas.c:    GiveSpecificTime (t_Mhd);
algogas.c:#endif //END MHD----------------------------------------------------------------
algogas.c:  InitSpecificTime (&t_Hydro, "Transport algorithms");
algogas.c:#if ((defined(SHEARINGSHEET2D) || defined(SHEARINGBOX3D)) && !defined(SHEARINGBC))
algogas.c:  FARGO_SAFE(NonReflectingBC (Vy_temp));
algogas.c:#endif
algogas.c:  FARGO_SAFE(copy_velocities(VTEMP2V));
algogas.c:  FARGO_SAFE(FillGhosts(PrimitiveVariables()));
algogas.c:  FARGO_SAFE(copy_velocities(V2VTEMP));
algogas.c:#ifdef MHD //-------------------------------------------------------------------
algogas.c:  if(Fluidtype == GAS){ //We do MHD only for the gaseous component
algogas.c:    FARGO_SAFE(UpdateMagneticField(dt,1,0,0));
algogas.c:    FARGO_SAFE(UpdateMagneticField(dt,0,1,0));
algogas.c:    FARGO_SAFE(UpdateMagneticField(dt,0,0,1));
algogas.c:#if !defined(STANDARD)
algogas.c:    FARGO_SAFE(MHD_fargo (dt)); // Perform additional field update with uniform velocity
algogas.c:#endif
algogas.c:#endif //END MHD ---------------------------------------------------------------
algogas.c:void Transport(real dt) {
algogas.c:  //NOTE: V_temp IS USED IN TRANSPORT
algogas.c:#ifdef X
algogas.c:#ifndef STANDARD
algogas.c:  FARGO_SAFE(ComputeVmed(Vx_temp)); 
algogas.c:#endif
algogas.c:#endif
algogas.c:  GiveSpecificTime (t_Hydro);
algogas.c:  if (ForwardOneStep == YES) prs_exit(EXIT_SUCCESS);
algogas.c:#ifdef MHD
algogas.c:  if(Fluidtype == GAS) {   // We do MHD only for the gaseous component
algogas.c:   *(Emfx->owner) = Emfx;  // EMFs claim ownership of their storage area
algogas.c:   *(Emfy->owner) = Emfy;
algogas.c:   *(Emfz->owner) = Emfz;
algogas.c:#endif
allocate.c:#include "fargo3d.h"
allocate.c:Field *CreateFieldAlias(char *name, Field *clone, int type) {
allocate.c:  Field *field;
allocate.c:  //real *array;
allocate.c:  field = (Field *) malloc(sizeof(Field));
allocate.c:  if (field == NULL) 
allocate.c:    prs_error("Insufficient memory for Field cloning");
allocate.c:  string = (char *) malloc(sizeof(char) * 80);
allocate.c:    prs_error("Insufficient memory for Field creation-step3");
allocate.c:  sprintf(string, "%s", name);
allocate.c:  field->field_cpu = clone->field_cpu; //Cloning fields
allocate.c:  field->backup = NULL;
allocate.c:  field->secondary_backup = NULL;
allocate.c:  field->owner = (Field **)(field->field_cpu+(Ny+2*NGHY)*(Nx+2*NGHX)*(Nz+2*NGHZ));
allocate.c:  field->name = string;
allocate.c:  field->next = ListOfGrids;     //Linkedlist
allocate.c:  ListOfGrids = field;
allocate.c:#ifdef GPU
allocate.c:  field->field_gpu = clone->field_gpu;
allocate.c:  field->gpu_pp = clone->gpu_pp;
allocate.c:  field->cpu_pp = clone->cpu_pp;
allocate.c:#endif
allocate.c:  field->fresh_cpu     =  YES;
allocate.c:    field->fresh_inside_contour_cpu[i] = YES;
allocate.c:    field->fresh_outside_contour_cpu[i] = YES;
allocate.c:  field->fresh_gpu     =  NO;
allocate.c:    field->fresh_inside_contour_gpu[i] = NO;
allocate.c:    field->fresh_outside_contour_gpu[i] = NO;
allocate.c:  field->type = type;
allocate.c:  masterprint("Grids %s and %s share their storage\n", clone->name, name);
allocate.c:  return field;
allocate.c:Fluid *CreateFluid(char *name, int fluidtype) {
allocate.c:  char fieldname[80];
allocate.c:  char *fluidname = (char*) malloc(sizeof(char)*MAXNAMELENGTH);
allocate.c:  fluidname = (char *) malloc(sizeof(char) * 80);
allocate.c:  sprintf(fluidname, "%s", name);
allocate.c:  f = (Fluid *) malloc(sizeof(Fluid));
allocate.c:  f->name = fluidname;
allocate.c:  f->Fluidtype = fluidtype;
allocate.c:  sprintf(fieldname,"%s%s",name,"dens");
allocate.c:  f->Density = CreateField(fieldname, DENS, 0,0,0);
allocate.c:  sprintf(fieldname,"%s%s",name,"energy");
allocate.c:  f->Energy  = CreateField(fieldname, ENERGY, 0,0,0);  
allocate.c:  f->VxMed   = CreateField2D ("VxMed", YZ);
allocate.c:#ifdef X
allocate.c:  sprintf(fieldname,"%s%s",name,"vx");
allocate.c:  f->Vx      = CreateField(fieldname, VX, 1,0,0);
allocate.c:  f->Vx_temp = CreateField("Vx_temp", VXTEMP, 1,0,0);
allocate.c:#ifdef COLLISIONPREDICTOR
allocate.c:  f->Vx_half = CreateField("Vx_half", VXTEMP, 1,0,0);
allocate.c:#endif
allocate.c:#endif
allocate.c:#ifdef Y
allocate.c:  sprintf(fieldname,"%s%s",name,"vy");
allocate.c:  f->Vy      = CreateField(fieldname, VY, 0,1,0);
allocate.c:  f->Vy_temp = CreateField("Vy_temp", VYTEMP,0,1,0);
allocate.c:#ifdef COLLISIONPREDICTOR
allocate.c:  f->Vy_half = CreateField("Vy_half", VYTEMP, 1,0,0);
allocate.c:#endif
allocate.c:#endif
allocate.c:#ifdef Z
allocate.c:  sprintf(fieldname,"%s%s",name,"vz");
allocate.c:  f->Vz      = CreateField(fieldname, VZ, 0,0,1);
allocate.c:  f->Vz_temp = CreateField("Vz_temp", VZTEMP,0,0,1);
allocate.c:#ifdef COLLISIONPREDICTOR
allocate.c:  f->Vz_half = CreateField("Vz_half", VZTEMP, 1,0,0);
allocate.c:#endif
allocate.c:#endif
allocate.c:#ifdef STOCKHOLM
allocate.c:  f->Density0 = CreateField2D ("rho0", YZ);
allocate.c:  f->Energy0   = CreateField2D ("e0", YZ);
allocate.c:  f->Vx0  = CreateField2D ("vx0", YZ);
allocate.c:  f->Vy0  = CreateField2D ("vy0", YZ);
allocate.c:  f->Vz0  = CreateField2D ("vz0", YZ);
allocate.c:#endif
allocate.c:  return f;
allocate.c:Field *CreateField(char *name, int type, boolean sx, boolean sy, boolean sz) {
allocate.c:  /*sx = YES ==> Field is staggered in X. Useful for determining the
allocate.c:    domain of each field.*/
allocate.c:  Field *field;
allocate.c:  real *array;
allocate.c:  size_t pitch;
allocate.c:  field = (Field *) malloc(sizeof(Field));
allocate.c:  if (field == NULL) 
allocate.c:    prs_error("Insufficient memory for Field creation-step1.");
allocate.c:#ifndef GPU
allocate.c:  array = (real *) malloc(sizeof(real)*(Ny+2*NGHY)*(Nx+2*NGHX)*(Nz+2*NGHZ)+sizeof(Field*));
allocate.c:#else
allocate.c:#ifndef PINNED
allocate.c:  array = (real *) malloc(sizeof(real)*(Ny+2*NGHY)*(Nx+2*NGHX)*(Nz+2*NGHZ)+sizeof(Field*));
allocate.c:#else
allocate.c:  cudaMallocHost((void**)&array,sizeof(real)*(Ny+2*NGHY)*(Nx+2*NGHX)*(Nz+2*NGHZ)+sizeof(Field*));
allocate.c:#endif
allocate.c:#endif
allocate.c:    prs_error("Insufficient memory for Field creation-step2.");
allocate.c:  string = (char *) malloc(sizeof(char) * 80);
allocate.c:    prs_error("Insufficient memory for Field creation-step3.");
allocate.c:  sprintf(string, "%s", name);
allocate.c:  field->field_cpu = array;
allocate.c:  field->backup = NULL;
allocate.c:  field->secondary_backup = NULL;
allocate.c:  field->name = string;
allocate.c:  field->owner = (Field **)(array+(Ny+2*NGHY)*(Nx+2*NGHX)*(Nz+2*NGHZ));
allocate.c:  *(field->owner) = field;
allocate.c:  field->line_origin = __LINE__;
allocate.c:  strncpy (field->file_origin, __FILE__, MAXLINELENGTH-1);
allocate.c:  field->next = ListOfGrids;     //Linkedlist
allocate.c:  ListOfGrids = field;
allocate.c:#ifdef Z
allocate.c:#endif
allocate.c:#ifdef Y
allocate.c:#endif
allocate.c:#ifdef X
allocate.c:#endif
allocate.c:#ifdef X
allocate.c:#endif
allocate.c:#ifdef Y
allocate.c:#endif
allocate.c:#ifdef Z
allocate.c:#endif  
allocate.c:  masterprint("Field %s has been created\n", name);
allocate.c:  //Now on the GPU
allocate.c:#ifdef GPU
allocate.c:    #ifndef NOPITCH
allocate.c:      cudaMallocPitch (&arr_gpu, &pitch, (Nx+2*NGHX)*sizeof(real), (Ny+2*NGHY)*(Nz+2*NGHZ));
allocate.c:    #else
allocate.c:      cudaMalloc (&arr_gpu, (Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ)*sizeof(real));
allocate.c:      pitch = (Nx+2*NGHX)*sizeof(real);
allocate.c:    #endif
allocate.c:    field->gpu_pp = make_cudaPitchedPtr (arr_gpu, pitch, (Nx+2*NGHX), Ny+2*NGHY);
allocate.c:  } else {
allocate.c:    #ifndef NOPITCH
allocate.c:      cudaMallocPitch (&arr_gpu, &pitch, (Ny+2*NGHY)*sizeof(real), Nz+2*NGHZ);
allocate.c:    #else
allocate.c:      cudaMalloc (&arr_gpu, (Ny+2*NGHY)*(Nz+2*NGHZ)*sizeof(real));
allocate.c:      pitch = (Ny+2*NGHY)*sizeof(real);
allocate.c:    #endif
allocate.c:  check_errors ("CreateField");
allocate.c:  field->cpu_pp = make_cudaPitchedPtr (array, (Nx+2*NGHX)*sizeof(real), (Nx+2*NGHX), Ny+2*NGHY);
allocate.c:  masterprint("Field %s has been created on the GPU\n", name);
allocate.c:  field->fresh_cpu     =  YES;
allocate.c:    field->fresh_inside_contour_cpu[i] = YES;
allocate.c:    field->fresh_outside_contour_cpu[i] = YES;
allocate.c:  field->fresh_gpu     =  NO;
allocate.c:    field->fresh_inside_contour_gpu[i] = NO;
allocate.c:    field->fresh_outside_contour_gpu[i] = NO;
allocate.c:  field->field_gpu     =  (real *)arr_gpu;
allocate.c:  Pitch_gpu            =  pitch/sizeof(real);
allocate.c:  Stride_gpu           =  Pitch_gpu*(Ny+2*NGHY);
allocate.c:    Stride_gpu = pitch/sizeof(real);
allocate.c:#ifdef DEBUG
allocate.c:  masterprint("------>>>Pitch of %s = %d\n",field->name,pitch);
allocate.c:#endif
allocate.c:  Host2Dev3D(field); // Do NOT remove this
allocate.c:#endif
allocate.c:  Stride_cpu           =  Pitch_cpu*(Ny+2*NGHY);
allocate.c:  field->type = type;
allocate.c:    field->x = Xmin;
allocate.c:  else 
allocate.c:    field->x = Xmed;
allocate.c:    field->y = Ymin;
allocate.c:  else 
allocate.c:    field->y = Ymed;
allocate.c:    field->z = Zmin;
allocate.c:  else 
allocate.c:    field->z = Zmed;
allocate.c:  return field;
allocate.c:Field2D *CreateField2D(char *name, int dim) {
allocate.c:  Field2D *field;
allocate.c:  real *array;
allocate.c:  size_t pitch;
allocate.c:  int size1, size2;
allocate.c:    size1 = Ny+2*NGHY;
allocate.c:    size2 = Nz+2*NGHZ;
allocate.c:    size1 = Nx+2*NGHX;
allocate.c:    size2 = Nz+2*NGHZ;
allocate.c:    size1 = Nx+2*NGHX;
allocate.c:    size2 = Ny+2*NGHY;
allocate.c:  field = (Field2D *) malloc(sizeof(Field));
allocate.c:  if (field == NULL) 
allocate.c:    prs_error("Insufficient memory for Field2D creation-step1.");
allocate.c:#ifndef GPU
allocate.c:  array = (real *) malloc(sizeof(real)*size1*size2);
allocate.c:#else
allocate.c:#ifndef PINNED
allocate.c:  array = (real *) malloc(sizeof(real)*size1*size2);
allocate.c:#else
allocate.c:  cudaMallocHost((void**)&array,sizeof(real)*size1*size2);
allocate.c:#endif
allocate.c:#endif
allocate.c:    prs_error("Insufficient memory for Field2D creation-step2.");
allocate.c:  string = (char *) malloc(sizeof(char) * 80);
allocate.c:    prs_error("Insufficient memory for Field2D creation-step3.");
allocate.c:  sprintf(string, "%s", name);
allocate.c:  field->field_cpu = array;
allocate.c:  field->name = string;
allocate.c:  for (i = 0; i < size1*size2; i++)
allocate.c:  masterprint("Field2D %s has been created\n", name);
allocate.c:  //Now on the GPU
allocate.c:#ifdef GPU
allocate.c:  if(cudaMallocPitch(&arr_gpu, &pitch, size1*sizeof(real), size2) == cudaSuccess){
allocate.c:    masterprint("Field %s has created on the GPU\n", name);
allocate.c:    masterprint("Pitch = %d bytes (%d elements)\n", (int)pitch, (int)(pitch/sizeof(real)));
allocate.c:    field->field_gpu = (real*)arr_gpu;
allocate.c:    field->pitch = pitch/sizeof(real); //number of elements
allocate.c:  else{
allocate.c:    masterprint("There was an error allocating %s on the GPU.\n", field->name);
allocate.c:    check_errors ("CreateField2D");
allocate.c:    MPI_Finalize();
allocate.c:    exit(1);
allocate.c:  field->fresh_gpu     =  NO;
allocate.c:  if (dim == YZ) // Backward compatibility (old 2D arrays were only YZ).
allocate.c:    Pitch2D = pitch/sizeof(real);
allocate.c:  //If the array is not in YZ, we store its pitch in a new field of the 2D structure.
allocate.c:#endif
allocate.c:  field->fresh_cpu     =  YES;
allocate.c:  field->kind = dim;
allocate.c:  return field;
allocate.c:FieldInt2D *CreateFieldInt2D(char *name) {
allocate.c:  FieldInt2D *field;
allocate.c:  size_t pitch;
allocate.c:  field = (FieldInt2D *) malloc(sizeof(Field));
allocate.c:  if (field == NULL) 
allocate.c:    prs_error("Insufficient memory for FieldInt2D creation-step1.");
allocate.c:#ifndef GPU
allocate.c:  array = (int *) malloc(sizeof(int)*(Ny+2*NGHY)*(Nz+2*NGHZ));
allocate.c:#else
allocate.c:#ifndef PINNED
allocate.c:  array = (int *) malloc(sizeof(int)*(Ny+2*NGHY)*(Nz+2*NGHZ));
allocate.c:#else
allocate.c:  cudaMallocHost((void**)&array,sizeof(int)*(Ny+2*NGHY)*(Nz+2*NGHZ));
allocate.c:#endif
allocate.c:#endif
allocate.c:    prs_error("Insufficient memory for FieldInt2D creation-step2.");
allocate.c:  string = (char *) malloc(sizeof(char) * 80);
allocate.c:    prs_error("Insufficient memory for FieldInt2D creation-step3.");
allocate.c:  sprintf(string, "%s", name);
allocate.c:  field->field_cpu = array;
allocate.c:  field->backup = NULL;
allocate.c:  field->secondary_backup = NULL;
allocate.c:  field->name = string;
allocate.c:#ifdef Z
allocate.c:#endif
allocate.c:#ifdef Y
allocate.c:#endif
allocate.c:#ifdef Y
allocate.c:#endif
allocate.c:#ifdef Z
allocate.c:#endif  
allocate.c:  masterprint("Field2D %s has been created\n", name);
allocate.c:  //Now on the GPU
allocate.c:#ifdef GPU
allocate.c:  cudaMallocPitch (&arr_gpu, &pitch, (Ny+2*NGHY)*sizeof(int), Nz+2*NGHZ);
allocate.c:  check_errors ("CreateFieldInt2D");
allocate.c:  masterprint("Integer field %s has been created on the GPU\n", name);
allocate.c:  field->field_gpu =  (int*)arr_gpu;
allocate.c:#endif
allocate.c:  Pitch_Int_gpu = pitch/sizeof(int);
allocate.c:  field->fresh_cpu     =  YES;
allocate.c:  return field;
boundary.c:#include "fargo3d.h"
boundary.c:void boundaries() {
boundary.c:#ifdef Z
boundary.c:      boundary_zmin[FluidIndex]();
boundary.c:      boundary_zmax[FluidIndex]();
boundary.c:#endif
boundary.c:#ifdef Y
boundary.c:    if(Gridd.bc_left)
boundary.c:      boundary_ymin[FluidIndex]();
boundary.c:      boundary_ymax[FluidIndex]();
boundary.c:#endif
boundary.c:#ifdef GHOSTSX 
boundary.c:#endif
cfl.c://#define __GPU
cfl.c://#define __NOPROTO
cfl.c:#include "fargo3d.h"
cfl.c:  INPUT(Energy);
cfl.c:  INPUT(Density);
cfl.c:  OUTPUT(DensStar);
cfl.c:#ifdef X
cfl.c:  INPUT2D(VxMed);
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:#endif
cfl.c:#ifdef MHD
cfl.c:#endif
cfl.c:#ifdef HALLEFFECT
cfl.c:#endif
cfl.c:#ifdef AMBIPOLARDIFFUSION
cfl.c:#endif
cfl.c:#ifdef OHMICDIFFUSION
cfl.c:#endif
cfl.c:  real* cs  = Energy->field_cpu;
cfl.c:  real* rho = Density->field_cpu;
cfl.c:  real* dtime = DensStar->field_cpu;
cfl.c:#ifdef X
cfl.c:  real* vx = Vx->field_cpu;
cfl.c:  real* vxmed = VxMed->field_cpu;
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:  real* vy = Vy->field_cpu;
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:  real* vz = Vz->field_cpu;
cfl.c:#endif 
cfl.c:#ifdef MHD
cfl.c:  real* bx = Bx->field_cpu;
cfl.c:  real* by = By->field_cpu;
cfl.c:  real* bz = Bz->field_cpu;
cfl.c:#endif
cfl.c:#ifdef MHD
cfl.c:#ifdef OHMICDIFFUSION
cfl.c:  real* etao = EtaOhm->field_cpu;
cfl.c:#endif
cfl.c:#ifdef HALLEFFECT
cfl.c:  real* etahall = EtaHall->field_cpu;
cfl.c:#endif
cfl.c:#ifdef AMBIPOLARDIFFUSION
cfl.c:  real* etaad   = EtaAD->field_cpu;
cfl.c:#endif
cfl.c:#endif
cfl.c:  int stride = Stride_cpu;
cfl.c:  int size_x = Nx+NGHX;
cfl.c:  int size_y = Ny+NGHY;
cfl.c:  int size_z = Nz+NGHZ;
cfl.c:  int fluidtype = Fluidtype;
cfl.c:  real __attribute__((unused))dtmin = 1e30;
cfl.c:  real cfl1_a=0.0;
cfl.c:  real cfl1_b=0.0;
cfl.c:  real cfl1_c=0.0;
cfl.c:  real cfl1=0.0;
cfl.c:  real cfl2=0.0;
cfl.c:  real cfl3=0.0;
cfl.c:  real cfl4=0.0;
cfl.c:  real cfl5_a=0.0;
cfl.c:  real cfl5_b=0.0;
cfl.c:  real cfl5_c=0.0;
cfl.c:  real cfl5=0.0;
cfl.c:  real cfl6=0.0;
cfl.c:  real cfl7_a=0.0;
cfl.c:  real cfl7_b=0.0;
cfl.c:  real cfl7_c=0.0;
cfl.c:  real cfl7=0.0;
cfl.c:  real cfl8=0.0;
cfl.c:  real cfl9=0.0;
cfl.c:  real cfl10=0.0;
cfl.c:  real b;
cfl.c:  real vxx, vxxp;
cfl.c:  real soundspeed;
cfl.c:  real soundspeed2;
cfl.c:  real viscosity;
cfl.c:// real xmin(Nx+2*NGHX+1);
cfl.c:// real ymin(Ny+2*NGHY+1);
cfl.c:// real zmin(Nz+2*NGHZ+1);
cfl.c:// real GAMMA(1);
cfl.c:// real CFL(1);
cfl.c:// real ALPHA(1);
cfl.c:// real NU(1);
cfl.c:#ifdef Z
cfl.c:  for (k=NGHZ; k<size_z; k++) {
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:    for (j=NGHY; j<size_y; j++) {
cfl.c:#endif
cfl.c:#ifdef X
cfl.c:      for (i=NGHX; i<size_x; i++) {
cfl.c:#endif
cfl.c:#ifdef X
cfl.c:#ifdef STANDARD
cfl.c:#else
cfl.c:	vxx = vx[ll] - vxmed[l2D];
cfl.c:	vxxp= vx[llxp] - vxmed[l2D];
cfl.c:#endif
cfl.c:#endif
cfl.c:#ifdef ISOTHERMAL
cfl.c:	soundspeed2 = cs[ll]*cs[ll];
cfl.c:#endif
cfl.c:#ifdef ALPHAVISCOSITY
cfl.c:#ifdef ISOTHERMAL
cfl.c:	viscosity = ALPHA*cs[l]*cs[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
cfl.c:#else //ADIABATIC
cfl.c:	viscosity = ALPHA*GAMMA*(GAMMA-1.0)*cs[l]/rho[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR)); //cs means internal energy.
cfl.c:#endif //END ISOTHERMAL
cfl.c:#else  //NU VISCOSITY
cfl.c:#endif //END ALPHAVISCOSITY
cfl.c:#ifdef ADIABATIC
cfl.c:	soundspeed2 = GAMMA*(GAMMA-1)*cs[ll]/rho[ll];
cfl.c:#endif
cfl.c:#ifdef POLYTROPIC
cfl.c:	soundspeed2 = GAMMA*cs[ll]*pow(rho[ll],GAMMA-1.0); //In polytropic setups we use cs[] to store the entropy
cfl.c:#endif
cfl.c:#ifdef MHD
cfl.c:	if (fluidtype == GAS) {
cfl.c:	  soundspeed2 += ((bx[ll]*bx[ll]+by[ll]*by[ll]+bz[ll]*bz[ll])/(MU0*rho[ll]));
cfl.c:#endif
cfl.c:	soundspeed = sqrt(soundspeed2);
cfl.c:#ifdef X
cfl.c:	cfl1_a = soundspeed/zone_size_x(i,j,k);
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:	cfl1_b = soundspeed/zone_size_y(j,k);
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:	cfl1_c = soundspeed/zone_size_z(j,k);
cfl.c:#endif
cfl.c:#ifdef X
cfl.c:	cfl2 = (max2(fabs(vxx),fabs(vxxp)))/zone_size_x(i,j,k);
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:	cfl3 = (max2(fabs(vy[ll]),fabs(vy[llyp])))/zone_size_y(j,k);
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:	cfl4 = (max2(fabs(vz[ll]),fabs(vz[llzp])))/zone_size_z(j,k);
cfl.c:#endif
cfl.c:#ifndef NOSUBSTEP2
cfl.c:#ifdef X	
cfl.c:	cfl5_a = fabs(vx[llxp]-vx[ll])/zone_size_x(i,j,k);
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:	cfl5_b = fabs(vy[llyp]-vy[ll])/zone_size_y(j,k);
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:	cfl5_c = fabs(vz[llzp]-vz[ll])/zone_size_z(j,k);
cfl.c:#endif
cfl.c:#endif
cfl.c:#ifdef STRONG_SHOCK
cfl.c:#endif
cfl.c:#ifdef X	
cfl.c:	cfl7_a = 1.0/zone_size_x(i,j,k);	
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:	cfl7_b = 1.0/zone_size_y(j,k);
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:	cfl7_c = 1.0/zone_size_z(j,k);
cfl.c:#endif      
cfl.c:#ifdef MHD
cfl.c:#ifdef OHMICDIFFUSION
cfl.c:	cfl8 = 4.0*etao[ll]*pow(max3(cfl7_a,cfl7_b,cfl7_c),2);
cfl.c:#endif
cfl.c:#ifdef HALLEFFECT
cfl.c:	cfl9 = 6.0*fabs(etahall[ll])*pow(max3(cfl7_a,cfl7_b,cfl7_c),2);
cfl.c:#endif
cfl.c:#ifdef AMBIPOLARDIFFUSION
cfl.c:	cfl10 = 4.0*etaad[ll]*pow(max3(cfl7_a,cfl7_b,cfl7_c),2);
cfl.c:#endif
cfl.c:#endif
cfl.c:	dtime[ll] = CFL/sqrt(cfl1*cfl1 + cfl2*cfl2 + 
cfl.c:#ifdef X
cfl.c:#endif
cfl.c:#ifdef Y
cfl.c:#endif
cfl.c:#ifdef Z
cfl.c:#endif
cfl_b.c:#include "fargo3d.h"
cfl_b.c:  real step;
cfl_b.c:  Min[FluidIndex] = reduction_full_MIN(DensStar, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
cfl_b.c:#ifdef X
cfl_b.c:    real* vxmed = VxMed->field_cpu;
cfl_b.c:    real shearlimit;
cfl_b.c:#ifndef STANDARD
cfl_b.c:    INPUT2D (VxMed);
cfl_b.c:#ifdef Z
cfl_b.c:#endif
cfl_b.c:#ifdef Y
cfl_b.c:#endif
cfl_b.c:#ifdef CARTESIAN
cfl_b.c:	shearlimit = CFL*Mindx / fabs(vxmed[l2D]-vxmed[l2D+1]);
cfl_b.c:#endif
cfl_b.c:#if defined(CYLINDRICAL) || defined(SPHERICAL)
cfl_b.c:	shearlimit = CFL*Mindx / fabs(vxmed[l2D]/Ymed(j)-vxmed[l2D+1]/Ymed(j+1));
cfl_b.c:#endif
cfl_b.c:	if (shearlimit < Min[FluidIndex]) {
cfl_b.c:	  Min[FluidIndex] = shearlimit;
cfl_b.c:#ifdef Y
cfl_b.c:#endif
cfl_b.c:#ifdef Z
cfl_b.c:#endif
cfl_b.c:#endif
cfl_b.c:#endif
cfl_fluids_min.c:#include "fargo3d.h"
cfl_fluids_min.c:  real step = 1e30;
cfl_fluids_min.c:  real min;
cfl_fluids_min.c:    if (step > Min[i])
cfl_fluids_min.c:      step = Min[i];
cfl_fluids_min.c:#ifdef FLOAT
cfl_fluids_min.c:  MPI_Allreduce(&step, &StepTime, 1, MPI_FLOAT, MPI_MIN, MPI_COMM_WORLD);
cfl_fluids_min.c:#else
cfl_fluids_min.c:  MPI_Allreduce(&step, &StepTime, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
cfl_fluids_min.c:#endif
cfl_fluids_min.c:  if(StepTime <= SMALLTIME) {
cfl_fluids_min.c:    masterprint("Error!!!--> Null dt\n");
cfl_fluids_min.c:    prs_exit(1);
change_arch.c:#include "fargo3d.h"
change_arch.c:void ChangeArch() {
change_arch.c:  char separator[20] = "\t :=>";
change_arch.c:  char name[MAXNAMELENGTH];
change_arch.c:  int success;
change_arch.c:  func_arch = fopen(FUNCARCHFILE, "r");
change_arch.c:    printf("Error!! %s cannot be opened.\n", FUNCARCHFILE);
change_arch.c:  //Function pointers assignment (Default values ==> _cpu)
change_arch.c:  ComputePressureFieldIso = ComputePressureFieldIso_cpu;
change_arch.c:  ComputePressureFieldAd = ComputePressureFieldAd_cpu;
change_arch.c:  ComputePressureFieldPoly = ComputePressureFieldPoly_cpu;
change_arch.c:  SubStep1_x  = SubStep1_x_cpu;
change_arch.c:  SubStep1_y  = SubStep1_y_cpu;
change_arch.c:  SubStep1_z  = SubStep1_z_cpu;
change_arch.c:  SubStep2_a  = SubStep2_a_cpu;
change_arch.c:  SubStep2_b  = SubStep2_b_cpu;
change_arch.c:  SubStep3    = SubStep3_cpu;
change_arch.c:  DivideByRho = DivideByRho_cpu;
change_arch.c:  VanLeerX_a  = VanLeerX_a_cpu;
change_arch.c:  VanLeerX_b  = VanLeerX_b_cpu;
change_arch.c:  VanLeerY_a  = VanLeerY_a_cpu;
change_arch.c:  VanLeerY_b  = VanLeerY_b_cpu;
change_arch.c:  VanLeerZ_a  = VanLeerZ_a_cpu;
change_arch.c:  VanLeerZ_b  = VanLeerZ_b_cpu;
change_arch.c:  momenta_x   = momenta_x_cpu;
change_arch.c:  momenta_y   = momenta_y_cpu;
change_arch.c:  momenta_z   = momenta_z_cpu;
change_arch.c:  UpdateX     = UpdateX_cpu;
change_arch.c:  UpdateY     = UpdateY_cpu;
change_arch.c:  UpdateZ     = UpdateZ_cpu;
change_arch.c:  UpdateDensityX = UpdateDensityX_cpu;
change_arch.c:  UpdateDensityY = UpdateDensityY_cpu;
change_arch.c:  UpdateDensityZ = UpdateDensityZ_cpu;
change_arch.c:  NewVelocity_x = NewVelocity_x_cpu;
change_arch.c:  NewVelocity_y = NewVelocity_y_cpu;
change_arch.c:  NewVelocity_z = NewVelocity_z_cpu;
change_arch.c:  AdvectSHIFT   = AdvectSHIFT_cpu;
change_arch.c:  AdvectRAM     = AdvectRAM_cpu;
change_arch.c:  AdvectRAMlin  = AdvectRAMlin_cpu;
change_arch.c:  RamSlopes     = RamSlopes_cpu;
change_arch.c:  reduction_SUM = reduction_SUM_cpu;
change_arch.c:  reduction_MIN = reduction_MIN_cpu;
change_arch.c:  ComputeResidual = ComputeResidual_cpu;
change_arch.c:  ComputeVweight  = ComputeVweight_cpu;
change_arch.c:  RamComputeUstar = RamComputeUstar_cpu;
change_arch.c:  ChangeFrame = ChangeFrame_cpu;
change_arch.c:  Potential   = Potential_cpu;
change_arch.c:  CorrectVtheta = CorrectVtheta_cpu;
change_arch.c:  copy_velocities = copy_velocities_cpu;
change_arch.c:  _ComputeForce = _ComputeForce_cpu;
change_arch.c:  visctensor_cart   = visctensor_cart_cpu;
change_arch.c:  visctensor_cyl    = visctensor_cyl_cpu;
change_arch.c:  visctensor_sph    = visctensor_sph_cpu;
change_arch.c:  #include <../scripts/bound_cpu.code>
change_arch.c:  mon_dens = mon_dens_cpu;
change_arch.c:  mon_reynolds = mon_reynolds_cpu;
change_arch.c:  mon_maxwell  = mon_maxwell_cpu;
change_arch.c:  CheckMuteY = CheckMuteY_cpu;
change_arch.c:  CheckMuteZ = CheckMuteZ_cpu;
change_arch.c:  SetupHook1 = SetupHook1_cpu;
change_arch.c:  DustDiffusion_Core         = DustDiffusion_Core_cpu;
change_arch.c:  DustDiffusion_Coefficients = DustDiffusion_Coefficients_cpu;
change_arch.c:  copy_field = copy_field_cpu;
change_arch.c:  ComputeSlopes = ComputeSlopes_cpu;
change_arch.c:  _ComputeStar = _ComputeStar_cpu;
change_arch.c:  _ComputeEmf  = _ComputeEmf_cpu;
change_arch.c:  _UpdateMagneticField  = _UpdateMagneticField_cpu;
change_arch.c:  _LorentzForce = _LorentzForce_cpu;
change_arch.c:  EMF_Upstream_Integrate = EMF_Upstream_Integrate_cpu;
change_arch.c:  ComputeJx = ComputeJx_cpu;
change_arch.c:  ComputeJy = ComputeJy_cpu;
change_arch.c:  ComputeJz = ComputeJz_cpu;
change_arch.c:  _OhmicDiffusion_emf  = _OhmicDiffusion_emf_cpu;
change_arch.c:  OhmicDiffusion_coeff = OhmicDiffusion_coeff_cpu;
change_arch.c:  HallEffect_emfx       = HallEffect_emfx_cpu;
change_arch.c:  HallEffect_emfy       = HallEffect_emfy_cpu;
change_arch.c:  HallEffect_emfz       = HallEffect_emfz_cpu;
change_arch.c:  _HallEffect_UpdateB   = _HallEffect_UpdateB_cpu;
change_arch.c:  HallEffect_UpdateEmfs = HallEffect_UpdateEmfs_cpu;
change_arch.c:  HallEffect_coeff      = HallEffect_coeff_cpu;
change_arch.c:  AmbipolarDiffusion_emfx  = AmbipolarDiffusion_emfx_cpu;
change_arch.c:  AmbipolarDiffusion_emfy  = AmbipolarDiffusion_emfy_cpu;
change_arch.c:  AmbipolarDiffusion_emfz  = AmbipolarDiffusion_emfz_cpu;
change_arch.c:  AmbipolarDiffusion_coeff = AmbipolarDiffusion_coeff_cpu;
change_arch.c:  ComputeTotalDensity = ComputeTotalDensity_cpu;
change_arch.c:  Reset_field = Reset_field_cpu; 
change_arch.c:  VanLeerX_PPA_a    = VanLeerX_PPA_a_cpu;
change_arch.c:  VanLeerX_PPA_b    = VanLeerX_PPA_b_cpu;
change_arch.c:  VanLeerX_PPA_steep= VanLeerX_PPA_steep_cpu;
change_arch.c:  VanLeerX_PPA_c    = VanLeerX_PPA_c_cpu;
change_arch.c:  VanLeerX_PPA_d    = VanLeerX_PPA_d_cpu;
change_arch.c:  VanLeerX_PPA_d_2d = VanLeerX_PPA_d_2d_cpu;
change_arch.c:  while (fgets(s, MAXLINELENGTH-1, func_arch) != NULL) {
change_arch.c:    success = sscanf(s, "%s", name);
change_arch.c:    if(name[0]!='#' && success == 1){
change_arch.c:      s1 = s + (int)strlen(name);
change_arch.c:      sscanf(s1 + strspn(s1,separator), "%s", strval);
change_arch.c:      for (i = 0; i<strlen(name); i++) {
change_arch.c:	name[i] = (char)tolower(name[i]);
change_arch.c:      for (i = 0; i<strlen(strval); i++){
change_arch.c:	strval[i] = (char)tolower(strval[i]);
change_arch.c:#ifdef GPU
change_arch.c:      if (EverythingOnCPU == YES) {
change_arch.c:	fclose (func_arch);
change_arch.c:	return;
change_arch.c:      if (strcmp(name, "computepressurefieldiso") == 0) {
change_arch.c:	  ComputePressureFieldIso = ComputePressureFieldIso_gpu;
change_arch.c:	  printf("CompPressFieldIso runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computepressurefieldad") == 0) {
change_arch.c:	  ComputePressureFieldAd = ComputePressureFieldAd_gpu;
change_arch.c:	  printf("CompPressFieldAd runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computepressurefieldpoly") == 0) {
change_arch.c:	  ComputePressureFieldPoly = ComputePressureFieldPoly_gpu;
change_arch.c:	  printf("CompPressFieldPoly runs on the GPU\n");
change_arch.c:      if (strcmp(name, "substep1") == 0) {
change_arch.c:	  SubStep1_x = SubStep1_x_gpu;
change_arch.c:	  SubStep1_y = SubStep1_y_gpu; 
change_arch.c:	  SubStep1_z = SubStep1_z_gpu;
change_arch.c:	  printf("Substep1 runs on the GPU\n");
change_arch.c:      if (strcmp(name, "substep2") == 0) {
change_arch.c:	  SubStep2_a = SubStep2_a_gpu;
change_arch.c:	  SubStep2_b = SubStep2_b_gpu;
change_arch.c:	  printf("Substep2 runs on the GPU\n");
change_arch.c:      if (strcmp(name, "substep3") == 0) {
change_arch.c:	  SubStep3 = SubStep3_gpu;
change_arch.c:	  printf("Substep3 runs on the GPU\n");
change_arch.c:      if (strcmp(name, "dividebyrho") == 0) {
change_arch.c:	  DivideByRho = DivideByRho_gpu;
change_arch.c:	  printf("DivideByRho runs on the GPU\n");
change_arch.c:      if (strcmp(name, "resetfield") == 0) {
change_arch.c:	  Reset_field = Reset_field_gpu;
change_arch.c:	  printf("resetfield on the GPU\n");
change_arch.c:      if (strcmp(name, "vanleer") == 0) {
change_arch.c:	  VanLeerX_a = VanLeerX_a_gpu;
change_arch.c:	  VanLeerX_b = VanLeerX_b_gpu;
change_arch.c:	  VanLeerY_a = VanLeerY_a_gpu;
change_arch.c:	  VanLeerY_b = VanLeerY_b_gpu;
change_arch.c:	  VanLeerZ_a = VanLeerZ_a_gpu;
change_arch.c:	  VanLeerZ_b = VanLeerZ_b_gpu;
change_arch.c:	  printf("Vanleer runs on the GPU\n");
change_arch.c:      if (strcmp(name, "momenta") == 0) {
change_arch.c:	  momenta_x = momenta_x_gpu;
change_arch.c:	  momenta_y = momenta_y_gpu;
change_arch.c:	  momenta_z = momenta_z_gpu;
change_arch.c:	  printf("momenta runs on the GPU\n");
change_arch.c:      if (strcmp(name, "update") == 0) {
change_arch.c:	  UpdateX = UpdateX_gpu;
change_arch.c:	  UpdateY = UpdateY_gpu;
change_arch.c:	  UpdateZ = UpdateZ_gpu;
change_arch.c:	  printf("update runs on the GPU\n");
change_arch.c:      if (strcmp(name, "updatedensity") == 0) {
change_arch.c:	  UpdateDensityX = UpdateDensityX_gpu;
change_arch.c:	  UpdateDensityY = UpdateDensityY_gpu;
change_arch.c:	  UpdateDensityZ = UpdateDensityZ_gpu;
change_arch.c:	  printf("updatedensity runs on the GPU\n");
change_arch.c:      if (strcmp(name, "newvelocity") == 0) {
change_arch.c:	  NewVelocity_x = NewVelocity_x_gpu;
change_arch.c:	  NewVelocity_y = NewVelocity_y_gpu;
change_arch.c:	  NewVelocity_z = NewVelocity_z_gpu;
change_arch.c:	  printf("NewVelocity runs on the GPU\n");
change_arch.c:      if (strcmp(name, "copyvelocities") == 0) {
change_arch.c:	  copy_velocities = copy_velocities_gpu;
change_arch.c:	  printf("Copy velocities runs on the GPU\n");
change_arch.c:      if (strcmp(name, "copyfield") == 0) {
change_arch.c:	  copy_field = copy_field_gpu;
change_arch.c:	  printf("Copy field runs on the GPU\n");
change_arch.c:      if (strcmp(name, "reduction") == 0) {
change_arch.c:	  reduction_SUM = reduction_SUM_gpu;
change_arch.c:	  reduction_MIN = reduction_MIN_gpu;
change_arch.c:	  printf("Reduction runs on the GPU\n");
change_arch.c:      if (strcmp(name, "advectshift") == 0) {
change_arch.c:	  AdvectSHIFT = AdvectSHIFT_gpu;
change_arch.c:	  printf("AdvectShift runs on the GPU\n");
change_arch.c:  if (strcmp(name, "advectram") == 0) {
change_arch.c:	  AdvectRAM = AdvectRAM_gpu;
change_arch.c:	  AdvectRAMlin = AdvectRAMlin_gpu;
change_arch.c:	  printf("AdvectRam runs on the GPU\n");
change_arch.c:  if (strcmp(name, "ramslopes") == 0) {
change_arch.c:	  RamSlopes = RamSlopes_gpu;
change_arch.c:	  printf("RamSlopes runs on the GPU\n");
change_arch.c:       if (strcmp(name, "ramcomputeustar") == 0) {
change_arch.c:	  RamComputeUstar = RamComputeUstar_gpu;
change_arch.c:	  printf("RamComputeUstar runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computeresidual") == 0) {
change_arch.c:	  ComputeResidual = ComputeResidual_gpu;
change_arch.c:	  printf("ComputeResidual runs on the GPU\n");
change_arch.c:   if (strcmp(name, "computevweight") == 0) {
change_arch.c:	  ComputeVweight = ComputeVweight_gpu;
change_arch.c:	  printf("Computevweight runs on the GPU\n");
change_arch.c:      if (strcmp(name, "changeframe") == 0) {
change_arch.c:	  ChangeFrame = ChangeFrame_gpu;
change_arch.c:	  printf("ChangeFrame runs on the GPU\n");
change_arch.c:      if (strcmp(name, "potential") == 0) {
change_arch.c:	  Potential = Potential_gpu;
change_arch.c:	  printf("Potential runs on the GPU\n");
change_arch.c:      if (strcmp(name, "correctvtheta") == 0) {
change_arch.c:	  CorrectVtheta = CorrectVtheta_gpu;
change_arch.c:	  printf("CorrectVtheta runs on the GPU\n");
change_arch.c:      if (strcmp(name, "cfl") == 0) {
change_arch.c:	  printf("cfl runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computeforce") == 0) {
change_arch.c:	  _ComputeForce = _ComputeForce_gpu;
change_arch.c:	  printf("ComputeForce runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computeslopes") == 0) {
change_arch.c:	  ComputeSlopes = ComputeSlopes_gpu;
change_arch.c:	  printf("ComputeSlopes runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computestar") == 0) {
change_arch.c:	  _ComputeStar = _ComputeStar_gpu;
change_arch.c:	  printf("ComputeStar runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computeemf") == 0) {
change_arch.c:	  _ComputeEmf  = _ComputeEmf_gpu;
change_arch.c:	  printf("ComputeEmf runs on the GPU\n");
change_arch.c:      if (strcmp(name, "updatemagneticfield") == 0) {
change_arch.c:	  _UpdateMagneticField  = _UpdateMagneticField_gpu;
change_arch.c:	  printf("UpdateMagneticField runs on the GPU\n");
change_arch.c:      if (strcmp(name, "lorentzforce") == 0) {
change_arch.c:	  _LorentzForce = _LorentzForce_gpu;
change_arch.c:	  printf("LorentzForce runs on the GPU\n");
change_arch.c:      if (strcmp(name, "vanleerppa") == 0) {
change_arch.c:	  VanLeerX_PPA_a    = VanLeerX_PPA_a_gpu;
change_arch.c:	  VanLeerX_PPA_b    = VanLeerX_PPA_b_gpu;
change_arch.c:	  VanLeerX_PPA_steep= VanLeerX_PPA_steep_gpu;
change_arch.c:	  VanLeerX_PPA_c    = VanLeerX_PPA_c_gpu;
change_arch.c:	  VanLeerX_PPA_d    = VanLeerX_PPA_d_gpu;
change_arch.c:	  VanLeerX_PPA_d_2d = VanLeerX_PPA_d_2d_gpu;
change_arch.c:	  printf("VanLeerPPA runs on the GPU\n");
change_arch.c:      if (strcmp(name, "computej") == 0) {
change_arch.c:          ComputeJx = ComputeJx_gpu;
change_arch.c:          ComputeJy = ComputeJy_gpu;
change_arch.c:          ComputeJz = ComputeJz_gpu;
change_arch.c:          printf("ComputeJx runs on the GPU\n");
change_arch.c:          printf("ComputeJy runs on the GPU\n");
change_arch.c:          printf("ComputeJz runs on the GPU\n");
change_arch.c:      if (strcmp(name, "ohmicdiffusionemfs") == 0) {
change_arch.c:	  _OhmicDiffusion_emf = _OhmicDiffusion_emf_gpu;
change_arch.c:          printf("OhmicDiffusion_emf runs on the GPU\n");
change_arch.c:      if (strcmp(name, "ohmicdiffusioncoeff") == 0) {
change_arch.c:          OhmicDiffusion_coeff = OhmicDiffusion_coeff_gpu;
change_arch.c:          printf("OhmicDiffusion_coeff runs on the GPU\n");
change_arch.c:      if (strcmp(name, "halleffectcoeff") == 0) {
change_arch.c:          HallEffect_coeff = HallEffect_coeff_gpu;
change_arch.c:          printf("HallEffect_coeff runs on the GPU\n");
change_arch.c:      if (strcmp(name, "halleffectemfs") == 0) {
change_arch.c:          HallEffect_emfx = HallEffect_emfx_gpu;
change_arch.c:          HallEffect_emfy = HallEffect_emfy_gpu;
change_arch.c:          HallEffect_emfz = HallEffect_emfz_gpu;
change_arch.c:          printf("HallEffect_emfx runs on the GPU\n");
change_arch.c:          printf("HallEffect_emfy runs on the GPU\n");
change_arch.c:          printf("HallEffect_emfz runs on the GPU\n");
change_arch.c:      if (strcmp(name, "halleffectupdateb") == 0) {
change_arch.c:          _HallEffect_UpdateB  = _HallEffect_UpdateB_gpu;
change_arch.c:          printf("_HallEffect_UpdateB runs on the GPU\n");
change_arch.c:      if (strcmp(name, "halleffectupdateemfs") == 0) {
change_arch.c:          HallEffect_UpdateEmfs  = HallEffect_UpdateEmfs_gpu;
change_arch.c:          printf("HallEffect_UpdateEmfs runs on the GPU\n");
change_arch.c:      if (strcmp(name, "ambipolardiffusionemfs") == 0) {
change_arch.c:          AmbipolarDiffusion_emfx = AmbipolarDiffusion_emfx_gpu;
change_arch.c:          AmbipolarDiffusion_emfy = AmbipolarDiffusion_emfy_gpu;
change_arch.c:          AmbipolarDiffusion_emfz = AmbipolarDiffusion_emfz_gpu;
change_arch.c:          printf("AmbipolarDiffusion_emfx runs on the GPU\n");
change_arch.c:          printf("AmbipolarDiffusion_emfy runs on the GPU\n");
change_arch.c:          printf("AmbipolarDiffusion_emfz runs on the GPU\n");
change_arch.c:      if (strcmp(name, "ambipolardiffusioncoeff") == 0) {
change_arch.c:          AmbipolarDiffusion_coeff = AmbipolarDiffusion_coeff_gpu;
change_arch.c:          printf("AmbipolarDiffusion_coeff runs on the GPU\n");
change_arch.c:      if (strcmp(name, "fargomhd") == 0) {
change_arch.c:	  EMF_Upstream_Integrate = EMF_Upstream_Integrate_gpu;
change_arch.c:	  printf("FargoMHD runs on the GPU\n");
change_arch.c:      if (strcmp(name, "stockholmboundary") == 0) {
change_arch.c:	  printf("Stockholm Boundary runs on the GPU\n");
change_arch.c:      if (strcmp(name, "viscoustensor") == 0) {
change_arch.c:	  visctensor_cart = visctensor_cart_gpu;
change_arch.c:	  visctensor_cyl = visctensor_cyl_gpu;
change_arch.c:	  visctensor_sph = visctensor_sph_gpu;
change_arch.c:	  printf("Viscous tensor is computed on the GPU\n");
change_arch.c:      if (strcmp(name, "addviscosity") == 0) {
change_arch.c:	  printf("addviscosity runs on the GPU\n");
change_arch.c:      if (strcmp(name, "monitor") == 0) {
change_arch.c:	  mon_dens = mon_dens_gpu;
change_arch.c:	  mon_reynolds = mon_reynolds_gpu;
change_arch.c:	  mon_maxwell  = mon_maxwell_gpu;
change_arch.c:	  printf("Monitoring runs on the GPU\n");
change_arch.c:      if (strcmp(name, "dustdiffusion") == 0) {
change_arch.c:	  DustDiffusion_Core         = DustDiffusion_Core_gpu;
change_arch.c:	  DustDiffusion_Coefficients = DustDiffusion_Coefficients_gpu;
change_arch.c:	  printf("Dust diffusion runs on the GPU\n");
change_arch.c:      if (strcmp(name, "communications") == 0) {
change_arch.c:#ifdef MPICUDA
change_arch.c:	  printf("Communications are done directy on GPU\n");
change_arch.c:#else
change_arch.c:	  printf("Warning: your version of MPI does not allow direct GPU-GPU communications.\n");
change_arch.c:	  printf("Communications are done through the hosts (CPUs), and may not be very efficient.\n");
change_arch.c:#endif
change_arch.c:      if (strcmp(name, "boundaries") == 0) {
change_arch.c:	  #include <../scripts/bound_gpu.code>
change_arch.c:	  printf("boundaries runs on the GPU\n");
change_arch.c:      if (strcmp(name, "fillghostsx") == 0) {
change_arch.c:	  printf("Fill_GhostsX runs on the GPU\n");
change_arch.c:      if (strcmp(name, "checkmute") == 0) {
change_arch.c:	  CheckMuteY = CheckMuteY_gpu;
change_arch.c:	  CheckMuteZ = CheckMuteZ_gpu;
change_arch.c:	  printf("CheckMute runs on the GPU\n");
change_arch.c:      if (strcmp(name, "setuphook") == 0) {
change_arch.c:	  SetupHook1 = SetupHook1_gpu;
change_arch.c:	  printf("SETUP hook runs on the GPU\n");
change_arch.c:      if (strcmp(name, "collisions") == 0) {
change_arch.c:	  printf("collisions runs on the GPU\n");
change_arch.c:if (strcmp(name, "computetotaldensity") == 0) {
change_arch.c:	  ComputeTotalDensity = ComputeTotalDensity_gpu;
change_arch.c:	  printf("ComputeTotalDensity runs on the GPU\n");
change_arch.c:      if (strcmp(name, "resetfield") == 0) {
change_arch.c:	  Reset_field = Reset_field_gpu;
change_arch.c:	  printf("Reset_field runs on the GPU\n");
change_arch.c:      if (strcmp(name, "floor") == 0) {
change_arch.c:	  printf("Floor runs on the GPU\n");
change_arch.c:#endif
change_arch.c:  fclose(func_arch);
change_frame.c://#define __GPU
change_frame.c://#define __NOPROTO
change_frame.c:#include "fargo3d.h"
change_frame.c:void ChangeFrame_cpu(int sign, Field *V, Field2D *Vm) {
change_frame.c:  real* v  = V->field_cpu;
change_frame.c:  real* vm = Vm->field_cpu;
change_frame.c:  int stride = Stride_cpu;
change_frame.c:  int size_x = Nx+2*NGHX;
change_frame.c:  int size_y = Ny+2*NGHY;
change_frame.c:  int size_z = Nz+2*NGHZ;
change_frame.c:#ifdef Z
change_frame.c:  for (k = 0; k < size_z; k++) {
change_frame.c:#endif
change_frame.c:#ifdef Y
change_frame.c:    for (j = 0; j < size_y; j++) {
change_frame.c:#endif
change_frame.c:#ifdef X
change_frame.c:      for (i = 0; i < size_x; i++) {
change_frame.c:#endif
change_frame.c:	v[l] += (real)sign*vm[l2D];
change_frame.c:#ifdef X
change_frame.c:#endif
change_frame.c:#ifdef Y
change_frame.c:#endif
change_frame.c:#ifdef Z
change_frame.c:#endif
checkmute_y.c://#define __GPU
checkmute_y.c://#define __NOPROTO
checkmute_y.c:#include "fargo3d.h"
checkmute_y.c:void CheckMuteY_cpu() {
checkmute_y.c:  /* Throughout the source, a direction Y or Z is said mute if it is
checkmute_y.c:     defined (the preprocessor variable Y or Z exists, so that VY or
checkmute_y.c:     VZ exists, for instance), but the corresponding number of zones
checkmute_y.c:     is 1 (NY=1 or NZ=1). In that special case the ghosts are filled
checkmute_y.c:     manually with the values of the unique active row or column, in
checkmute_y.c:  INPUT(Density);
checkmute_y.c:#ifdef ADIABATIC
checkmute_y.c:  INPUT(Energy);
checkmute_y.c:#endif
checkmute_y.c:#ifdef X
checkmute_y.c:#endif
checkmute_y.c:#ifdef Y
checkmute_y.c:#endif
checkmute_y.c:#ifdef Z
checkmute_y.c:#endif
checkmute_y.c:#ifdef MHD
checkmute_y.c:#endif
checkmute_y.c:  OUTPUT(Density);
checkmute_y.c:#ifdef ADIABATIC
checkmute_y.c:  OUTPUT(Energy);
checkmute_y.c:#endif
checkmute_y.c:#ifdef X
checkmute_y.c:#endif
checkmute_y.c:#ifdef Y
checkmute_y.c:#endif
checkmute_y.c:#ifdef Z
checkmute_y.c:#endif
checkmute_y.c:#ifdef MHD
checkmute_y.c:#endif
checkmute_y.c:  real* rho = Density->field_cpu;
checkmute_y.c:#ifdef X  
checkmute_y.c:  real* vx = Vx->field_cpu;
checkmute_y.c:#endif
checkmute_y.c:#ifdef Y
checkmute_y.c:  real* vy = Vy->field_cpu;
checkmute_y.c:#endif
checkmute_y.c:#ifdef Z
checkmute_y.c:  real* vz = Vz->field_cpu;
checkmute_y.c:#endif
checkmute_y.c:#ifdef ADIABATIC
checkmute_y.c:  real* energy = Energy->field_cpu;
checkmute_y.c:#endif
checkmute_y.c:#ifdef MHD
checkmute_y.c:  real* bx = Bx->field_cpu;
checkmute_y.c:  real* by = By->field_cpu;
checkmute_y.c:  real* bz = Bz->field_cpu;
checkmute_y.c:#endif
checkmute_y.c:  int stride = Stride_cpu;
checkmute_y.c:  int size_x = Nx+2*NGHX;
checkmute_y.c:  int size_y = NGHY;
checkmute_y.c:  int size_z = Nz+2*NGHZ;
checkmute_y.c:#ifdef Z
checkmute_y.c:    for (k = 0; k < size_z; k++) {
checkmute_y.c:#endif
checkmute_y.c:      for (j = 0; j < size_y; j++) {
checkmute_y.c:#ifdef X
checkmute_y.c:	for (i = 0; i < size_x; i++) {
checkmute_y.c:#endif
checkmute_y.c:	  l_act = i+NGHY*pitch+k*stride;
checkmute_y.c:	  l_up  = i+(j+NGHY+1)*pitch+k*stride;
checkmute_y.c:#ifdef Y
checkmute_y.c:#endif
checkmute_y.c:#ifdef X
checkmute_y.c:#endif	 
checkmute_y.c:#ifdef Z
checkmute_y.c:#endif	 
checkmute_y.c:#ifdef ADIABATIC
checkmute_y.c:	  energy[ll]   = energy[l_act];
checkmute_y.c:	  energy[l_up] = energy[l_act];
checkmute_y.c:#endif
checkmute_y.c:#ifdef MHD
checkmute_y.c:#endif
checkmute_y.c:#ifdef X
checkmute_y.c:#endif
checkmute_y.c:#ifdef Z
checkmute_y.c:#endif
checkmute_z.c://#define __GPU
checkmute_z.c://#define __NOPROTO
checkmute_z.c:#include "fargo3d.h"
checkmute_z.c:void CheckMuteZ_cpu() {
checkmute_z.c:  /* Throughout the source, a direction Y or Z is said mute if it is
checkmute_z.c:     defined (the preprocessor variable Y or Z exists, so that VY or
checkmute_z.c:     VZ exists, for instance), but the corresponding number of zones
checkmute_z.c:     is 1 (NY=1 or NZ=1). In that special case the ghosts are filled
checkmute_z.c:     manually with the values of the unique active row or column, in
checkmute_z.c:  INPUT(Density);
checkmute_z.c:#ifdef ADIABATIC
checkmute_z.c:  INPUT(Energy);
checkmute_z.c:#endif
checkmute_z.c:#ifdef X
checkmute_z.c:#endif
checkmute_z.c:#ifdef Y
checkmute_z.c:#endif
checkmute_z.c:#ifdef Z
checkmute_z.c:#endif
checkmute_z.c:#ifdef MHD
checkmute_z.c:#endif
checkmute_z.c:  OUTPUT(Density);
checkmute_z.c:#ifdef ADIABATIC
checkmute_z.c:  OUTPUT(Energy);
checkmute_z.c:#endif
checkmute_z.c:#ifdef X
checkmute_z.c:#endif
checkmute_z.c:#ifdef Y
checkmute_z.c:#endif
checkmute_z.c:#ifdef Z
checkmute_z.c:#endif
checkmute_z.c:#ifdef MHD
checkmute_z.c:#endif
checkmute_z.c:  real* rho = Density->field_cpu;
checkmute_z.c:#ifdef X  
checkmute_z.c:  real* vx = Vx->field_cpu;
checkmute_z.c:#endif
checkmute_z.c:#ifdef Y
checkmute_z.c:  real* vy = Vy->field_cpu;
checkmute_z.c:#endif
checkmute_z.c:#ifdef Z
checkmute_z.c:  real* vz = Vz->field_cpu;
checkmute_z.c:#endif
checkmute_z.c:#ifdef ADIABATIC
checkmute_z.c:  real* energy = Energy->field_cpu;
checkmute_z.c:#endif
checkmute_z.c:#ifdef MHD
checkmute_z.c:  real* bx = Bx->field_cpu;
checkmute_z.c:  real* by = By->field_cpu;
checkmute_z.c:  real* bz = Bz->field_cpu;
checkmute_z.c:#endif
checkmute_z.c:  int stride = Stride_cpu;
checkmute_z.c:  int size_x = Nx+2*NGHX;
checkmute_z.c:  int size_y = Ny+2*NGHY;
checkmute_z.c:  int size_z = NGHZ;
checkmute_z.c:#ifdef Z
checkmute_z.c:  for (k = 0; k < size_z; k++) {
checkmute_z.c:#endif
checkmute_z.c:#ifdef Y
checkmute_z.c:    for (j = 0; j < size_y; j++) {
checkmute_z.c:#endif
checkmute_z.c:#ifdef X
checkmute_z.c:      for (i = 0; i < size_x; i++) {
checkmute_z.c:#endif
checkmute_z.c:	l_act = i+j*pitch+NGHZ*stride;
checkmute_z.c:	l_up  = i+j*pitch+(k+NGHZ+1)*stride;
checkmute_z.c:#ifdef Z
checkmute_z.c:#endif
checkmute_z.c:#ifdef X
checkmute_z.c:#endif	 
checkmute_z.c:#ifdef Y
checkmute_z.c:#endif	 
checkmute_z.c:#ifdef ADIABATIC
checkmute_z.c:	energy[ll]   = energy[l_act];
checkmute_z.c:	energy[l_up] = energy[l_act];
checkmute_z.c:#endif
checkmute_z.c:#ifdef MHD
checkmute_z.c:#endif   
checkmute_z.c:#ifdef X
checkmute_z.c:#endif
checkmute_z.c:#ifdef Y
checkmute_z.c:#endif
checkmute_z.c:#ifdef Z
checkmute_z.c:#endif
checknans.c:#include "fargo3d.h"
checknans.c:int CheckNansField (Field *f) {
checknans.c:	if (isnan(f->field_cpu[l])) {
checknans.c:	  return l;
checknans.c:  return -1;
checknans.c:int CheckAxiSym (Field *f) {
checknans.c:      if (fabs(f->field_cpu[l] - f->field_cpu[l+1]) > 1e-12)
checknans.c:	return l;
checknans.c:  return -1;
checknans.c:void AxiSym (Field *f) {
checknans.c:      f->field_cpu[l] = f->field_cpu[l+1];
checknans.c:void CheckNans (char *string){
checknans.c:  Field *g;
checknans.c:  while (g != NULL) {
checknans.c:    if ((i = CheckAxiSym (g)) >= 0) {
checknans.c:      if (g == DensStar) {
checknans.c:	printf ("DensStar being examined after call to %s\n", string);
checknans.c:	      g->name, i%(Nx+2*NGHX), (i/(Nx+2*NGHX))%(Ny+2*NGHY), i/((Nx+2*NGHX)*(Ny+2*NGHY)));
checknans.c:      printf ("position: after call to %s\n", string);
checknans.c:      exit(1);
checknans.c:      if (g == DensStar) {
checknans.c:	printf ("DensStar being examined after call to %s\n", string);
checknans.c:    g = g->next;
closed_bc.c://#define __GPU
closed_bc.c://#define __NOPROTO
closed_bc.c:#include "fargo3d.h"
closed_bc.c:void CloseBoundaries_cpu(Field *Vy, Field *Vz){
closed_bc.c:  real* vy = Vy->field_cpu;
closed_bc.c:  real* vz = Vz->field_cpu;
closed_bc.c:  int stride = Stride_cpu;
closed_bc.c:  int size_x   = Nx;
closed_bc.c:  int size_y   = Ny+2*NGHY;
closed_bc.c:  int size_z   = Nz+2*NGHZ;
closed_bc.c:#ifdef Z
closed_bc.c:  for (k=0; k<size_z; k++) {
closed_bc.c:#endif
closed_bc.c:#ifdef Y
closed_bc.c:    for (j=0; j<size_y; j++) {
closed_bc.c:#endif
closed_bc.c:#ifdef X
closed_bc.c:      for (i=0; i<size_x; i++) {
closed_bc.c:#endif
closed_bc.c:#ifdef YMINCLOSED	
closed_bc.c:#endif
closed_bc.c:#ifdef YMAXCLOSED
closed_bc.c:	if ((jcpu == ncpuy-1) && (j == size_y-NGHY-1))
closed_bc.c:#endif
closed_bc.c:#ifdef ZMINCLOSED	
closed_bc.c:#endif
closed_bc.c:#ifdef ZMAXCLOSED
closed_bc.c:	if ((kcpu == ncpuz-1) && (k == size_z-NGHZ-1))
closed_bc.c:#endif
closed_bc.c:#ifdef X
closed_bc.c:#endif
closed_bc.c:#ifdef Y
closed_bc.c:#endif
closed_bc.c:#ifdef Z
closed_bc.c:#endif
collisions.c://#define __GPU
collisions.c://#define __NOPROTO
collisions.c:#include "fargo3d.h"
collisions.c:void _collisions_cpu(real dt, int id1, int id2, int id3, int option) {
collisions.c:  real *rho[NFLUIDS];
collisions.c:  real *velocities_input[NFLUIDS];
collisions.c:  real *velocities_output[NFLUIDS];
collisions.c:    INPUT(Fluids[ii]->Density);
collisions.c:    rho[ii]  = Fluids[ii]->Density->field_cpu;
collisions.c:    #ifdef X
collisions.c:	INPUT(Fluids[ii]->Vx_temp);
collisions.c:	OUTPUT(Fluids[ii]->Vx_temp);
collisions.c:	velocities_input[ii] = Fluids[ii]->Vx_temp->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vx_temp->field_cpu;
collisions.c:	velocities_input[ii] = Fluids[ii]->Vx->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vx_half->field_cpu;
collisions.c:    #endif
collisions.c:    #ifdef Y
collisions.c:	INPUT(Fluids[ii]->Vy_temp);
collisions.c:	OUTPUT(Fluids[ii]->Vy_temp);
collisions.c:	velocities_input[ii] = Fluids[ii]->Vy_temp->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vy_temp->field_cpu;
collisions.c:	velocities_input[ii] = Fluids[ii]->Vy->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vy_half->field_cpu;
collisions.c:    #endif
collisions.c:    #ifdef Z
collisions.c:	INPUT(Fluids[ii]->Vz_temp);
collisions.c:	OUTPUT(Fluids[ii]->Vz_temp);
collisions.c:	velocities_input[ii] = Fluids[ii]->Vz_temp->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vz_temp->field_cpu;
collisions.c:	velocities_input[ii] = Fluids[ii]->Vz->field_cpu;
collisions.c:	velocities_output[ii] = Fluids[ii]->Vz_half->field_cpu;
collisions.c:    #endif
collisions.c:  int stride = Stride_cpu;
collisions.c:  int size_x = XIP; 
collisions.c:  int size_y = Ny+2*NGHY;
collisions.c:  int size_z = Nz+2*NGHZ;
collisions.c:  real* alpha = Alpha;
collisions.c:  real max_value;
collisions.c:  real factor;
collisions.c:  real big;
collisions.c:  real temp;
collisions.c:  real sum;
collisions.c:  real b[NFLUIDS];
collisions.c:  real m[NFLUIDS*NFLUIDS];  
collisions.c:  real omega;
collisions.c:  real rho_p;
collisions.c:  real rho_o;
collisions.c:  real rho_q;
collisions.c:// real Alpha(NFLUIDS*NFLUIDS);
collisions.c:#ifdef Z
collisions.c:  for(k=1; k<size_z; k++) {
collisions.c:#endif
collisions.c:#ifdef Y
collisions.c:    for(j=1; j<size_y; j++) {
collisions.c:#endif
collisions.c:#ifdef X
collisions.c:      for(i=XIM; i<size_x; i++) {
collisions.c:#endif
collisions.c:#include  "collision_kernel.h"
collisions.c:#include  "gauss.h"
collisions.c:	  velocities_output[o][l] = b[o];
collisions.c:#ifdef X
collisions.c:#endif
collisions.c:#ifdef Y
collisions.c:#endif
collisions.c:#ifdef Z
collisions.c:#endif
collisions.c:void Collisions(real dt, int option) {
collisions.c:  //Input and output velocities are the same Fields
collisions.c:#ifdef X
collisions.c:    //Collisions along the X direction
collisions.c:#endif
collisions.c:#ifdef Y
collisions.c:    //Collisions along the Y direction
collisions.c:#endif
collisions.c:#ifdef Z
collisions.c:    //Collisions along the Z direction
collisions.c:#endif
collisions.c:  //Input and output velocities are not the same Fields
collisions.c:#ifdef X
collisions.c:    //Collisions along the X direction
collisions.c:#endif
collisions.c:#ifdef Y
collisions.c:    //Collisions along the Y direction
collisions.c:#endif
collisions.c:#ifdef Z
collisions.c:    //Collisions along the Z direction
collisions.c:#endif
colrate.c://#define __GPU
colrate.c://#define __NOPROTO
colrate.c:#include "fargo3d.h"
colrate.c:void ColRate(real colrate, int i, int j, int feedback) {
colrate.c:  Alpha[i+j*NFLUIDS] = colrate;
colrate.c:  if(feedback == YES)
colrate.c:    Alpha[j+i*NFLUIDS] = colrate;
colrate.c:  else
colrate.c:#ifdef GPU
colrate.c:  DevMemcpyH2D(Alpha_d,Alpha,sizeof(real)*NFLUIDS*NFLUIDS);
colrate.c:#endif
comm.c:#include "fargo3d.h"
comm.c:#define LEFT  0
comm.c:#define RIGHT 1
comm.c:#define DOWN  2
comm.c:#define UP    3
comm.c:#define UPRIGHT 4
comm.c:#define UPLEFT  5
comm.c:#define DOWNLEFT 6
comm.c:#define DOWNRIGHT 7
comm.c:#define MAX_FIELDS_PER_COMM 12
comm.c:  int src; 			/* rank of source and destination */
comm.c:  struct communicator *next;	/* We use a chained (or linked) list */
comm.c:  real *buffer; 		/* Will be allocated according to size */
comm.c:  /* only on the relevant processes, of course */
comm.c:  int direction;
comm.c:  int yminsrc;			/* location on source */
comm.c:  int ymindst;			/* location on destination */
comm.c:  int size;			/* Size of buffer in YZ plane */
comm.c:  int nvarmax;			/* Maximal number of variables handled
comm.c:				   simultaneously */
comm.c:  int stride;
comm.c:typedef struct communicator Communicator;
comm.c:void MakeCommunicator (int src, int dest, int direction,			\
comm.c:  int nbytes, nvar;
comm.c:  comm = malloc (sizeof(Communicator));
comm.c:  comm->dst = dest;
comm.c:  comm->direction = direction;
comm.c:  /* Note : min included, max excluded */
comm.c:  comm->next = ListStart;	/* insert into chained list */
comm.c:  comm->stride = ymaxsrc-yminsrc;
comm.c:  comm->size = (ymaxsrc-yminsrc)*(zmaxsrc-zminsrc);
comm.c:  if ((src == CPU_Rank) || (dest == CPU_Rank)) {
comm.c:    nbytes = sizeof(real)*(Nx+2*NGHX)*nvar*comm->size;
comm.c:    comm->buffer = (real *)malloc(nbytes);
comm.c:void ResetBuffers() {
comm.c:  int j, k, rank, rankdest;
comm.c:  int extraz = 0, extray = 0;
comm.c:#ifdef Z
comm.c:  extraz = 1;
comm.c:#endif
comm.c:#ifdef Y
comm.c:  extray = 1;
comm.c:#endif
comm.c:  for (j = 0; j < Ncpu_x; j++) { /* We scan all CPUs */
comm.c:      /* Do we have a neighbor on our right side ? */
comm.c:	MakeCommunicator (rank,						\
comm.c:			  Ny, NGHZ, Ny+NGHY,NGHZ+Nz+extraz,		\
comm.c:			  0, NGHZ, NGHY, NGHZ+Nz+extraz,		\
comm.c:      /* Do we have a neighbor on our left side ? */
comm.c:	MakeCommunicator (rank,						\
comm.c:			  NGHY, NGHZ, 2*NGHY,NGHZ+Nz+extraz,		\
comm.c:			  Ny+NGHY, NGHZ, Ny+2*NGHY, NGHZ+Nz+extraz,	\
comm.c:      /* Do we have a neighbor on top of us ? */
comm.c:	MakeCommunicator (rank,						\
comm.c:			  NGHY, Nz, NGHY+Ny+extray, NGHZ+Nz,		\
comm.c:			  NGHY, 0, NGHY+Ny+extray, NGHZ,		\
comm.c:      /* Do we have a neighbor below us ? */
comm.c:	MakeCommunicator (rank,						\
comm.c:			  NGHY, NGHZ, NGHY+Ny+extray, 2*NGHZ,		\
comm.c:			  NGHY, Nz+NGHZ, NGHY+Ny+extray, Nz+2*NGHZ,	\
comm.c:      /* Do we have a right-top neighbor ? */
comm.c:	/* The sums in the above test is a trick to include a fast
comm.c:	   test for periodicity. Note that a given test is always true
comm.c:	   when its associated dimension is periodic (provided YES is
comm.c:	   defined to 1, and NO defined to 0, which is the case in
comm.c:	   define.h) */
comm.c:	  rankdest = rank+1+Ncpu_x;
comm.c:	  if (j == Ncpu_x-1) rankdest -= Ncpu_x;
comm.c:	  if (k == Ncpu_y-1) rankdest -= Ncpu_x*Ncpu_y;
comm.c:	  MakeCommunicator (rank,			\
comm.c:			    rankdest,			\
comm.c:      /* Do we have a left-top neighbor ? */
comm.c:	  rankdest = rank-1+Ncpu_x;
comm.c:	  if (j == 0) rankdest += Ncpu_x;
comm.c:	  if (k == Ncpu_y-1) rankdest -= Ncpu_x*Ncpu_y;
comm.c:	  MakeCommunicator (rank,			\
comm.c:			    rankdest,			\
comm.c:      /* Do we have a left-bottom neighbor ? */
comm.c:	  rankdest = rank-1-Ncpu_x;
comm.c:	  if (j == 0) rankdest += Ncpu_x;
comm.c:	  if (k == 0) rankdest += Ncpu_x*Ncpu_y;
comm.c:	  MakeCommunicator (rank,					\
comm.c:			    rankdest,					\
comm.c:      /* Do we have a right-bottom neighbor ? */
comm.c:	  rankdest = rank+1-Ncpu_x;
comm.c:	  if (j == Ncpu_x-1) rankdest -= Ncpu_x;
comm.c:	  if (k == 0) rankdest += Ncpu_x*Ncpu_y;
comm.c:	  MakeCommunicator (rank,			\
comm.c:			    rankdest,			\
comm.c:  static boolean comm_init = NO;
comm.c:  MPI_Request reqs[8], reqr[8];		/* At most 8 requests per PE */
comm.c:  Field *f[MAX_FIELDS_PER_COMM];
comm.c:  real *field[MAX_FIELDS_PER_COMM];
comm.c:  int special[MAX_FIELDS_PER_COMM];
comm.c:  int   nvar=0, i, j, k, n, offset, nbreqs=0, nbreqr=0, parity, direction;
comm.c:  int skip_line;
comm.c:    ResetBuffers ();
comm.c:    masterprint ("Found %d communicators\n", NbCom);
comm.c:    special[i] = 0;
comm.c:    f[nvar++] = Density;
comm.c:    f[nvar++] = Energy;
comm.c:#ifdef X
comm.c:    f[nvar++] = Vx_temp;
comm.c:#endif
comm.c:#ifdef Y
comm.c:    f[nvar++] = Vy_temp;
comm.c:#endif
comm.c:#ifdef Z
comm.c:    f[nvar++] = Vz_temp;
comm.c:#endif
comm.c:#ifdef MHD
comm.c:#ifdef SHEARINGBC
comm.c:      special[nvar] = 1;
comm.c:#endif
comm.c:#endif
comm.c:  if (nvar == 0) return;
comm.c:    mastererr ("Too many fields sent in one communication\n");
comm.c:    mastererr ("Rebuild after increasing MAX_FIELDS_PER_COMM\n");
comm.c:    mastererr ("In %s\n", __FILE__);
comm.c:    prs_exit (EXIT_FAILURE);
comm.c:  for (direction = 0; direction < 8; direction++) {
comm.c:    while (comm != NULL ) {
comm.c:      if (comm->direction == direction) {
comm.c:	    field[i] = f[i]->field_cpu;
comm.c:	    Input_Contour_Inside (f[i],direction);
comm.c:      comm = comm->next;
comm.c:    for (direction = 0; direction < 8; direction++) {
comm.c:      while (comm != NULL ) {
comm.c:	if ((comm->parity == parity) && (comm->direction == direction)) {
comm.c:	      field[i] = f[i]->field_cpu;
comm.c:		  offset = (i*(comm->size)+j-comm->yminsrc+(k-comm->zminsrc)*comm->stride)*(Nx+2*NGHX);
comm.c:		  memcpy (comm->buffer+offset,field[i]+j*(Nx+2*NGHX)+k*Stride, (Nx+2*NGHX)*sizeof(real));
comm.c:#ifdef FLOAT
comm.c:	      MPI_Isend (comm->buffer, comm->size*nvar*(Nx+2*NGHX), MPI_FLOAT, comm->dst, comm->direction, \
comm.c:			 MPI_COMM_WORLD, reqs+nbreqs++);
comm.c:#else
comm.c:	      MPI_Isend (comm->buffer, comm->size*nvar*(Nx+2*NGHX), MPI_DOUBLE, comm->dst, comm->direction, \
comm.c:			 MPI_COMM_WORLD, reqs+nbreqs++);
comm.c:#endif
comm.c:#ifdef FLOAT
comm.c:	      MPI_Irecv (comm->buffer, comm->size*nvar*(Nx+2*NGHX), MPI_FLOAT, comm->src, comm->direction, \
comm.c:			 MPI_COMM_WORLD, reqr+nbreqr);
comm.c:#else
comm.c:	      MPI_Irecv (comm->buffer, comm->size*nvar*(Nx+2*NGHX), MPI_DOUBLE, comm->src, comm->direction, \
comm.c:			 MPI_COMM_WORLD, reqr+nbreqr);
comm.c:#endif
comm.c:	      MPI_Wait (reqr+nbreqr++, MPI_STATUS_IGNORE);
comm.c:	      /* This WAIT instruction must be here, as we have to
comm.c:		 wait for the data to be ready to send it to the
comm.c:		 device. We therefore split send and receive requests. */
comm.c:	      field[i] = f[i]->field_cpu;
comm.c:	      /* The arithmetical trick below gives the direction of
comm.c:		 reception. For instance, if a send is toward the
comm.c:		 left, the receive must be for the right and
comm.c:		 vice-versa. The expression yields the following
comm.c:		 involutive correspondences: 0 <--> 1 and 2 <--> 3 */
comm.c:	      if (direction < 4)
comm.c:		f[i]->fresh_outside_contour_gpu[1-direction+4*(direction/2)] = NO;
comm.c:	      skip_line = 0;
comm.c:	      if ((comm->direction == LEFT) && (special[i] == 1)) skip_line=1;
comm.c:	      for (j = comm->ymindst+skip_line; j < comm->ymaxdst; j++) {
comm.c:		  offset = (i*(comm->size)+j-comm->ymindst+(k-comm->zmindst)*comm->stride)*(Nx+2*NGHX);
comm.c:		  memcpy (field[i]+j*(Nx+2*NGHX)+k*Stride, comm->buffer+offset, (Nx+2*NGHX)*sizeof(real));
comm.c:	comm = comm->next;
comm.c:  for (direction = 0; direction < 8; direction++) {
comm.c:    while (comm != NULL ) {
comm.c:      if (comm->direction == direction) {
comm.c:	    field[i] = f[i]->field_cpu;
comm.c:	    if (direction < 4)
comm.c:	      Output_Contour_Outside (f[i],1-direction+4*(direction/2));
comm.c:      comm = comm->next;
comm.c:  for (n = 0; n < nbreqs; n++)
comm.c:    MPI_Wait (reqs+n, MPI_STATUS_IGNORE);
comm.c:  MPI_Barrier (MPI_COMM_WORLD);
comm.c:#ifdef SHEARINGBC
comm.c:  FARGO_SAFE(ShearBC (options));
comm.c:#endif  
comm_device.c:#include "fargo3d.h"
comm_device.c:#define LEFT  0
comm_device.c:#define RIGHT 1
comm_device.c:#define DOWN  2
comm_device.c:#define UP    3
comm_device.c:#define UPRIGHT 4
comm_device.c:#define UPLEFT  5
comm_device.c:#define DOWNLEFT 6
comm_device.c:#define DOWNRIGHT 7
comm_device.c:#define MAX_FIELDS_PER_COMM 12
comm_device.c:  int src; 			/* rank of source and destination */
comm_device.c:  int direction;
comm_device.c:  struct gpucommunicator *next;	/* We use a chained list */
comm_device.c:#ifdef GPU
comm_device.c:  struct cudaPitchedPtr buffer;    /* Will be allocated according to
comm_device.c:				      size only on the relevant
comm_device.c:				      processes, of course */
comm_device.c:  struct cudaMemcpy3DParms OnSrc;
comm_device.c:  struct cudaMemcpy3DParms OnDst;
comm_device.c:#endif
comm_device.c:  int size;			/* Size of buffer in YZ plane */
comm_device.c:  int nvarmax;			/* Maximal number of variables handled
comm_device.c:				   simultaneously */
comm_device.c:  void *buffer2d;
comm_device.c:  size_t pitch;
comm_device.c:  int offset_src;
comm_device.c:  int offset_dst;
comm_device.c:  int dwbytes;
comm_device.c:typedef struct gpucommunicator GpuCommunicator;
comm_device.c:void MakeCommunicatorGPU (int src, int dest, int direction,			\
comm_device.c:#ifdef GPU
comm_device.c:  size_t pitch;
comm_device.c:  struct cudaPitchedPtr buffer;
comm_device.c:  struct cudaExtent extent;
comm_device.c:    prs_error ("Internal error: source/dest size mismatch error in MakeCommunicator.\n");
comm_device.c:    exit (EXIT_FAILURE); //Do not use prs_exit() here to avoid dead-lock
comm_device.c:  comm = malloc (sizeof(GpuCommunicator));
comm_device.c:  comm->dst = dest;
comm_device.c:  comm->direction = direction;
comm_device.c:  if (Nx+2*NGHX > 1) { //We use 3D functions of the CUDA library (see also dh_boundary.c)
comm_device.c:    /* Note : min included, max excluded */
comm_device.c:    comm->OnSrc.srcPos = make_cudaPos (0, yminsrc, zminsrc);
comm_device.c:    comm->OnDst.dstPos = make_cudaPos (0, ymindst, zmindst);
comm_device.c:    // OnSrc.dstPos and OnDst.srcPos defined "on the fly" in comm_gpu ();
comm_device.c:    comm->OnSrc.extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), ymaxsrc-yminsrc, zmaxsrc-zminsrc);
comm_device.c:    comm->OnDst.extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), ymaxsrc-yminsrc, zmaxsrc-zminsrc);
comm_device.c:    comm->OnSrc.kind = cudaMemcpyDeviceToDevice;
comm_device.c:    comm->OnDst.kind = cudaMemcpyDeviceToDevice;
comm_device.c:    //  comm->OnSrc.srcPtr defined "on the fly" in comm_gpu ();
comm_device.c:    //  comm->OnDst.dstPtr defined "on the fly" in comm_gpu ();
comm_device.c:    if ((src == CPU_Rank) || (dest == CPU_Rank)) {
comm_device.c:      extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real),ymaxsrc-yminsrc,(zmaxsrc-zminsrc)*nvar);
comm_device.c:      cudaMalloc3D (&buffer, extent);
comm_device.c:      check_errors ("allocating comm buffer on GPU");
comm_device.c:    comm->OnSrc.dstPtr = buffer;
comm_device.c:    comm->OnDst.srcPtr = buffer;
comm_device.c:    comm->size = (ymaxsrc-yminsrc)*(zmaxsrc-zminsrc);
comm_device.c:  } else {// Case Nx == 1: we use 2D routines such as cudaMallocPitch. Here the pitch is in Y
comm_device.c:    cudaMallocPitch (&(buffer.ptr), &pitch,\
comm_device.c:		     sizeof(real)*(ymaxsrc-yminsrc), (zmaxsrc-zminsrc)*nvar);
comm_device.c:    comm->offset_src = yminsrc+zminsrc*Stride_gpu;
comm_device.c:    comm->offset_dst = ymindst+zmindst*Stride_gpu;
comm_device.c:    /* The following two lines are a trick to be able to use the same
comm_device.c:       MPI_Isend (or MPI_Irecv) instruction for the cases Nx > 1 and
comm_device.c:       Nx==1. The two variables below are only used in these
comm_device.c:       MPI_Isend/MPI_Irecv invocations */
comm_device.c:    buffer.pitch = 1;
comm_device.c:    comm->size = pitch*(zmaxsrc-zminsrc);
comm_device.c:  comm->dwbytes = (ymaxsrc-yminsrc)*sizeof(real);
comm_device.c:  comm->buffer = buffer;
comm_device.c:  comm->next = ListStart;	/* insert into chained list */
comm_device.c:#endif
comm_device.c:void ResetBuffersGPU() {
comm_device.c:#ifdef GPU
comm_device.c:  int j, k, rank, rankdest;
comm_device.c:  int extraz = 0, extray = 0;
comm_device.c:#ifdef Z
comm_device.c:  extraz = 1;
comm_device.c:#endif
comm_device.c:#ifdef Y
comm_device.c:  extray = 1;
comm_device.c:#endif
comm_device.c:  for (j = 0; j < Ncpu_x; j++) { /* We scan all CPUs */
comm_device.c:      /* Do we have a neighbor on our right side ? */
comm_device.c:	MakeCommunicatorGPU (rank,					\
comm_device.c:			     Ny, NGHZ, Ny+NGHY,NGHZ+Nz+extraz,		\
comm_device.c:			     0, NGHZ, NGHY, NGHZ+Nz+extraz,		\
comm_device.c:      /* Do we have a neighbor on our left side ? */
comm_device.c:	MakeCommunicatorGPU (rank,					\
comm_device.c:			     NGHY, NGHZ, 2*NGHY,NGHZ+Nz+extraz,		\
comm_device.c:			     Ny+NGHY, NGHZ, Ny+2*NGHY, NGHZ+Nz+extraz,	\
comm_device.c:      /* Do we have a neighbor on top of us ? */
comm_device.c:	MakeCommunicatorGPU (rank,					\
comm_device.c:			     NGHY, Nz, NGHY+Ny+extray, NGHZ+Nz,		\
comm_device.c:			     NGHY, 0, NGHY+Ny+extray, NGHZ,		\
comm_device.c:      /* Do we have a neighbor below us ? */
comm_device.c:	MakeCommunicatorGPU (rank,					\
comm_device.c:			     NGHY, NGHZ, NGHY+Ny+extray, 2*NGHZ,	\
comm_device.c:			     NGHY, Nz+NGHZ, NGHY+Ny+extray, Nz+2*NGHZ,	\
comm_device.c:      /* Do we have a right-top neighbor ? */
comm_device.c:	/* The sums in the above test is a trick to include a fast
comm_device.c:	   test for periodicity. Note that a given test is always true
comm_device.c:	   when its associated dimension is periodic (provided YES is
comm_device.c:	   defined to 1, and NO defined to 0, which is the case in
comm_device.c:	   define.h) */
comm_device.c:	  rankdest = rank+1+Ncpu_x;
comm_device.c:	  if (j == Ncpu_x-1) rankdest -= Ncpu_x;
comm_device.c:	  if (k == Ncpu_y-1) rankdest -= Ncpu_x*Ncpu_y;
comm_device.c:	  MakeCommunicatorGPU (rank,			\
comm_device.c:			       rankdest,		\
comm_device.c:      /* Do we have a left-top neighbor ? */
comm_device.c:	  rankdest = rank-1+Ncpu_x;
comm_device.c:	  if (j == 0) rankdest += Ncpu_x;
comm_device.c:	  if (k == Ncpu_y-1) rankdest -= Ncpu_x*Ncpu_y;
comm_device.c:	  MakeCommunicatorGPU (rank,			\
comm_device.c:			       rankdest,		\
comm_device.c:      /* Do we have a left-bottom neighbor ? */
comm_device.c:	  rankdest = rank-1-Ncpu_x;
comm_device.c:	  if (j == 0) rankdest += Ncpu_x;
comm_device.c:	  if (k == 0) rankdest += Ncpu_x*Ncpu_y;
comm_device.c:	  MakeCommunicatorGPU (rank,					\
comm_device.c:			       rankdest,				\
comm_device.c:      /* Do we have a right-bottom neighbor ? */
comm_device.c:	  rankdest = rank+1-Ncpu_x;
comm_device.c:	  if (j == Ncpu_x-1) rankdest -= Ncpu_x;
comm_device.c:	  if (k == 0) rankdest += Ncpu_x*Ncpu_y;
comm_device.c:	  MakeCommunicatorGPU (rank,			\
comm_device.c:			       rankdest,		\
comm_device.c:#endif
comm_device.c:#ifdef GPU
comm_device.c:  static boolean comm_init = NO;
comm_device.c:  MPI_Request reqs[8], reqr[8];		/* At most 8 requests per PE */
comm_device.c:  Field *f[MAX_FIELDS_PER_COMM];
comm_device.c:  real *field[MAX_FIELDS_PER_COMM];
comm_device.c:  int special[MAX_FIELDS_PER_COMM];
comm_device.c:  int   nvar=0, i, n, nbreqs=0, nbreqr=0, parity, direction;
comm_device.c:  int skip_line;
comm_device.c:    ResetBuffersGPU ();
comm_device.c:    special[i] = 0;
comm_device.c:    f[nvar++] = Density;
comm_device.c:    f[nvar++] = Energy;
comm_device.c:#ifdef X
comm_device.c:    f[nvar++] = Vx_temp;
comm_device.c:#endif
comm_device.c:#ifdef Y
comm_device.c:    f[nvar++] = Vy_temp;
comm_device.c:#endif
comm_device.c:#ifdef Z
comm_device.c:    f[nvar++] = Vz_temp;
comm_device.c:#endif
comm_device.c:#ifdef MHD
comm_device.c:#ifdef SHEARINGBC
comm_device.c:      special[nvar] = 1;
comm_device.c:#endif
comm_device.c:#endif
comm_device.c:  if (nvar == 0) return;
comm_device.c:    mastererr ("Too many fields sent in one communication\n");
comm_device.c:    mastererr ("Rebuild after increasing MAX_FIELDS_PER_COMM\n");
comm_device.c:    mastererr ("In %s\n", __FILE__);
comm_device.c:    prs_exit (EXIT_FAILURE);
comm_device.c:    for (direction = 0; direction < 8; direction++) {
comm_device.c:      while (comm != NULL ) {
comm_device.c:	if ((comm->parity == parity) && (comm->direction == direction)) {
comm_device.c:	      if (Nx+2*NGHX > 1) { // We pile up "bricks" of fields in Z
comm_device.c:		comm->OnSrc.dstPos = make_cudaPos (0, 0, i*comm->dz);
comm_device.c:		cudaMemcpy3D (&(comm->OnSrc));
comm_device.c:	      } else {
comm_device.c:		field[i] = f[i]->field_gpu;
comm_device.c:		cudaMemcpy2D (comm->buffer.ptr+i*comm->pitch*comm->dz, comm->pitch,\
comm_device.c:			      field[i]+comm->offset_src, Stride_gpu*sizeof(real),\
comm_device.c:			      comm->dwbytes, comm->dz, cudaMemcpyDeviceToDevice);
comm_device.c:	      check_errors ("mpi src send to buffer");
comm_device.c:#ifdef FLOAT
comm_device.c:	      MPI_Isend (comm->buffer.ptr, comm->size*nvar*comm->buffer.pitch/sizeof(real), \
comm_device.c:			 MPI_FLOAT, comm->dst, comm->direction,		\
comm_device.c:			 MPI_COMM_WORLD, reqs+nbreqs++);
comm_device.c:#else
comm_device.c:	      MPI_Isend (comm->buffer.ptr, comm->size*nvar*comm->buffer.pitch/sizeof(real), \
comm_device.c:			 MPI_DOUBLE, comm->dst, comm->direction,	\
comm_device.c:			 MPI_COMM_WORLD, reqs+nbreqs++);
comm_device.c:#endif
comm_device.c:#ifdef FLOAT
comm_device.c:	      MPI_Irecv (comm->buffer.ptr, comm->size*nvar*comm->buffer.pitch/sizeof(real),\
comm_device.c:			 MPI_FLOAT, comm->src, comm->direction,		\
comm_device.c:			 MPI_COMM_WORLD, reqr+nbreqr);
comm_device.c:#else
comm_device.c:	      MPI_Irecv (comm->buffer.ptr, comm->size*nvar*comm->buffer.pitch/sizeof(real), \
comm_device.c:			 MPI_DOUBLE, comm->src, comm->direction,	\
comm_device.c:			 MPI_COMM_WORLD, reqr+nbreqr);
comm_device.c:#endif
comm_device.c:	      MPI_Wait (reqr+nbreqr++, MPI_STATUS_IGNORE);
comm_device.c:	      /* This WAIT instruction must be here, as we have to
comm_device.c:		 wait for the data to be ready to send it to the
comm_device.c:		 device. We therefore split send and receive requests. */
comm_device.c:		comm->OnDst.srcPos = make_cudaPos (0, 0, i*comm->dz);
comm_device.c:		cudaMemcpy3D (&(comm->OnDst));
comm_device.c:	      } else {
comm_device.c:		field[i] = f[i]->field_gpu;
comm_device.c:		cudaMemcpy2D (field[i]+comm->offset_dst, Stride_gpu*sizeof(real), \
comm_device.c:			      comm->buffer.ptr+i*comm->dz*comm->pitch, comm->pitch, \
comm_device.c:			      comm->dwbytes, comm->dz, cudaMemcpyDeviceToDevice);
comm_device.c:	      check_errors ("mpi dst receive from buffer");
comm_device.c:	      //	      skip_line = 0; UNIMPLEMENTED ON GPU - Used for ShearingBox BCs
comm_device.c:	      //	      if ((comm->direction == LEFT) && (special[i] == 1)) skip_line=1;
comm_device.c:	comm = comm->next;
comm_device.c:  for (n = 0; n < nbreqs; n++)
comm_device.c:    MPI_Wait (reqs+n, MPI_STATUS_IGNORE);
comm_device.c:  MPI_Barrier (MPI_COMM_WORLD);
comm_device.c:#ifdef SHEARINGBC
comm_device.c:  FARGO_SAFE(ShearBC (options));
comm_device.c:#endif  
comm_device.c:#endif
compfields.c:#include "fargo3d.h"
compfields.c:boolean CompareField (Field *f) { // Compare a field to its secondary backup
compfields.c:  int size, i;
compfields.c:  real *f1, *f2;
compfields.c:  //  if(f->name[0]!='S') //Problem with Slope field when reduction is analized
compfields.c:  if (*(f->owner) == NULL) {
compfields.c:      fprintf (stderr, "Skipping comparison of field %s used as a temporary work array\n",f->name);
compfields.c:      fprintf (stderr, "in file %s (as declared at line %d)\n",f->file_origin,f->line_origin);
compfields.c:    return FALSE;
compfields.c:  if (*(f->owner) != f) return FALSE;
compfields.c:  f1 = f->field_cpu;
compfields.c:  f2 = f->secondary_backup;
compfields.c:  size = (Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ);
compfields.c:  for (i=0; i < size; i++) {
compfields.c:  if (diff > 0) return TRUE;
compfields.c:  return FALSE;
compfields.c:void CompareAllFields () {
compfields.c:  Field *current;
compfields.c:  int size;
compfields.c:  current = ListOfGrids;
compfields.c:  size = (Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ);
compfields.c:  if (!CPU_Rank) printf ("List of fields that differ:\n");
compfields.c:  while (current != NULL) {
compfields.c:    if (CompareField (current)) {
compfields.c:      if (!CPU_Rank) printf ("Fields %s differ:\n", current->name);
compfields.c:      GiveStats (current->name, current->field_cpu, current->secondary_backup, size);
compfields.c:    current = current->next;
compfields.c:void GiveStats (char *name, real *f1, real *f2, int size) {
compfields.c:  real min1=1e40, min2=1e40, max1=-1e40, max2=-1e4;
compfields.c:  real mindiff=1e40, maxdiff=-1e40, minratio=1e40, maxratio=-1e40;
compfields.c:  real maxabs;
compfields.c:  for (i = 0; i < size; i++) {
compfields.c:  printf ("Minimum of %s on GPU: %.17g\n", name, min1);
compfields.c:  printf ("Minimum of %s on CPU: %.17g\n", name, min2);
compfields.c:  printf ("Maximum of %s on GPU: %.17g\n", name, max1);
compfields.c:  printf ("Maximum of %s on CPU: %.17g\n", name, max2);
compfields.c:  printf ("Minimum for %s of GPU/CPU-1: %g\n", name, minratio-1.);
compfields.c:  printf ("Maximum for %s of GPU/CPU-1: %g\n", name, maxratio-1.);
compfields.c:  printf ("Minimum for %s of GPU-CPU: %g\n", name, mindiff);
compfields.c:  printf ("Maximum for %s of GPU-CPU: %g\n", name, maxdiff);
compfields.c:  printf ("(Minimum for %s of GPU-CPU)/max(abs(CPU)): %g\n", name, mindiff/maxabs);
compfields.c:  printf ("(Maximum for %s of GPU-CPU)/max(abs(CPU)): %g\n", name, maxdiff/maxabs);
compute_emf.c://#define __GPU
compute_emf.c://#define __NOPROTO
compute_emf.c:#include "fargo3d.h"
compute_emf.c:void ComputeEmf(real dt, int idx, int idy, int idz, 
compute_emf.c:		Field *Bs1, Field *Vs1, Field *Bs2, Field *Vs2) {
compute_emf.c:  Field* B1;
compute_emf.c:  Field* B2;
compute_emf.c:  Field* V1;
compute_emf.c:  Field* V2;
compute_emf.c:  Field* Emf;
compute_emf.c:  FARGO_SAFE(_ComputeEmf(dt, idx1, idy1, idz1, idx2, idy2, idz2,Bs1,Vs1,Bs2,Vs2,B1,B2,V1,V2,Emf));
compute_emf.c:void _ComputeEmf_cpu(real dt, int idx1, int idy1, int idz1, int idx2, int idy2, int idz2, Field *Bs1, Field *Vs1, Field *Bs2, Field *Vs2, Field* B1, Field*B2, Field* V1, Field* V2, Field* Emf) {
compute_emf.c:    Function that computes the EMF. It needs as input the star fields
compute_emf.c:    (bs1,vs1,bs2,vs2). The integers idx,idy,idz represent the direction
compute_emf.c:    in which the EMF is computed.
compute_emf.c:  INPUT(Slope_v1);
compute_emf.c:  INPUT(Slope_v2);
compute_emf.c:  INPUT(Slope_b1);
compute_emf.c:  INPUT(Slope_b2);
compute_emf.c:  real* slope_v1 = Slope_v1->field_cpu;
compute_emf.c:  real* slope_b1 = Slope_b1->field_cpu;
compute_emf.c:  real* slope_v2 = Slope_v2->field_cpu;
compute_emf.c:  real* slope_b2 = Slope_b2->field_cpu;
compute_emf.c:  real* b1 = B1->field_cpu;
compute_emf.c:  real* v1 = V1->field_cpu;
compute_emf.c:  real* b2 = B2->field_cpu;
compute_emf.c:  real* v2 = V2->field_cpu;
compute_emf.c:  real* bs1 = Bs1->field_cpu;
compute_emf.c:  real* bs2 = Bs2->field_cpu;
compute_emf.c:  real* vs1 = Vs1->field_cpu;
compute_emf.c:  real* vs2 = Vs2->field_cpu;
compute_emf.c:  real* emf = Emf->field_cpu;
compute_emf.c:  int stride = Stride_cpu;
compute_emf.c:  int size_x = Nx+2*NGHX;
compute_emf.c:  int size_y = Ny+2*NGHY;
compute_emf.c:  int size_z = Nz+2*NGHZ;
compute_emf.c:  real b1_mean;
compute_emf.c:  real b2_mean;
compute_emf.c:  real v1_mean;
compute_emf.c:  real v2_mean;
compute_emf.c:  real delta1;
compute_emf.c:  real delta2;
compute_emf.c:  real v1_mean_old;
compute_emf.c:  real v2_mean_old;
compute_emf.c:// real xmin(Nx+1);
compute_emf.c:// real ymin(Ny+2*NGHY+1);
compute_emf.c:// real zmin(Nz+2*NGHZ+1);
compute_emf.c:  for (k=1; k<size_z; k++) {
compute_emf.c:    for (j=1; j<size_y; j++) {
compute_emf.c:      for (i=XIM; i<size_x; i++) {
compute_emf.c:	delta1 = (zone_size_x(i,j,k)*idx1 +
compute_emf.c:		  zone_size_y(j,k)*idy1 +
compute_emf.c:		  zone_size_z(j,k)*idz1);
compute_emf.c:	delta2 = (zone_size_x(i,j,k)*idx2 +
compute_emf.c:		  zone_size_y(j,k)*idy2 +
compute_emf.c:		  zone_size_z(j,k)*idz2);
compute_emf.c:	v1_mean_old = 0.5*(v1[ll]+v1[l2]);
compute_emf.c:	v2_mean_old = 0.5*(v2[ll]+v2[l1]);
compute_emf.c:	if(v2_mean_old<0.0){
compute_emf.c:	  v1_mean = v1[ll]-.5*slope_v2[ll]*(delta2+v2_mean_old*dt);
compute_emf.c:	  b1_mean = b1[ll]-.5*slope_b2[ll]*(delta2+v2_mean_old*dt);
compute_emf.c:	else{
compute_emf.c:	  v1_mean = v1[l2]+.5*slope_v2[l2]*(delta2-v2_mean_old*dt);
compute_emf.c:	  b1_mean = b1[l2]+.5*slope_b2[l2]*(delta2-v2_mean_old*dt);
compute_emf.c:#ifdef STRICTSYM
compute_emf.c:	if (fabs(v2_mean_old) < SMALLVEL) {
compute_emf.c:	  v1_mean = .5*(v1[ll]+v1[l2]);
compute_emf.c:	  b1_mean = .5*(b1[ll]+b1[l2]);
compute_emf.c:#endif
compute_emf.c:	if(v1_mean_old<0.0){
compute_emf.c:	  v2_mean = v2[ll]-.5*slope_v1[ll]*(delta1+v1_mean_old*dt);
compute_emf.c:	  b2_mean = b2[ll]-.5*slope_b1[ll]*(delta1+v1_mean_old*dt);
compute_emf.c:	else{
compute_emf.c:	  v2_mean = v2[l1]+.5*slope_v1[l1]*(delta1-v1_mean_old*dt);
compute_emf.c:	  b2_mean = b2[l1]+.5*slope_b1[l1]*(delta1-v1_mean_old*dt);
compute_emf.c:#ifdef STRICTSYM
compute_emf.c:	if (fabs(v1_mean_old) < SMALLVEL) {
compute_emf.c:	  v2_mean = .5*(v2[ll]+v2[l1]);
compute_emf.c:	  b2_mean = .5*(b2[ll]+b2[l1]);
compute_emf.c:#endif
compute_emf.c:	emf[ll] = 0.5*(vs1[ll]*b2_mean + bs2[ll]*v1_mean -
compute_emf.c:		       vs2[ll]*b1_mean - bs1[ll]*v2_mean);
compute_force.c://#define __GPU
compute_force.c://#define __NOPROTO
compute_force.c:#include "fargo3d.h"
compute_force.c://#define BLOCK_X 8
compute_force.c://#define BLOCK_Y 8
compute_force.c://#define BLOCK_Z 1
compute_force.c:// Fills forces arrays of the force experienced by the planet
compute_force.c:void _ComputeForce_cpu(real x, real y, real z, real rsmoothing, real mass) {
compute_force.c:  INPUT(Total_Density);
compute_force.c:  OUTPUT(Vx_temp);
compute_force.c:  OUTPUT(Vy_temp);
compute_force.c:  real* dens = Total_Density->field_cpu;
compute_force.c:  real* fxi  = Mmx->field_cpu;
compute_force.c:  real* fyi  = Mpx->field_cpu;
compute_force.c:  real* fzi  = Mmy->field_cpu;
compute_force.c:  real* fxhi = Mpy->field_cpu;
compute_force.c:  real* fyhi = Vx_temp->field_cpu;
compute_force.c:  real* fzhi = Vy_temp->field_cpu;
compute_force.c:  int stride = Stride_cpu;
compute_force.c:  int size_x = Nx+NGHX;
compute_force.c:  int size_y = Ny+NGHY;
compute_force.c:  int size_z = Nz+NGHZ;
compute_force.c:  real rh = pow(mass/3./MSTAR, 1./3.)*sqrt(x*x+y*y+z*z);
compute_force.c:  real cellmass;
compute_force.c:  real distance;
compute_force.c:  real dist2;
compute_force.c:  real dx;
compute_force.c:  real dy;
compute_force.c:  real dz;
compute_force.c:  real InvDist3; 
compute_force.c:  real hill_cut; 
compute_force.c:  real planet_distance;
compute_force.c:// real Sxi(Nx);
compute_force.c:// real Sxj(Ny+2*NGHY);
compute_force.c:// real Syj(Ny+2*NGHY);
compute_force.c:// real Szj(Ny+2*NGHY);
compute_force.c:// real Sxk(Nz+2*NGHZ);
compute_force.c:// real Syk(Nz+2*NGHZ);
compute_force.c:// real Szk(Nz+2*NGHZ);
compute_force.c:// real InvVj(Ny+2*NGHY);
compute_force.c:// real xmin(Nx+2*NGHX+1);
compute_force.c:// real ymin(Ny+2*NGHY+1);
compute_force.c:// real zmin(Nz+2*NGHZ+1);
compute_force.c:#ifdef Z
compute_force.c:  for (k=NGHZ; k<size_z; k++) {
compute_force.c:#endif
compute_force.c:#ifdef Y
compute_force.c:    for (j = NGHY; j<size_y; j++) {
compute_force.c:#endif
compute_force.c:#ifdef X
compute_force.c:      for (i = NGHX; i<size_x; i++) {
compute_force.c:#endif
compute_force.c:	/* Warning: Vol(i,j,k) must be also used
compute_force.c:	   for 2D simulations (ie: surface area). */
compute_force.c:	cellmass = Vol(i,j,k)*dens[ll];
compute_force.c:#ifdef CARTESIAN
compute_force.c:	dx = xmed(i)-x;
compute_force.c:	dy = ymed(j)-y;
compute_force.c:	dz = zmed(k)-z;
compute_force.c:#endif
compute_force.c:#ifdef CYLINDRICAL
compute_force.c:	dx = ymed(j)*cos(xmed(i))-x;
compute_force.c:	dy = ymed(j)*sin(xmed(i))-y;
compute_force.c:	dz = zmed(k)-z;
compute_force.c:#endif
compute_force.c:#ifdef SPHERICAL
compute_force.c:	dx = ymed(j)*cos(xmed(i))*sin(zmed(k))-x;
compute_force.c:	dy = ymed(j)*sin(xmed(i))*sin(zmed(k))-y;
compute_force.c:	dz = ymed(j)*cos(zmed(k))-z;
compute_force.c:#endif
compute_force.c:	/* New default exclusion function */
compute_force.c:#ifdef HILLCUT 
compute_force.c:	planet_distance=sqrt(dist2);
compute_force.c:	if (planet_distance/rh < 0.5)
compute_force.c:	else {
compute_force.c:	  if (planet_distance > rh)
compute_force.c:	  else
compute_force.c:	    hill_cut = pow(sin((planet_distance/rh-.5)*M_PI),2.);
compute_force.c:#endif
compute_force.c:	distance = sqrt(dist2);
compute_force.c:	InvDist3 = 1.0/(dist2*distance);
compute_force.c:	InvDist3 *= G*cellmass;
compute_force.c:#ifdef HILLCUT
compute_force.c:#else
compute_force.c:#endif
compute_force.c:#ifdef HALFDISK
compute_force.c:#endif
compute_force.c:#ifdef X
compute_force.c:#endif
compute_force.c:#ifdef Y
compute_force.c:#endif
compute_force.c:#ifdef Z
compute_force.c:#endif
compute_force.c:  int index;
compute_force.c:  real aa = sqrt(x*x+y*y+z*z);
compute_force.c:  /*This part can be improved for 3D*/
compute_force.c:  index = (int)(((aa-Ymin(NGHY))/(Ymin(Ny+NGHY+1)-Ymin(NGHY)))*(real)Ny) + NGHY;
compute_force.c:  if (index >= NGHY) {
compute_force.c:    if(index < Ny+NGHY) {
compute_force.c:      /*Inner Force*/
compute_force.c:      localforce[0]  = reduction_full_SUM(Mmx, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[1]  = reduction_full_SUM(Mpx, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[2]  = reduction_full_SUM(Mmy, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[3]  = reduction_full_SUM(Mpy, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[4]  = reduction_full_SUM(Vx_temp, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[5]  = reduction_full_SUM(Vy_temp, NGHY, index, NGHZ, Nz+NGHZ);
compute_force.c:      /*Outer Force*/
compute_force.c:      localforce[6]  = reduction_full_SUM(Mmx, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[7]  = reduction_full_SUM(Mpx, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[8]  = reduction_full_SUM(Mmy, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[9]  = reduction_full_SUM(Mpy, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[10] = reduction_full_SUM(Vx_temp, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[11] = reduction_full_SUM(Vy_temp, index, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    /*All is Inner Force*/
compute_force.c:    else{
compute_force.c:      localforce[0]   = reduction_full_SUM(Mmx, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[1]   = reduction_full_SUM(Mpx, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[2]   = reduction_full_SUM(Mmy, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[3]   = reduction_full_SUM(Mpy, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[4]   = reduction_full_SUM(Vx_temp, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[5]   = reduction_full_SUM(Vy_temp, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:      localforce[6]   = 0.0;
compute_force.c:      localforce[7]   = 0.0;
compute_force.c:      localforce[8]   = 0.0;
compute_force.c:      localforce[9]   = 0.0;
compute_force.c:      localforce[10]  = 0.0;
compute_force.c:      localforce[11]  = 0.0;
compute_force.c:  /*All is Outer Force*/
compute_force.c:  else{
compute_force.c:    localforce[0]  = 0.0;
compute_force.c:    localforce[1]  = 0.0;
compute_force.c:    localforce[2]  = 0.0;
compute_force.c:    localforce[3]  = 0.0;
compute_force.c:    localforce[4]  = 0.0;
compute_force.c:    localforce[5]  = 0.0;
compute_force.c:    localforce[6]  = reduction_full_SUM(Mmx, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    localforce[7]  = reduction_full_SUM(Mpx, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    localforce[8]  = reduction_full_SUM(Mmy, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    localforce[9]  = reduction_full_SUM(Mpy, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    localforce[10] = reduction_full_SUM(Vx_temp, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_force.c:    localforce[11] = reduction_full_SUM(Vy_temp, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
compute_jx.c://#define __GPU
compute_jx.c://#define __NOPROTO
compute_jx.c:#include "fargo3d.h"
compute_jx.c:void ComputeJx_cpu() {
compute_jx.c:  real* by = By->field_cpu;
compute_jx.c:  real* bz = Bz->field_cpu;
compute_jx.c:  real* jx = Jx->field_cpu;
compute_jx.c:  real mu0 = MU0;
compute_jx.c:  int stride = Stride_cpu;
compute_jx.c:  int size_x = Nx;
compute_jx.c:  int size_y = Ny+2*NGHY-1;
compute_jx.c:  int size_z = Nz+2*NGHZ-1;
compute_jx.c:  real fact1;
compute_jx.c:  real fact2;
compute_jx.c:// real ymin(Ny+2*NGHY+1);
compute_jx.c:// real zmin(Nz+2*NGHZ+1);
compute_jx.c:  for (k=1; k<size_z; k++) {
compute_jx.c:    for (j=1; j<size_y; j++) {
compute_jx.c:      for (i=0; i<size_x; i++) {
compute_jx.c:#ifdef CARTESIAN
compute_jx.c:	fact1 = 1.0/(ymed(j)-ymed(j-1));
compute_jx.c:	fact2 = 1.0/(zmed(k)-zmed(k-1));
compute_jx.c:#endif
compute_jx.c:#ifdef CYLINDRICAL
compute_jx.c:	fact1 = 1.0/(ymed(j)-ymed(j-1));
compute_jx.c:	fact2 = 1.0/(zmed(k)-zmed(k-1));
compute_jx.c:#endif
compute_jx.c:#ifdef SPHERICAL
compute_jx.c:	fact1 = 1.0/(ymin(j)*(ymed(j)-ymed(j-1)));
compute_jx.c:	fact2 = 1.0/(ymin(j)*(zmed(k)-zmed(k-1)));
compute_jx.c:	jx[ll] = ((ymed(j)*bz[ll]-ymed(j-1)*bz[lym])*fact1-(by[ll]-by[lzm])*fact2)/mu0; //rot(B)_phi
compute_jx.c:#endif
compute_jy.c://#define __GPU
compute_jy.c://#define __NOPROTO
compute_jy.c:#include "fargo3d.h"
compute_jy.c:void ComputeJy_cpu() {
compute_jy.c:  real* bx = Bx->field_cpu;
compute_jy.c:  real* bz = Bz->field_cpu;
compute_jy.c:  real* jy = Jy->field_cpu;
compute_jy.c:  real mu0 = MU0;
compute_jy.c:  int stride = Stride_cpu;
compute_jy.c:  int size_x = Nx;
compute_jy.c:  int size_y = Ny+2*NGHY-1;
compute_jy.c:  int size_z = Nz+2*NGHZ-1;
compute_jy.c:  real fact1;
compute_jy.c:  real fact2;
compute_jy.c:  real fact;
compute_jy.c:// real xmin(Nx+1);
compute_jy.c:// real InvDiffXmed(Nx+1);
compute_jy.c:// real ymin(Ny+2*NGHY+1);
compute_jy.c:// real zmin(Nz+2*NGHZ+1);
compute_jy.c:  for (k=1; k<size_z; k++) {
compute_jy.c:    for (j=1; j<size_y; j++) {
compute_jy.c:      for (i=0; i<size_x; i++) {
compute_jy.c:#ifdef CARTESIAN
compute_jy.c:	fact1 = 1.0/(zmed(k)-zmed(k-1));
compute_jy.c:	fact2 = Inv_zone_size_xmed(i,j,k);
compute_jy.c:#endif
compute_jy.c:#ifdef CYLINDRICAL
compute_jy.c:	fact1 = Inv_zone_size_xmed(i,j,k);
compute_jy.c:	fact2 = 1.0/(zmed(k)-zmed(k-1));
compute_jy.c:#endif
compute_jy.c:#ifdef SPHERICAL
compute_jy.c:	fact1 = Inv_zone_size_xmed(i,j,k);
compute_jy.c:	fact2 = 1.0/(fact*(zmed(k)-zmed(k-1)));
compute_jy.c:	jy[ll] = ((sin(zmed(k))*bx[ll]-sin(zmed(k-1))*bx[lzm])*fact2-(bz[ll]-bz[lxm])*fact1)/mu0;
compute_jy.c:#endif
compute_jz.c://#define __GPU
compute_jz.c://#define __NOPROTO
compute_jz.c:#include "fargo3d.h"
compute_jz.c:void ComputeJz_cpu() {
compute_jz.c:  real* bx = Bx->field_cpu;
compute_jz.c:  real* by = By->field_cpu;
compute_jz.c:  real* jz = Jz->field_cpu;
compute_jz.c:  real mu0 = MU0;
compute_jz.c:  int stride = Stride_cpu;
compute_jz.c:  int size_x = Nx;
compute_jz.c:  int size_y = Ny+2*NGHY-1;
compute_jz.c:  int size_z = Nz+2*NGHZ-1;
compute_jz.c:  real fact1;
compute_jz.c:  real fact2;
compute_jz.c:// real xmin(Nx+1);
compute_jz.c:// real InvDiffXmed(Nx+1);
compute_jz.c:// real ymin(Ny+2*NGHY+1);
compute_jz.c:// real zmin(Nz+2*NGHZ+1);
compute_jz.c:  for (k=1; k<size_z; k++) {
compute_jz.c:    for (j=1; j<size_y; j++) {
compute_jz.c:      for (i=0; i<size_x; i++) {
compute_jz.c:#ifdef CARTESIAN
compute_jz.c:	fact1 = Inv_zone_size_xmed(i,j,k);
compute_jz.c:	fact2 = 1.0/(ymed(j)-ymed(j-1));
compute_jz.c:#endif
compute_jz.c:#ifdef CYLINDRICAL
compute_jz.c:	fact1 = Inv_zone_size_xmed(i,j,k);
compute_jz.c:	fact2 = 1.0/(ymin(j)*(ymed(j)-ymed(j-1)));
compute_jz.c:	jz[ll] = ((ymed(j)*bx[ll]-ymed(j-1)*bx[lym])*fact2-(by[ll]-by[lxm])*fact1)/mu0;
compute_jz.c:#endif
compute_jz.c:#ifdef SPHERICAL
compute_jz.c:	fact1 = Inv_zone_size_xmed(i,j,k);
compute_jz.c:	fact2 = 1.0/(ymin(j)*(ymed(j)-ymed(j-1)));
compute_jz.c:	jz[ll] = ((by[ll]-by[lxm])*fact1-(ymed(j)*bx[ll]-ymed(j-1)*bx[lym])*fact2)/mu0;
compute_jz.c:#endif
compute_residual.c://#define __GPU
compute_residual.c://#define __NOPROTO
compute_residual.c:#include "fargo3d.h"
compute_residual.c:void ComputeResidual_cpu(real dt) {
compute_residual.c:  INPUT(Vx_temp);
compute_residual.c:  INPUT2D(VxMed);
compute_residual.c:  OUTPUT(Vx_temp);
compute_residual.c:  real* vx    = Vx_temp->field_cpu;
compute_residual.c:  real* vxr   = Vx->field_cpu;
compute_residual.c:  real* vxmed = VxMed->field_cpu;
compute_residual.c:  int* nshift = Nshift->field_cpu;
compute_residual.c:  int stride  = Stride_cpu;
compute_residual.c:  int size_x  = Nx+2*NGHX;
compute_residual.c:  int size_y  = Ny+2*NGHY;
compute_residual.c:  int size_z  = Nz+2*NGHZ;
compute_residual.c:  real ntilde;
compute_residual.c:  real nround;
compute_residual.c:// real xmin(Nx+2*NGHX+1);
compute_residual.c:// real ymin(Ny+2*NGHY+1);
compute_residual.c:// real zmin(Nz+2*NGHZ+1);
compute_residual.c:#ifdef Z
compute_residual.c:  for (k = 0; k < size_z; k++) {
compute_residual.c:#endif 
compute_residual.c:#ifdef Y
compute_residual.c:    for (j = 0; j < size_y; j++) {
compute_residual.c:#endif
compute_residual.c:#ifdef X
compute_residual.c:      for (i = 0; i < size_x; i++) {
compute_residual.c:#endif
compute_residual.c:#ifndef RAM
compute_residual.c:	ntilde = vxmed[ll2D]*dt/zone_size_x(i,j,k);
compute_residual.c:	nround = floor(ntilde+0.5);
compute_residual.c:	vxr[ll] = vx[ll]-vxmed[ll2D];
compute_residual.c:	vx[ll] = (ntilde-nround)*zone_size_x(i,j,k)/dt;
compute_residual.c:#else
compute_residual.c:	vxr[ll] = vx[ll]-vxmed[ll2D];
compute_residual.c:#endif
compute_residual.c:#ifdef X
compute_residual.c:#endif
compute_residual.c:#ifdef Y
compute_residual.c:#endif
compute_residual.c:#ifdef Z
compute_residual.c:#endif
compute_slopes.c://#define __GPU
compute_slopes.c://#define __NOPROTO
compute_slopes.c:#include "fargo3d.h"
compute_slopes.c:void ComputeSlopes_cpu(int idx, int idy, int idz, Field *f, Field *s) {
compute_slopes.c:    Function that computes the slopes that will be used in the MOC.
compute_slopes.c:    The indices idx, idy and idz represent the direction in which the
compute_slopes.c:    slope is calculated. f is the input field, s is the output
compute_slopes.c:    slope. Generally in the MHD we need the slopes perpendicular to
compute_slopes.c:    the direction of the field (ComputeSlope (vx, 0,0,1) and
compute_slopes.c:    ComputeSlope (vx, 0,1,0)). The slope has same centering as the
compute_slopes.c:    input field. Van Leer's slopes are calculated in this routine.
compute_slopes.c:  real* field = f->field_cpu;
compute_slopes.c:  real* slope = s->field_cpu;
compute_slopes.c:  int stride = Stride_cpu;
compute_slopes.c:  int size_x = XIP;
compute_slopes.c:  int size_y = Ny+2*NGHY-1;
compute_slopes.c:  int size_z = Nz+2*NGHZ-1;
compute_slopes.c:  real dfp;
compute_slopes.c:  real dfm;
compute_slopes.c:  real delta;
compute_slopes.c:// real xmin(Nx+1);
compute_slopes.c:// real ymin(Ny+2*NGHY+1);
compute_slopes.c:// real zmin(Nz+2*NGHZ+1);
compute_slopes.c:  for (k=1; k<size_z; k++) {
compute_slopes.c:    for (j=1; j<size_y; j++) {
compute_slopes.c:      for (i=XIM; i<size_x; i++) {
compute_slopes.c:	delta = (zone_size_x(i,j,k)*idx +		
compute_slopes.c:		 zone_size_y(j,k)*idy +       
compute_slopes.c:		 zone_size_z(j,k)*idz);	
compute_slopes.c:	dfp = field[lp]-field[ll];
compute_slopes.c:	dfm = field[ll]-field[lm];
compute_slopes.c:	  slope[ll] = 0.0;
compute_slopes.c:	else
compute_slopes.c:	  slope[ll] =2.0*dfp*dfm/((dfp+dfm)*delta);
compute_star.c://#define __GPU
compute_star.c://#define __NOPROTO
compute_star.c:#include "fargo3d.h"
compute_star.c:void ComputeStar(real dt, int idx1, int idy1, int idz1,			 
compute_star.c:		 int idx2, int idy2, int idz2, int index,
compute_star.c:		 Field* Bs, Field* Vs, Field* Slope_b,	
compute_star.c:		 Field* Slope_v, Field* Slope_bvl, Field* Slope_vvl) {
compute_star.c:  /* This function is an intermediate stage to the wrapper function _ComputeStar */
compute_star.c:  Field* B1;
compute_star.c:  Field* B2;
compute_star.c:  Field* V1;
compute_star.c:  Field* V2;
compute_star.c:  int stride1;
compute_star.c:  int stride2;
compute_star.c:    stride1 = 1;
compute_star.c:#ifdef GPU
compute_star.c:    if (_ComputeStar == _ComputeStar_gpu)
compute_star.c:      stride1 = Pitch_gpu;    
compute_star.c:    else
compute_star.c:#endif
compute_star.c:      stride1 = Nx+2*NGHX;    
compute_star.c:#ifdef GPU
compute_star.c:    if (_ComputeStar == _ComputeStar_gpu)
compute_star.c:      stride1 = Stride_gpu;
compute_star.c:    else
compute_star.c:#endif
compute_star.c:      stride1 = (Nx+2*NGHX)*(Ny+2*NGHY);
compute_star.c:  /* Now index of field */
compute_star.c:    stride2 = 1;
compute_star.c:#ifdef GPU
compute_star.c:    if (_ComputeStar == _ComputeStar_gpu)
compute_star.c:      stride2 = Pitch_gpu;
compute_star.c:    else
compute_star.c:#endif
compute_star.c:      stride2 = Nx+2*NGHX;
compute_star.c:#ifdef GPU
compute_star.c:    if (_ComputeStar == _ComputeStar_gpu)
compute_star.c:      stride2 = Stride_gpu;
compute_star.c:    else
compute_star.c:#endif
compute_star.c:      stride2 = (Nx+2*NGHX)*(Ny+2*NGHY);
compute_star.c:  FARGO_SAFE(_ComputeStar(dt, idx1,idy1,idz1,idx2,idy2,idz2,index,stride1,stride2,B1,B2,V1,V2,Bs,Vs,Slope_b,Slope_v,Slope_bvl,Slope_vvl));
compute_star.c:void _ComputeStar_cpu(real dt, int idx1, int idy1, int idz1, int idx2, int idy2, int idz2, int index, int stride1, int stride2, Field* B1, Field* B2, Field* V1, Field* V2, Field* Bs, Field* Vs, Field* Slope_b, Field* Slope_v, Field* Slope_bvl, Field* Slope_vvl) {
compute_star.c:  /* This function computes the star fields for the Method of
compute_star.c:     Characteristics (magnetic field and velocity). The slopes of each
compute_star.c:     field are needed as input.  Index=0 implies a calculation in a
compute_star.c:     frame at rest, whereas Index=1 implies a calculation in a
compute_star.c:     comobile frame (with velocity v1). The integers idx1,idy1 and
compute_star.c:     idz1 are for the direction of propagation of the characteristics,
compute_star.c:     and the integers idx2,idy2 and idz2 are for the direction of the
compute_star.c:     field of which we want the star value
compute_star.c:  INPUT(Density);
compute_star.c:  INPUT(Slope_b);
compute_star.c:  INPUT(Slope_v);
compute_star.c:  INPUT(Slope_bvl);
compute_star.c:  INPUT(Slope_vvl);
compute_star.c:  real* rho = Density->field_cpu;
compute_star.c:  real* b1  = B1->field_cpu;
compute_star.c:  real* b2  = B2->field_cpu;
compute_star.c:  real* v1  = V1->field_cpu;
compute_star.c:  real* v2  = V2->field_cpu;
compute_star.c:  real* bs  = Bs->field_cpu;
compute_star.c:  real* vs  = Vs->field_cpu;
compute_star.c:  real* slope_b   = Slope_b->field_cpu;	
compute_star.c:  real* slope_v   = Slope_v->field_cpu;
compute_star.c:  real* slope_bvl = Slope_bvl->field_cpu;
compute_star.c:  real* slope_vvl = Slope_vvl->field_cpu;
compute_star.c:  int stride = Stride_cpu;
compute_star.c:  int size_x = XIP;
compute_star.c:  int size_y = Ny+2*NGHY-1;
compute_star.c:  int size_z = Nz+2*NGHZ-1;
compute_star.c:  real cp;
compute_star.c:  real cm;
compute_star.c:  real rho_mean;
compute_star.c:  real rho_mean1;
compute_star.c:  real rho_mean2;
compute_star.c:  real bp;
compute_star.c:  real bm;
compute_star.c:  real vp;
compute_star.c:  real vm;
compute_star.c:  real delta1;
compute_star.c:  real delta2;
compute_star.c:  int lperpm;
compute_star.c:  int lmperpm;
compute_star.c:  real v1_mean;
compute_star.c:  real v2_mean;
compute_star.c:  real b1_mean;
compute_star.c:  real temp;
compute_star.c:  //  real b2_mean;
compute_star.c:  /* Propagation index first */
compute_star.c:// real xmin(Nx+1);
compute_star.c:// real ymin(Ny+2*NGHY+1);
compute_star.c:// real zmin(Nz+2*NGHZ+1);
compute_star.c:  for (k=2; k<size_z; k++) {
compute_star.c:    for (j=2; j<size_y; j++) {
compute_star.c:      for (i=XIM; i<size_x; i++) {
compute_star.c:	lpropm  = lxm*idx1 + lym*idy1 + lzm*idz1; //Propagation index minus
compute_star.c:	lperpm  = lxm*idx2 + lym*idy2 + lzm*idz2; //Minus along vectors	
compute_star.c:	lmperpm = lpropm - stride2;  //direction! (l plus perpendicular minus)
compute_star.c:#ifndef GHOSTSX
compute_star.c:	    lmperpm = lpropm + nx -1; //passes permutation test
compute_star.c:#endif
compute_star.c:	rho_mean1 = 0.5*(rho[lperpm]+rho[lmperpm]);
compute_star.c:	rho_mean2 = 0.5*(rho[ll]+rho[lpropm]);
compute_star.c:	rho_mean  = 0.5*(rho_mean1+rho_mean2);
compute_star.c:	delta1 = (zone_size_x(i,j,k)*idx1 +
compute_star.c:		  zone_size_y(j,k)*idy1 +
compute_star.c:		  zone_size_z(j,k)*idz1);
compute_star.c:	delta2 = (zone_size_x(i,j,k)*idx2 +
compute_star.c:		  zone_size_y(j,k)*idy2 +
compute_star.c:		  zone_size_z(j,k)*idz2);
compute_star.c:	v2_mean = 0.5*(v2[ll] + v2[lpropm]);
compute_star.c:	if(v2_mean>0.0){	/* van Leer upwind estimate below */
compute_star.c:	  temp = (delta2-v2_mean*dt);
compute_star.c:	  v1_mean = v1[lperpm]+.5*slope_vvl[lperpm]*temp;
compute_star.c:	  b1_mean = b1[lperpm]+.5*slope_bvl[lperpm]*temp;
compute_star.c:	else{
compute_star.c:	  temp = (delta2+v2_mean*dt);
compute_star.c:	  v1_mean = v1[ll]-0.5*slope_vvl[ll]*temp;
compute_star.c:	  b1_mean = b1[ll]-0.5*slope_bvl[ll]*temp;
compute_star.c:#ifdef STRICTSYM
compute_star.c:	if (fabs(v2_mean)*dt/delta2 < 1e-9) {
compute_star.c:	  v1_mean = 0.5*(v1[ll]+v1[lperpm]);
compute_star.c:	  b1_mean = 0.5*(b1[ll]+b1[lperpm]);
compute_star.c:#endif
compute_star.c:	temp = b1_mean/sqrt(MU0*rho_mean);
compute_star.c:	cp = v1_mean*(real)index + temp;
compute_star.c:	cm = v1_mean*(real)index - temp;
compute_star.c:	  temp = 0.5*(delta1-cp*dt);
compute_star.c:	  bp = b2[lpropm] + temp*slope_b[lpropm];
compute_star.c:	  vp = v2[lpropm] + temp*slope_v[lpropm];
compute_star.c:	else {
compute_star.c:	  temp = 0.5*(delta1+cp*dt);
compute_star.c:	  bp = b2[ll] - temp*slope_b[ll];
compute_star.c:	  vp = v2[ll] - temp*slope_v[ll];
compute_star.c:#ifdef STRICTSYM
compute_star.c:	if (fabs(cp)*dt/delta2 < 1e-9) {
compute_star.c:#endif
compute_star.c:	  temp = 0.5*(delta1-cm*dt);
compute_star.c:	  bm = b2[lpropm] + temp*slope_b[lpropm];
compute_star.c:	  vm = v2[lpropm] + temp*slope_v[lpropm];
compute_star.c:	else {
compute_star.c:	  temp = 0.5*(delta1+cm*dt);
compute_star.c:	  bm = b2[ll] - temp*slope_b[ll];
compute_star.c:	  vm = v2[ll] - temp*slope_v[ll];
compute_star.c:#ifdef STRICTSYM
compute_star.c:	if (fabs(cm)*dt/delta2 < 1e-9) {
compute_star.c:#endif	
compute_star.c:	temp = sqrt(MU0*rho_mean);
compute_star.c:	bs[ll] = 0.5 * ((bp+bm) - (vp-vm)*temp);
compute_star.c:	vs[ll] = 0.5 * ((vp+vm) - (bp-bm)/temp);
compute_vmed.c://#define __GPU
compute_vmed.c://#define __NOPROTO
compute_vmed.c:#include "fargo3d.h"
compute_vmed.c:void ComputeVmed(Field *V) {
compute_vmed.c:  FARGO_SAFE(ComputeVweight(V, Qs));
compute_vmed.c:  reduction_SUM(Qs, 0, Ny+2*NGHY, 0, Nz+2*NGHZ);
compute_vmed.c:  INPUT2D(Reduction2D);
compute_vmed.c:  OUTPUT2D(VxMed);
compute_vmed.c:#ifdef Z
compute_vmed.c:#endif
compute_vmed.c:#ifdef Y
compute_vmed.c:#endif
compute_vmed.c:      VxMed->field_cpu[ll2D] = Reduction2D->field_cpu[ll2D]/(XMAX-XMIN);
compute_vmed.c:#ifdef Y
compute_vmed.c:#endif
compute_vmed.c:#ifdef Z
compute_vmed.c:#endif
compute_vmed.c:void ComputeVweight_cpu(Field *V, Field *Q) {
compute_vmed.c:  real* v     = V->field_cpu;
compute_vmed.c:  real* q     = Q->field_cpu;
compute_vmed.c:  int stride  = Stride_cpu;
compute_vmed.c:  int size_x  = Nx+2*NGHX;
compute_vmed.c:  int size_y  = Ny+2*NGHY;
compute_vmed.c:  int size_z  = Nz+2*NGHZ;
compute_vmed.c:// real xmin(Nx+2*NGHX+1);
compute_vmed.c:#ifdef Z
compute_vmed.c:  for (k = 0; k < size_z; k++) {
compute_vmed.c:#endif 
compute_vmed.c:#ifdef Y
compute_vmed.c:    for (j = 0; j < size_y; j++) {
compute_vmed.c:#endif
compute_vmed.c:#ifdef X
compute_vmed.c:      for (i = 0; i < size_x; i++) {
compute_vmed.c:#endif
compute_vmed.c:#ifdef X
compute_vmed.c:#endif
compute_vmed.c:#ifdef Y
compute_vmed.c:#endif
compute_vmed.c:#ifdef Z
compute_vmed.c:#endif
condinit.c:#include "fargo3d.h"
condinit.c:  mastererr ("\n\n******\n\nERROR\n\n");
condinit.c:  mastererr ("You have forgotten to specify initial conditions.\n");
condinit.c:  mastererr ("These must be defined in the setup directory, in a\n");
condinit.c:  mastererr ("file called condinit.c, with a function void CondInit().\n");
condinit.c:  mastererr ("\nOnce this is done, issue a 'make clean' before rebuilding.\n");
condinit.c:  prs_exit (1);
copy_field.c:#include "fargo3d.h"
copy_field.c:void copy_field_cpu(Field *Dst, Field *Src) {
copy_field.c:  real *dst = Dst->field_cpu;
copy_field.c:  real *src = Src->field_cpu;
copy_field.c:  memcpy (dst, src, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
copy_field.c:void copy_field_gpu(Field *Dst, Field *Src) {
copy_field.c:#ifdef GPU
copy_field.c:  int width, height, pitch;
copy_field.c:  real *dst = Dst->field_gpu;
copy_field.c:  real *src = Src->field_gpu;
copy_field.c:  if (Nx+2*NGHX == 1) { //Actually we need something like check mute in x direction also
copy_field.c:    pitch = Stride_gpu * sizeof(real);
copy_field.c:    width = (Ny+2*NGHY)*sizeof(real);
copy_field.c:    height = Nz+2*NGHZ;
copy_field.c:  } else {
copy_field.c:    pitch = Pitch_gpu * sizeof(real);
copy_field.c:    width = (Nx+2*NGHX)*sizeof(real);
copy_field.c:    height = (Ny+2*NGHY)*(Nz+2*NGHZ);
copy_field.c:  cudaMemcpy2D (dst, pitch, src, pitch, width, height ,cudaMemcpyDeviceToDevice);
copy_field.c:#endif
correct_vtheta.c://#define __GPU
correct_vtheta.c://#define __NOPROTO
correct_vtheta.c:#include "fargo3d.h"
correct_vtheta.c:void CorrectVtheta_cpu(real domega) {
correct_vtheta.c:  real* vt = Vx->field_cpu;
correct_vtheta.c:  int stride = Stride_cpu;
correct_vtheta.c:  int size_x = Nx+2*NGHX;
correct_vtheta.c:  int size_y = Ny+2*NGHY;
correct_vtheta.c:  int size_z = Nz+2*NGHZ;
correct_vtheta.c:// real ymin(Ny+2*NGHY+1);
correct_vtheta.c:// real zmin(Nz+2*NGHZ+1);
correct_vtheta.c:#ifdef Z
correct_vtheta.c:  for(k=0; k < size_z; k++) {
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef Y
correct_vtheta.c:    for (j = 0; j < size_y; j++) {
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef X
correct_vtheta.c:      for (i = 0; i < size_x; i++) {
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef SPHERICAL
correct_vtheta.c:	vt[l] -= domega*ymed(j)*sin(zmed(k));
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef CYLINDRICAL
correct_vtheta.c:	vt[l] -= domega*ymed(j);
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef X
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef Y
correct_vtheta.c:#endif
correct_vtheta.c:#ifdef Z
correct_vtheta.c:#endif
cpvel.c:#include "fargo3d.h"
cpvel.c:void copy_velocities_cpu(int option) {
cpvel.c:#ifdef X
cpvel.c:  real *vx = Vx->field_cpu;
cpvel.c:  real *vx_temp = Vx_temp->field_cpu;
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:  real *vy = Vy->field_cpu;
cpvel.c:  real *vy_temp = Vy_temp->field_cpu;
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:  real *vz = Vz->field_cpu;
cpvel.c:  real *vz_temp = Vz_temp->field_cpu;
cpvel.c:#endif
cpvel.c:#ifdef X
cpvel.c:    INPUT (Vx_temp);
cpvel.c:    memcpy (vx, vx_temp, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    INPUT (Vy_temp);
cpvel.c:    memcpy (vy, vy_temp, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    INPUT (Vz_temp);
cpvel.c:    memcpy (vz, vz_temp, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:  } else {
cpvel.c:#ifdef X
cpvel.c:    OUTPUT (Vx_temp);
cpvel.c:    memcpy (vx_temp, vx, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    OUTPUT (Vy_temp);
cpvel.c:    memcpy (vy_temp, vy, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    OUTPUT (Vz_temp);
cpvel.c:    memcpy (vz_temp, vz, sizeof(real)*(Nx+2*NGHX)*(Ny+2*NGHY)*(Nz+2*NGHZ));
cpvel.c:#endif
cpvel.c:void copy_velocities_gpu(int option) {
cpvel.c:#ifdef GPU
cpvel.c:  int width, height, pitch;
cpvel.c:#ifdef X
cpvel.c:  real *vx = Vx->field_gpu;
cpvel.c:  real *vx_temp = Vx_temp->field_gpu;
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:  real *vy = Vy->field_gpu;
cpvel.c:  real *vy_temp = Vy_temp->field_gpu;
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:  real *vz = Vz->field_gpu;
cpvel.c:  real *vz_temp = Vz_temp->field_gpu;
cpvel.c:#endif
cpvel.c:#ifdef X
cpvel.c:    Input_GPU(Vx_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    Input_GPU(Vy_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    Input_GPU(Vz_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:  } else {
cpvel.c:#ifdef X
cpvel.c:    Output_GPU(Vx_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    Output_GPU(Vy_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    Output_GPU(Vz_temp, __LINE__, __FILE__);
cpvel.c:#endif
cpvel.c:  if (Nx+2*NGHX == 1) { //Actually we need something like check mute in x direction also
cpvel.c:    pitch = Stride_gpu * sizeof(real);
cpvel.c:    width = (Ny+2*NGHY)*sizeof(real);
cpvel.c:    height = Nz+2*NGHZ;
cpvel.c:  } else {
cpvel.c:    pitch = Pitch_gpu * sizeof(real);
cpvel.c:    width = (Nx+2*NGHX)*sizeof(real);
cpvel.c:    height = (Ny+2*NGHY)*(Nz+2*NGHZ);
cpvel.c:#ifdef X
cpvel.c:    cudaMemcpy2D (vx, pitch, vx_temp, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    cudaMemcpy2D (vy, pitch, vy_temp, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    cudaMemcpy2D (vz, pitch, vz_temp, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:  } else {
cpvel.c:#ifdef X
cpvel.c:    cudaMemcpy2D (vx_temp, pitch, vx, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:#ifdef Y
cpvel.c:    cudaMemcpy2D (vy_temp, pitch, vy, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:#ifdef Z
cpvel.c:    cudaMemcpy2D (vz_temp, pitch, vz, pitch, width, height ,cudaMemcpyDeviceToDevice);
cpvel.c:#endif
cpvel.c:#endif
defout.c:#include "fargo3d.h"
defout.c:/* In this file we read the default root directory for output.  They
defout.c: should be defined by the environment variable FARGO_OUT. If this
defout.c: variable is undefined, it is set by default to ./ */
defout.c:void ReadDefaultOut () {
defout.c:  char *defout;
defout.c:  defout = getenv ("FARGO_OUT");
defout.c:  if (defout != NULL) {
defout.c:    strncpy (DefaultOut, defout, MAXLINELENGTH-2);
defout.c:  } else {
defout.c:    sprintf (DefaultOut, "./");
defout.c:  if (*(DefaultOut+strlen(DefaultOut)-1) != '/')
defout.c:    strcat (DefaultOut, "/");	/* Add trailing slash if missing */
defout.c:  masterprint ("The default output directory root is %s\n", DefaultOut);
defout.c:void SubsDef (char *target, char *def){
defout.c:  char new_target[MAXLINELENGTH];
defout.c:  loc = strchr (target, (int)c);
defout.c:    else
defout.c:    if (loc != target) {
defout.c:      masterprint ("Characters located before '%c' wildcard in OUTPUTDIR definition are ignored\n", c);
defout.c:    snprintf (new_target,MAXLINELENGTH/2-1,"%s",def);
defout.c:    strncat (new_target,follow,MAXLINELENGTH/2-1);
defout.c:    strncpy (target, new_target, MAXLINELENGTH-1);
defout.c:  masterprint ("The output directory is %s\n", target);
dh_boundary.c:#include "fargo3d.h"
dh_boundary.c:#define LEFT 0
dh_boundary.c:#define RIGHT 1
dh_boundary.c:#define DOWN 2
dh_boundary.c:#define UP 3
dh_boundary.c:#define INSIDE 0
dh_boundary.c:#define OUTSIDE 1
dh_boundary.c:static boolean BuffersReady = NO;
dh_boundary.c:static int StartAddress_CPU[4][2];
dh_boundary.c:static int StartAddress_GPU[4][2];
dh_boundary.c:static int Stride_j_CPU;
dh_boundary.c:static int Stride_k_CPU;
dh_boundary.c:static int Stride_j_GPU;
dh_boundary.c:static int Stride_k_GPU;
dh_boundary.c:#ifdef GPU
dh_boundary.c:static struct cudaMemcpy3DParms Inner[4] = {0,0,0,0};
dh_boundary.c:static struct cudaMemcpy3DParms Outer[4] = {0,0,0,0};
dh_boundary.c:#endif 
dh_boundary.c:void Prepare_DH_buffers () {
dh_boundary.c:#ifdef GPU
dh_boundary.c:  Inner[LEFT].srcPos = Inner[LEFT].dstPos = make_cudaPos (0, NGHY, 0);
dh_boundary.c:  Outer[LEFT].extent = Inner[LEFT].extent = \
dh_boundary.c:    make_cudaExtent ((Nx+2*NGHX)*sizeof(real), NGHY, Nz+2*NGHZ);
dh_boundary.c:  Outer[LEFT].dstPos = Outer[LEFT].srcPos = make_cudaPos (0, 0, 0);
dh_boundary.c:  Inner[RIGHT].srcPos = Inner[RIGHT].dstPos = make_cudaPos (0, Ny, 0);
dh_boundary.c:  Outer[RIGHT].extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), NGHY, Nz+2*NGHZ);
dh_boundary.c:  Inner[RIGHT].extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), NGHY, Nz+2*NGHZ);
dh_boundary.c:  Outer[RIGHT].dstPos = Outer[RIGHT].srcPos = make_cudaPos (0, Ny+NGHY, 0);
dh_boundary.c:  Inner[DOWN].srcPos = Inner[DOWN].dstPos = make_cudaPos (0, 0, NGHZ);
dh_boundary.c:  Outer[DOWN].extent = Inner[DOWN].extent = \
dh_boundary.c:    make_cudaExtent ((Nx+2*NGHX)*sizeof(real), Ny+2*NGHY, NGHZ);
dh_boundary.c:  Outer[DOWN].dstPos = Outer[DOWN].srcPos = make_cudaPos (0, 0, 0);
dh_boundary.c:  Inner[UP].srcPos = Inner[UP].dstPos = make_cudaPos (0, 0, Nz);
dh_boundary.c:  Inner[UP].extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), Ny+2*NGHY, NGHZ);
dh_boundary.c:  Outer[UP].extent = make_cudaExtent ((Nx+2*NGHX)*sizeof(real), Ny+2*NGHY, NGHZ);
dh_boundary.c:  Outer[UP].dstPos = Outer[UP].srcPos = make_cudaPos (0, 0, Nz+NGHZ);
dh_boundary.c:  Stride_j_CPU = (Nx+2*NGHX);
dh_boundary.c:  Stride_k_CPU = (Nx+2*NGHX)*(Ny+2*NGHY);
dh_boundary.c:  Stride_j_GPU = Pitch_gpu;
dh_boundary.c:  Stride_k_GPU = Stride_gpu;
dh_boundary.c:  StartAddress_CPU[LEFT][OUTSIDE] = 0;
dh_boundary.c:  StartAddress_GPU[LEFT][OUTSIDE] = 0;
dh_boundary.c:  StartAddress_CPU[LEFT][INSIDE] = NGHY*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[LEFT][INSIDE] = NGHY*Pitch_gpu;
dh_boundary.c:  StartAddress_CPU[RIGHT][OUTSIDE] = (Ny+NGHY)*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[RIGHT][OUTSIDE] = (Ny+NGHY)*Pitch_gpu;
dh_boundary.c:  StartAddress_CPU[RIGHT][INSIDE] = Ny*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[RIGHT][INSIDE] = Ny*Pitch_gpu;
dh_boundary.c:  StartAddress_CPU[DOWN][OUTSIDE] = 0;
dh_boundary.c:  StartAddress_GPU[DOWN][OUTSIDE] = 0;
dh_boundary.c:  StartAddress_CPU[DOWN][INSIDE] = NGHZ*(Ny+2*NGHY)*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[DOWN][INSIDE] = NGHZ*Stride_gpu;
dh_boundary.c:  StartAddress_CPU[UP][OUTSIDE] = (Nz+NGHZ)*(Ny+2*NGHY)*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[UP][OUTSIDE] = (Nz+NGHZ)*Stride_gpu;
dh_boundary.c:  StartAddress_CPU[UP][INSIDE] = Nz*(Ny+2*NGHY)*(Nx+2*NGHX);
dh_boundary.c:  StartAddress_GPU[UP][INSIDE] = Nz*Stride_gpu;
dh_boundary.c:  BuffersReady = YES;
dh_boundary.c:#endif
dh_boundary.c:void Input_Contour_Inside (Field *f, int side) { // Active zones go from D to H
dh_boundary.c:#ifdef GPU
dh_boundary.c:  if (BuffersReady == NO) Prepare_DH_buffers();
dh_boundary.c:  if (side>3) return;
dh_boundary.c:  if (f->fresh_inside_contour_cpu[side] == YES) return;
dh_boundary.c:  //  printf ("Field %s sends boundary %d from D to H\n", f->name, side);
dh_boundary.c:    cudaMemcpy2D(f->field_cpu+StartAddress_CPU[side][INSIDE],
dh_boundary.c:		 (Ny+2*NGHY)*sizeof(real),
dh_boundary.c:		 f->field_gpu+StartAddress_GPU[side][INSIDE],
dh_boundary.c:		 Stride_k_GPU*sizeof(real),
dh_boundary.c:		 Nj[side][INSIDE]*sizeof(real),Nk[side][INSIDE],
dh_boundary.c:		 cudaMemcpyDeviceToHost);
dh_boundary.c:  } else {
dh_boundary.c:    Inner[side].kind = cudaMemcpyDeviceToHost;
dh_boundary.c:    Inner[side].srcPtr = f->gpu_pp;
dh_boundary.c:    Inner[side].dstPtr = f->cpu_pp;
dh_boundary.c:    cudaMemcpy3D (&(Inner[side]));
dh_boundary.c:    check_errors ("memcpy3d");
dh_boundary.c:  f->fresh_inside_contour_cpu[side] = YES;
dh_boundary.c:#endif
dh_boundary.c:void Output_Contour_Outside (Field *f, int side) { // Ghost zones go from H to D
dh_boundary.c:#ifdef GPU
dh_boundary.c:  if (BuffersReady == NO) Prepare_DH_buffers();
dh_boundary.c:  if (side>3) return;
dh_boundary.c:  if (f->fresh_outside_contour_gpu[side] == YES) return;
dh_boundary.c:  //  printf ("Field %s sends boundary %d from H to D\n", f->name, side);
dh_boundary.c:    cudaMemcpy2D(f->field_gpu+StartAddress_GPU[side][OUTSIDE],
dh_boundary.c:		 Stride_k_GPU*sizeof(real),
dh_boundary.c:		 f->field_cpu+StartAddress_CPU[side][OUTSIDE],
dh_boundary.c:		 (Ny+2*NGHY)*sizeof(real),
dh_boundary.c:		 Nj[side][OUTSIDE]*sizeof(real),Nk[side][OUTSIDE],
dh_boundary.c:		 cudaMemcpyHostToDevice);
dh_boundary.c:  } else {
dh_boundary.c:    Outer[side].kind = cudaMemcpyHostToDevice;
dh_boundary.c:    Outer[side].srcPtr = f->cpu_pp;
dh_boundary.c:    Outer[side].dstPtr = f->gpu_pp;
dh_boundary.c:    cudaMemcpy3D (&(Outer[side]));
dh_boundary.c:    check_errors ("memcpy3d_outer");
dh_boundary.c:  f->fresh_outside_contour_gpu[side] = YES;
dh_boundary.c:#endif
divrho.c://#define __GPU
divrho.c://#define __NOPROTO
divrho.c:#include "fargo3d.h"
divrho.c:void DivideByRho_cpu(Field *Q) {
divrho.c:  INPUT(Density);
divrho.c:  real* q      = Q->field_cpu;
divrho.c:  real* divrho = DivRho->field_cpu;
divrho.c:  real* rho    = Density->field_cpu;
divrho.c:  int size_x = Nx+2*NGHX;
divrho.c:  int size_y = Ny+2*NGHY;
divrho.c:  int size_z = Nz+2*NGHZ;
divrho.c:  int stride = Stride_cpu;
divrho.c:#ifdef Z
divrho.c:  for (k=0; k<size_z; k++) {
divrho.c:#endif
divrho.c:#ifdef Y
divrho.c:    for (j=0; j<size_y; j++) {
divrho.c:#endif
divrho.c:#ifdef X
divrho.c:      for (i=0; i<size_x; i++) {
divrho.c:#endif
divrho.c:#ifdef X
divrho.c:#endif
divrho.c:#ifdef Y
divrho.c:#endif
divrho.c:#ifdef Z
divrho.c:#endif
dust_diffusion_coefficients.c://#define __GPU
dust_diffusion_coefficients.c://#define __NOPROTO
dust_diffusion_coefficients.c:#include "fargo3d.h"
dust_diffusion_coefficients.c:void DustDiffusion_Coefficients_cpu() {
dust_diffusion_coefficients.c:#ifdef ALPHAVISCOSITY
dust_diffusion_coefficients.c:  INPUT(Energy);
dust_diffusion_coefficients.c:#ifdef ADIABATIC
dust_diffusion_coefficients.c:  INPUT(Density);
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:  real* sdiff_yfzc = Sdiffyfzc->field_cpu;
dust_diffusion_coefficients.c:  real* sdiff_yczc = Sdiffyczc->field_cpu;
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:  real* sdiff_yczf = Sdiffyczf->field_cpu;
dust_diffusion_coefficients.c:  real* sdiff_yfzf = Sdiffyfzf->field_cpu;
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef ALPHAVISCOSITY  
dust_diffusion_coefficients.c:#ifdef ISOTHERMAL
dust_diffusion_coefficients.c:  real* cs = Fluids[0]->Energy->field_cpu;
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef ADIABATIC
dust_diffusion_coefficients.c:  real* e = Fluids[0]->Energy->field_cpu;
dust_diffusion_coefficients.c:  real* rhog = Fluids[0]->Density->field_cpu;
dust_diffusion_coefficients.c:  real gamma = GAMMA;
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:  real alphavisc = ALPHA;
dust_diffusion_coefficients.c:#else
dust_diffusion_coefficients.c:  real nu = NU;
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:  int stride = Stride_cpu;
dust_diffusion_coefficients.c:  int size_x = Nx+2*NGHX;
dust_diffusion_coefficients.c:  int size_y = Ny+2*NGHY;
dust_diffusion_coefficients.c:  int size_z = Nz+2*NGHZ;
dust_diffusion_coefficients.c:#ifdef ALPHAVISCOSITY
dust_diffusion_coefficients.c:  real r3yczc;
dust_diffusion_coefficients.c:  real r3yfzc;
dust_diffusion_coefficients.c:  real soundspeed2;
dust_diffusion_coefficients.c:  real soundspeedf2;
dust_diffusion_coefficients.c:  real soundspeedfz2;
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:// real ymin(Ny+2*NGHY+1);
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:  for (k=0; k<size_z; k++) {
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Y
dust_diffusion_coefficients.c:    for (j=0; j<size_y; j++) {
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef X
dust_diffusion_coefficients.c:      for (i=0; i<size_x; i++ ) {
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Y
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef ALPHAVISCOSITY
dust_diffusion_coefficients.c:#ifdef ISOTHERMAL
dust_diffusion_coefficients.c:	soundspeed2 = cs[ll]*cs[ll];
dust_diffusion_coefficients.c:	  soundspeedf2 = soundspeed2;
dust_diffusion_coefficients.c:	else
dust_diffusion_coefficients.c:	  soundspeedf2 = 0.5*(cs[ll]+cs[llym])*0.5*(cs[ll]+cs[llym]);
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:          soundspeedfz2 = soundspeed2;
dust_diffusion_coefficients.c:        else
dust_diffusion_coefficients.c:          soundspeedfz2 = 0.5*(cs[ll]+cs[llzm])*0.5*(cs[ll]+cs[llzm]);
dust_diffusion_coefficients.c:#endif //Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef ADIABATIC
dust_diffusion_coefficients.c:	soundspeed2 = gamma*(gamma-1.0)*e[ll]/rhog[ll];
dust_diffusion_coefficients.c:	  soundspeedf2 = soundspeed2;
dust_diffusion_coefficients.c:	else
dust_diffusion_coefficients.c:	  soundspeedf2 = gamma*(gamma-1.0)*(e[ll]+e[llym])/(rhog[ll]+rhog[llym]);
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:	r3yczc = ymed(j)*ymed(j)*ymed(j);
dust_diffusion_coefficients.c:	sdiff_yczc[ll] = alphavisc*soundspeed2/sqrt(G*MSTAR/r3yczc);
dust_diffusion_coefficients.c:	sdiff_yfzc[ll] = alphavisc*soundspeedf2/sqrt(G*MSTAR/r3yfzc);
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:	sdiff_yczf[ll] = alphavisc*soundspeedfz2/sqrt(G*MSTAR/r3yczc);
dust_diffusion_coefficients.c:	sdiff_yfzf[ll] = alphavisc*soundspeedfz2/sqrt(G*MSTAR/r3yfzc);
dust_diffusion_coefficients.c:#endif //Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef VISCOSITY
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef X
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Y
dust_diffusion_coefficients.c:#endif
dust_diffusion_coefficients.c:#ifdef Z
dust_diffusion_coefficients.c:#endif
dust_diffusion_core.c://#define __GPU
dust_diffusion_core.c://#define __NOPROTO
dust_diffusion_core.c:#include "fargo3d.h"
dust_diffusion_core.c:void DustDiffusion_Core_cpu(real dt) {
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:#endif
dust_diffusion_core.c:  INPUT(Density);
dust_diffusion_core.c:  INPUT(Fluids[0]->Density);
dust_diffusion_core.c:  OUTPUT(Pressure);// we use the pressure field for temporal storage
dust_diffusion_core.c:  //Arrays Mmx, Mpx, Mmy and Mpy were filled with the dust diffusion coefficients in DustDiffusion_Coefficients()
dust_diffusion_core.c:  real* sdiff_yfzc = Sdiffyfzc->field_cpu;
dust_diffusion_core.c:  real* sdiff_yczc = Sdiffyczc->field_cpu;
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:  real* sdiff_yczf = Sdiffyczf->field_cpu;
dust_diffusion_core.c:  real* sdiff_yfzf = Sdiffyfzf->field_cpu;
dust_diffusion_core.c:#endif
dust_diffusion_core.c:  real* rhod  = Density->field_cpu;
dust_diffusion_core.c:  real* rhog  = Fluids[0]->Density->field_cpu;
dust_diffusion_core.c:  real* temp  = Pressure->field_cpu;
dust_diffusion_core.c:  int stride = Stride_cpu;
dust_diffusion_core.c:  int size_x = Nx+2*NGHX;
dust_diffusion_core.c:  int size_y = Ny+2*NGHY-1;
dust_diffusion_core.c:  int size_z = Nz+2*NGHZ-1;
dust_diffusion_core.c:  real c;
dust_diffusion_core.c:  real update;
dust_diffusion_core.c:#ifdef X
dust_diffusion_core.c:  real d1;
dust_diffusion_core.c:  real d2;
dust_diffusion_core.c:  real cxp;
dust_diffusion_core.c:  real cxm;
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Y
dust_diffusion_core.c:  real cyp;
dust_diffusion_core.c:  real cym;
dust_diffusion_core.c:  real d3;
dust_diffusion_core.c:  real d4;
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:  real czp;
dust_diffusion_core.c:  real czm;
dust_diffusion_core.c:  real d5;
dust_diffusion_core.c:  real d6;
dust_diffusion_core.c:#endif
dust_diffusion_core.c:  real dxmedm;
dust_diffusion_core.c:  real dxmedp;
dust_diffusion_core.c:  real dxmin;
dust_diffusion_core.c:// real xmin(Nx+2*NGHX+1);
dust_diffusion_core.c:// real ymin(Ny+2*NGHY+1);
dust_diffusion_core.c:// real zmin(Nz+2*NGHZ+1);
dust_diffusion_core.c:// real InvDiffXmed(Nx+2*NGHX);
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:  for (k=1; k<size_z; k++) {
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Y
dust_diffusion_core.c:    for (j=1; j<size_y; j++) {
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef X
dust_diffusion_core.c:      for (i=0; i<size_x; i++ ) {
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef X
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Y
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:#endif
dust_diffusion_core.c:	update = 0.0;
dust_diffusion_core.c:	c    = rhod[ll]/(rhod[ll] + rhog[ll]); //Cell centered
dust_diffusion_core.c:	dxmedp = 1.0/InvDiffXmed(ixp);
dust_diffusion_core.c:	dxmedm = 1.0/InvDiffXmed(i);
dust_diffusion_core.c:#ifdef X
dust_diffusion_core.c:        d1   = 0.25*(rhod[ll] + rhog[ll] + rhod[llxp] + rhog[llxp])*(sdiff_yczc[llxp]+sdiff_yczc[ll]); //face centered in X
dust_diffusion_core.c:        d2   = 0.25*(rhod[ll] + rhog[ll] + rhod[llxm] + rhog[llxm])*(sdiff_yczc[llxm]+sdiff_yczc[ll]); //face centered in X
dust_diffusion_core.c:	cxp  = rhod[llxp]/(rhod[llxp] + rhog[llxp]);                                                   //Cell centered
dust_diffusion_core.c:        cxm  = rhod[llxm]/(rhod[llxm] + rhog[llxm]);                                                   //Cell centered
dust_diffusion_core.c:#ifdef CARTESIAN
dust_diffusion_core.c:	update += 1.0/(dxmin)*(d1*(cxp-c)/(dxmedp) - (d2*(c-cxm))/(dxmedm));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef CYLINDRICAL
dust_diffusion_core.c:        update += 1.0/ymed(j)/ymed(j)/(dxmin)*(d1*(cxp-c)/(dxmedp) - (d2*(c-cxm))/(dxmedm));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef SPHERICAL
dust_diffusion_core.c:        update += 1.0/ymed(j)/ymed(j)/sin(zmed(k))/sin(zmed(k))/(dxmin)*(d1*(cxp-c)/(dxmedp) - (d2*(c-cxm))/(dxmedm));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#endif //X
dust_diffusion_core.c:#ifdef Y
dust_diffusion_core.c:	d3   = 0.5*(rhod[ll] + rhog[ll] + rhod[llyp] + rhog[llyp])*sdiff_yfzc[llyp];//face centered in Y
dust_diffusion_core.c:	d4   = 0.5*(rhod[ll] + rhog[ll] + rhod[llym] + rhog[llym])*sdiff_yfzc[ll];  //face centered in Y
dust_diffusion_core.c:	cyp  = rhod[llyp]/(rhod[llyp] + rhog[llyp]);                                //Cell centered
dust_diffusion_core.c:	cym  = rhod[llym]/(rhod[llym] + rhog[llym]);                                //Cell centered
dust_diffusion_core.c:#ifdef CARTESIAN
dust_diffusion_core.c:	update += 1.0/(ymin(j+1)-ymin(j))*(d3*(cyp-c)/(ymed(j+1)-ymed(j)) - (d4*(c-cym))/(ymed(j)-ymed(j-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef CYLINDRICAL
dust_diffusion_core.c:        update += 1.0/ymed(j)/(ymin(j+1)-ymin(j))*(ymin(j+1)*d3*(cyp-c)/(ymed(j+1)-ymed(j)) -
dust_diffusion_core.c:						   (ymin(j)*d4*(c-cym))/(ymed(j)-ymed(j-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef SPHERICAL
dust_diffusion_core.c:	update += 1.0/ymed(j)/ymed(j)/(ymin(j+1)-ymin(j))*(ymin(j+1)*ymin(j+1)*d3*(cyp-c)/(ymed(j+1)-ymed(j)) -
dust_diffusion_core.c:							   (ymin(j)*ymin(j)*d4*(c-cym))/(ymed(j)-ymed(j-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#endif //Y
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:	d5   = 0.5*(rhod[ll] + rhog[ll] + rhod[llzp] + rhog[llzp])*sdiff_yczf[llzp]; // face centered in Z
dust_diffusion_core.c:	d6   = 0.5*(rhod[ll] + rhog[ll] + rhod[llzm] + rhog[llzm])*sdiff_yczf[ll];   // face centered in Z
dust_diffusion_core.c:	czp  = rhod[llzp]/(rhod[llzp] + rhog[llzp]);                                 // Cell centered
dust_diffusion_core.c:	czm  = rhod[llzm]/(rhod[llzm] + rhog[llzm]);                                 // Cell centered
dust_diffusion_core.c:#ifdef CARTESIAN
dust_diffusion_core.c:	update += 1.0/(zmin(k+1)-zmin(k))*(d5*(czp-c)/(zmed(k+1)-zmed(k)) - (d6*(c-czm))/(zmed(k)-zmed(k-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef CYLINDRICAL
dust_diffusion_core.c:        update += 1.0/(zmin(k+1)-zmin(k))*(d5*(czp-c)/(zmed(k+1)-zmed(k)) - (d6*(c-czm))/(zmed(k)-zmed(k-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef SPHERICAL
dust_diffusion_core.c:	update += 1.0/ymed(j)/ymed(j)/sin(zmed(k))/(zmin(k+1)-zmin(k))*(sin(zmin(k+1))*d5*(czp-c)/(zmed(k+1)-zmed(k)) -
dust_diffusion_core.c:									(sin(zmin(k))*d6*(c-czm))/(zmed(k)-zmed(k-1)));
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#endif // Z
dust_diffusion_core.c:      	temp[ll] = rhod[ll] + dt*update; // Density update
dust_diffusion_core.c:#ifdef X
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Y
dust_diffusion_core.c:#endif
dust_diffusion_core.c:#ifdef Z
dust_diffusion_core.c:#endif
dust_diffusion_main.c:#include "fargo3d.h"
dust_diffusion_main.c:void DustDiffusion_Main(real dt) {
dust_diffusion_main.c:    if (Fluids[0]->Fluidtype != GAS) {
dust_diffusion_main.c:      mastererr("ERROR -  Dust diffusion module assumes that Fluids[0] is of type GAS.\n");
dust_diffusion_main.c:      mastererr("ERROR -  You can fix this by defining the Fluid with:\n");
dust_diffusion_main.c:      mastererr("Fluids[0] = CreateFluid(<label>,GAS);");
dust_diffusion_main.c:      prs_exit (1);      
dust_diffusion_main.c:  // In principle, Diffusion_Coefficients() does not need to be called every time step
dust_diffusion_main.c:  // for temporary constant viscosity.
dust_diffusion_main.c:  FARGO_SAFE(DustDiffusion_Coefficients());
dust_diffusion_main.c:	     if(Fluidtype == DUST) {
dust_diffusion_main.c:	       FARGO_SAFE(DustDiffusion_Core(dt));        // Updated density is stored in Pressure field.
dust_diffusion_main.c:	       FARGO_SAFE(copy_field(Density,Pressure));  // We update dust densities from the Pressure field.
dust_diffusion_main.c:	       FARGO_SAFE(FillGhosts(DENS));  // We update dust densities from the Pressure field.
fargo_mhd.c:#include "fargo3d.h"
fargo_mhd.c:void Compute_Staggered_2D_fields (real dt)  {
fargo_mhd.c:  real *vxhy, *vxhyr, *vxhz, *vxhzr, *vxmed;
fargo_mhd.c:  vxhy  = Vxhy->field_cpu;
fargo_mhd.c:  vxhz  = Vxhz->field_cpu;
fargo_mhd.c:  vxhyr = Vxhyr->field_cpu;
fargo_mhd.c:  vxhzr = Vxhzr->field_cpu;
fargo_mhd.c:  nxhy  = Nxhy->field_cpu;
fargo_mhd.c:  nxhz  = Nxhz->field_cpu;
fargo_mhd.c:  vxmed = VxMed->field_cpu;
fargo_mhd.c:  INPUT2D  (VxMed);
fargo_mhd.c:      vxhy[l2D] = .5*(vxmed[l2D-1]+vxmed[l2D]);
fargo_mhd.c:      nxhy[l2D] = (int)(floor(vxhy[l2D]*dt/edge_size_x_middlez_lowy(i,j,k)+.5));
fargo_mhd.c:      vxhyr[l2D] = vxhy[l2D] - (real)nxhy[l2D]*edge_size_x_middlez_lowy(i,j,k)/dt;
fargo_mhd.c:      vxhz[l2D] = .5*(vxmed[l2D-Ny-2*NGHY]+vxmed[l2D]);
fargo_mhd.c:      nxhz[l2D] = (int)(floor(vxhz[l2D]*dt/edge_size_x_middley_lowz(i,j,k)+.5));
fargo_mhd.c:      vxhzr[l2D] = vxhz[l2D] - (real)nxhz[l2D]*edge_size_x_middley_lowz(i,j,k)/dt;
fargo_mhd.c:void MHD_fargo (real dt) {
fargo_mhd.c:  Compute_Staggered_2D_fields (dt);
fargo_mhd.c:  FARGO_SAFE(VanLeerX_PPA_2D(By, Emfz, Vxhyr, dt));
fargo_mhd.c:  FARGO_SAFE(VanLeerX_PPA_2D(Bz, Emfy, Vxhzr, dt));
fargo_mhd.c:  FARGO_SAFE(EMF_Upstream_Integrate(dt));
fargo_mhd.c:  FARGO_SAFE(AdvectSHIFT (Emfz, Nxhy));
fargo_mhd.c:  FARGO_SAFE(AdvectSHIFT (Emfy, Nxhz));
fargo_mhd.c:  FARGO_SAFE(UpdateMagneticField (1.0, 1,0,0));
fargo_mhd.c:  FARGO_SAFE(UpdateMagneticField (1.0, 0,1,0));
fargo_mhd.c:  FARGO_SAFE(UpdateMagneticField (1.0, 0,0,1));
fargo_ppa_a.c://#define __GPU
fargo_ppa_a.c://#define __NOPROTO
fargo_ppa_a.c:#include "fargo3d.h"
fargo_ppa_a.c:void VanLeerX_PPA_a_cpu(Field *Q){
fargo_ppa_a.c:  OUTPUT(Slope);
fargo_ppa_a.c:#ifdef PPA_STEEPENER
fargo_ppa_a.c:#endif
fargo_ppa_a.c:  real* slope = Slope->field_cpu;
fargo_ppa_a.c:#ifdef PPA_STEEPENER
fargo_ppa_a.c:  real* lapla = LapPPA->field_cpu;
fargo_ppa_a.c:#endif
fargo_ppa_a.c:  real* q = Q->field_cpu;
fargo_ppa_a.c:  int stride = Stride_cpu;
fargo_ppa_a.c:  int size_x = XIP; 
fargo_ppa_a.c:  int size_y = Ny+2*NGHY;
fargo_ppa_a.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_a.c:  real dqm;
fargo_ppa_a.c:  real dqp;
fargo_ppa_a.c:  real work;
fargo_ppa_a.c:#ifdef Z
fargo_ppa_a.c:  for (k=0; k<size_z; k++) {
fargo_ppa_a.c:#endif
fargo_ppa_a.c:#ifdef Y
fargo_ppa_a.c:    for (j=0; j<size_y; j++) {
fargo_ppa_a.c:#endif
fargo_ppa_a.c:      for (i=XIM; i<size_x; i++) {
fargo_ppa_a.c:	if(dqp*dqm<=0.0)  slope[l] = 0.0;
fargo_ppa_a.c:	else { // Monotonized centered slope limited
fargo_ppa_a.c:	  slope[l] = 0.5*(q[lxp]-q[lxm]);
fargo_ppa_a.c:	  work = fabs(slope[l]);
fargo_ppa_a.c:	  if (slope[l] < 0) slope[l] = -work;
fargo_ppa_a.c:	  else slope[l] = work;
fargo_ppa_a.c:#ifdef PPA_STEEPENER
fargo_ppa_a.c:#endif
fargo_ppa_a.c:#ifdef Y
fargo_ppa_a.c:#endif
fargo_ppa_a.c:#ifdef Z
fargo_ppa_a.c:#endif
fargo_ppa_b.c://#define __GPU
fargo_ppa_b.c://#define __NOPROTO
fargo_ppa_b.c:#include "fargo3d.h"
fargo_ppa_b.c:void VanLeerX_PPA_b_cpu(Field *Q){
fargo_ppa_b.c:  INPUT(Slope);
fargo_ppa_b.c:  real* slope = Slope->field_cpu;
fargo_ppa_b.c:  real* q = Q->field_cpu;
fargo_ppa_b.c:  real* qL = QL->field_cpu;
fargo_ppa_b.c:  real* qR = QR->field_cpu;
fargo_ppa_b.c:  int stride = Stride_cpu;
fargo_ppa_b.c:  int size_x = XIP;
fargo_ppa_b.c:  int size_y = Ny+2*NGHY;
fargo_ppa_b.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_b.c:  real temp;
fargo_ppa_b.c:#ifdef Z
fargo_ppa_b.c:  for (k=0; k<size_z; k++) {
fargo_ppa_b.c:#endif
fargo_ppa_b.c:#ifdef Y
fargo_ppa_b.c:    for (j=0; j<size_y; j++) {
fargo_ppa_b.c:#endif
fargo_ppa_b.c:      for (i=0; i<size_x; i++)	{// Now we compute q_j+1/2
fargo_ppa_b.c:	temp = q[ll]+0.5*(q[llxp]-q[ll])-1.0/6.0*(slope[llxp]-slope[ll]);
fargo_ppa_b.c:	qR[ll] = temp;
fargo_ppa_b.c:	qL[llxp] = temp;
fargo_ppa_b.c:#ifdef Y
fargo_ppa_b.c:#endif
fargo_ppa_b.c:#ifdef Z
fargo_ppa_b.c:#endif
fargo_ppa_c.c://#define __GPU
fargo_ppa_c.c://#define __NOPROTO
fargo_ppa_c.c:#include "fargo3d.h"
fargo_ppa_c.c:void VanLeerX_PPA_c_cpu(Field *Q){
fargo_ppa_c.c:  real* q  = Q->field_cpu;
fargo_ppa_c.c:  real* qL = QL->field_cpu;
fargo_ppa_c.c:  real* qR = QR->field_cpu;
fargo_ppa_c.c:  int stride = Stride_cpu;
fargo_ppa_c.c:  int size_x = Nx+2*NGHX;
fargo_ppa_c.c:  int size_y = Ny+2*NGHY;
fargo_ppa_c.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_c.c:  real diff;
fargo_ppa_c.c:  real cord;
fargo_ppa_c.c:#ifdef Z
fargo_ppa_c.c:  for (k=0; k<size_z; k++) {
fargo_ppa_c.c:#endif
fargo_ppa_c.c:#ifdef Y
fargo_ppa_c.c:    for (j=0; j<size_y; j++) {
fargo_ppa_c.c:#endif
fargo_ppa_c.c:      for (i=0; i<size_x; i++) {
fargo_ppa_c.c:#ifdef Y
fargo_ppa_c.c:#endif
fargo_ppa_c.c:#ifdef Z
fargo_ppa_c.c:#endif
fargo_ppa_d.c://#define __GPU
fargo_ppa_d.c://#define __NOPROTO
fargo_ppa_d.c:#include "fargo3d.h"
fargo_ppa_d.c:void VanLeerX_PPA_d_cpu(real dt, Field *Q, Field *Qs, Field *Vx_t){
fargo_ppa_d.c:  real* vx = Vx_t->field_cpu;
fargo_ppa_d.c:  real* q  = Q->field_cpu   ;
fargo_ppa_d.c:  real* qs = Qs->field_cpu  ;
fargo_ppa_d.c:  real* qL = QL->field_cpu  ;
fargo_ppa_d.c:  real* qR = QR->field_cpu  ;
fargo_ppa_d.c:  int stride = Stride_cpu;
fargo_ppa_d.c:  int size_x = Nx+2*NGHX;
fargo_ppa_d.c:  int size_y = Ny+2*NGHY;
fargo_ppa_d.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_d.c:  real ksi;
fargo_ppa_d.c:// real xmin(Nx+1);
fargo_ppa_d.c:// real ymin(Ny+2*NGHY+1);
fargo_ppa_d.c:// real zmin(Nz+2*NGHZ+1);
fargo_ppa_d.c:#ifdef Z
fargo_ppa_d.c:  for (k=0; k<size_z; k++) {
fargo_ppa_d.c:#endif
fargo_ppa_d.c:#ifdef Y
fargo_ppa_d.c:    for (j=0; j<size_y; j++) {
fargo_ppa_d.c:#endif
fargo_ppa_d.c:      for (i=XIM; i<size_x; i++) {
fargo_ppa_d.c:	  ksi = vx[ll]*dt/zone_size_x(i,j,k);
fargo_ppa_d.c:	} else {
fargo_ppa_d.c:	  ksi = -vx[ll]*dt/zone_size_x(i,j,k);
fargo_ppa_d.c:#ifdef Y
fargo_ppa_d.c:#endif
fargo_ppa_d.c:#ifdef Z
fargo_ppa_d.c:#endif
fargo_ppa_d_2d.c://#define __GPU
fargo_ppa_d_2d.c://#define __NOPROTO
fargo_ppa_d_2d.c:#include "fargo3d.h"
fargo_ppa_d_2d.c:void VanLeerX_PPA_d_2d_cpu(real dt, Field *Q, Field *Qs, Field2D *Vx_t){
fargo_ppa_d_2d.c:  real* vx = Vx_t->field_cpu;
fargo_ppa_d_2d.c:  real* q  = Q->field_cpu   ;
fargo_ppa_d_2d.c:  real* qs = Qs->field_cpu  ;
fargo_ppa_d_2d.c:  real* qL = QL->field_cpu  ;
fargo_ppa_d_2d.c:  real* qR = QR->field_cpu  ;
fargo_ppa_d_2d.c:  int stride = Stride_cpu;
fargo_ppa_d_2d.c:  int size_x = Nx+2*NGHX;
fargo_ppa_d_2d.c:  int size_y = Ny+2*NGHY;
fargo_ppa_d_2d.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_d_2d.c:  real ksi;
fargo_ppa_d_2d.c://Parsed as copytosymbol, from a _d variable allocated on the gpu by users.
fargo_ppa_d_2d.c:// real xmin(Nx+1);
fargo_ppa_d_2d.c:// real ymin(Ny+2*NGHY+1);
fargo_ppa_d_2d.c:// real zmin(Nz+2*NGHZ+1);
fargo_ppa_d_2d.c:#ifdef Z
fargo_ppa_d_2d.c:  for (k=1; k<size_z; k++) {
fargo_ppa_d_2d.c:#endif
fargo_ppa_d_2d.c:#ifdef Y
fargo_ppa_d_2d.c:    for (j=1; j<size_y; j++) {
fargo_ppa_d_2d.c:#endif
fargo_ppa_d_2d.c:      for (i=XIM; i<size_x; i++) {
fargo_ppa_d_2d.c:	l2d = l2D; // Must go there instead of being out of the loop on 'i'
fargo_ppa_d_2d.c:	  ksi = vx[l2d]*dt/zone_size_x(i,j,k);
fargo_ppa_d_2d.c:	} else {
fargo_ppa_d_2d.c:	  ksi = -vx[l2d]*dt/zone_size_x(i,j,k);
fargo_ppa_d_2d.c:#ifdef Y
fargo_ppa_d_2d.c:#endif
fargo_ppa_d_2d.c:#ifdef Z
fargo_ppa_d_2d.c:#endif
fargo_ppa_steep.c://#define __GPU
fargo_ppa_steep.c://#define __NOPROTO
fargo_ppa_steep.c:#include "fargo3d.h"
fargo_ppa_steep.c:// The values below are those defined by Colella and Woodward 1984,
fargo_ppa_steep.c:// JCP, 54, 174 In the present implementation it is recommended to use
fargo_ppa_steep.c:// simple PPA advection (this is the default) and not to activate the
fargo_ppa_steep.c:// steepening solution implemented in this file (this would be
fargo_ppa_steep.c:// obtained by adding: FARGOP_OPT += -DPPA_STEEPENER in the .opt
fargo_ppa_steep.c:// file). Indeed the default 3 values below have been found to yield
fargo_ppa_steep.c:// spurious small scale vortices in some high resolution setups.
fargo_ppa_steep.c:#define ETA1 20.0
fargo_ppa_steep.c:#define ETA2 0.05
fargo_ppa_steep.c:#define EPS  0.01
fargo_ppa_steep.c:void VanLeerX_PPA_steep_cpu(Field *Q){
fargo_ppa_steep.c:  INPUT(Slope);
fargo_ppa_steep.c:  real* slope = Slope->field_cpu;
fargo_ppa_steep.c:  real* lapla = LapPPA->field_cpu;
fargo_ppa_steep.c:  real* q = Q->field_cpu;
fargo_ppa_steep.c:  real* qL = QL->field_cpu;
fargo_ppa_steep.c:  real* qR = QR->field_cpu;
fargo_ppa_steep.c:  int stride = Stride_cpu;
fargo_ppa_steep.c:  int size_x = XIP; 
fargo_ppa_steep.c:  int size_y = Ny+2*NGHY;
fargo_ppa_steep.c:  int size_z = Nz+2*NGHZ;
fargo_ppa_steep.c:  real eta;
fargo_ppa_steep.c:  real etatilde;
fargo_ppa_steep.c:  real aL;
fargo_ppa_steep.c:  real aR;
fargo_ppa_steep.c:#ifdef Z
fargo_ppa_steep.c:  for (k=0; k<size_z; k++) {
fargo_ppa_steep.c:#endif
fargo_ppa_steep.c:#ifdef Y
fargo_ppa_steep.c:    for (j=0; j<size_y; j++) {
fargo_ppa_steep.c:#endif
fargo_ppa_steep.c:      for (i=XIM; i<size_x; i++)	{// Now we compute q_j+1/2
fargo_ppa_steep.c:	      (fabs(q[llxp]-q[llxm]) > EPS*fabs(q[llxm]))) {  /* Do we have a discontinuity ? */
fargo_ppa_steep.c:	    etatilde = - (lapla[llxp]-lapla[llxm])/(q[llxp]-q[llxm]);
fargo_ppa_steep.c:	    eta = ETA1*(etatilde-ETA2);
fargo_ppa_steep.c:	    if (eta > 1.0) eta=1.0;
fargo_ppa_steep.c:	    if (eta < 0.0) eta=0.0;
fargo_ppa_steep.c:	    aL = q[llxm]+.5*slope[llxm];
fargo_ppa_steep.c:	    aR = q[llxp]-.5*slope[llxp];
fargo_ppa_steep.c:	    qL[ll] = qL[ll]*(1.0-eta) + aL*eta;
fargo_ppa_steep.c:	    qR[ll] = qR[ll]*(1.0-eta) + aR*eta;
fargo_ppa_steep.c:#ifdef Y
fargo_ppa_steep.c:#endif
fargo_ppa_steep.c:#ifdef Z
fargo_ppa_steep.c:#endif
fill_ghostsx.c://#define __GPU
fill_ghostsx.c://#define __NOPROTO
fill_ghostsx.c:#include "fargo3d.h"
fill_ghostsx.c:  INPUT(Density);
fill_ghostsx.c:  //#ifdef ADIABATIC
fill_ghostsx.c:  INPUT(Energy);
fill_ghostsx.c:  //#endif
fill_ghostsx.c:#ifdef X
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef MHD
fill_ghostsx.c:#endif
fill_ghostsx.c:  OUTPUT(Density);
fill_ghostsx.c:  //#ifdef ADIABATIC
fill_ghostsx.c:  OUTPUT(Energy);
fill_ghostsx.c:  //#endif
fill_ghostsx.c:#ifdef X
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef MHD
fill_ghostsx.c:#endif
fill_ghostsx.c:  real* rho = Density->field_cpu;
fill_ghostsx.c:#ifdef X  
fill_ghostsx.c:  real* vx = Vx->field_cpu;
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:  real* vy = Vy->field_cpu;
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:  real* vz = Vz->field_cpu;
fill_ghostsx.c:#endif
fill_ghostsx.c:  //#ifdef ADIABATIC
fill_ghostsx.c:  real* energy = Energy->field_cpu;
fill_ghostsx.c:  //#endif
fill_ghostsx.c:#ifdef MHD
fill_ghostsx.c:  real* bx = Bx->field_cpu;
fill_ghostsx.c:  real* by = By->field_cpu;
fill_ghostsx.c:  real* bz = Bz->field_cpu;
fill_ghostsx.c:#endif
fill_ghostsx.c:  int stride = Stride_cpu;
fill_ghostsx.c:  int size_x = NGHX; 
fill_ghostsx.c:  int size_y = Ny+2*NGHY;
fill_ghostsx.c:  int size_z = Nz+2*NGHZ;
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:    for (k = 0; k < size_z; k++) {
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:      for (j = 0; j < size_y; j++) {
fill_ghostsx.c:#endif	 
fill_ghostsx.c:	for (i = 0; i < size_x; i++) {
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef X
fill_ghostsx.c:#endif	 
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:#endif	 
fill_ghostsx.c:	  //#ifdef ADIABATIC
fill_ghostsx.c:	  energy[lghost1]   = energy[lcopy1];
fill_ghostsx.c:	  energy[lghost2]   = energy[lcopy2];
fill_ghostsx.c:	  //#endif
fill_ghostsx.c:#ifdef MHD
fill_ghostsx.c:#endif
fill_ghostsx.c:#ifdef Y
fill_ghostsx.c:#endif	 
fill_ghostsx.c:#ifdef Z
fill_ghostsx.c:#endif
floor.c://#define __GPU
floor.c://#define __NOPROTO
floor.c:#include "fargo3d.h"
floor.c:  INPUT(Density);
floor.c:  OUTPUT(Density);
floor.c:  real* dens = Density->field_cpu;
floor.c:  int stride = Stride_cpu;
floor.c:  int size_x = Nx+2*NGHX;
floor.c:  int size_y = Ny+2*NGHY;
floor.c:  int size_z = Nz+2*NGHZ;
floor.c:#ifdef Z
floor.c:  for (k=0; k<size_z; k++) {
floor.c:#endif
floor.c:#ifdef Y
floor.c:    for (j=0; j<size_y; j++) {
floor.c:#endif
floor.c:#ifdef X
floor.c:      for (i=0; i<size_x; i++ ) {
floor.c:#endif
floor.c:	if (dens[ll]<1.0e-11)
floor.c:	  dens[ll] = 1.0e-11;
floor.c:#ifdef X
floor.c:#endif
floor.c:#ifdef Y
floor.c:#endif
floor.c:#ifdef Z
floor.c:#endif
fresh.c:#include "fargo3d.h"
fresh.c:void send2cpu() {
fresh.c:#ifdef GPU
fresh.c:  Field* g;
fresh.c:  printf("\nCopying Fields--------------------------------------\n");
fresh.c:  while(g != NULL){
fresh.c:    if(Dev2Host3D(g)){
fresh.c:      printf("Error in send2cpu() with the field %s\n.", g->name);
fresh.c:      exit(-1);
fresh.c:    else {
fresh.c:      printf("Field %s has been copied (Dev2Host)\n", g->name);
fresh.c:    g = g->next;
fresh.c:#endif
fresh.c:void send2gpu() {
fresh.c:#ifdef GPU
fresh.c:  Field* g;
fresh.c:  printf("\nCopying Fields--------------------------------------\n");
fresh.c:  while(g != NULL){
fresh.c:    if(Host2Dev3D(g)){
fresh.c:      printf("Error in send2gpu() with the field %s\n.", g->name);
fresh.c:      exit(-1);
fresh.c:    else {
fresh.c:      printf("Field %s has been copied (Host2Dev)\n", g->name);
fresh.c:    g = g->next;
fresh.c:#endif
fresh.c:void Input2D_CPU(Field2D *field, int line, const char *string){
fresh.c:#ifdef GPU
fresh.c:  if(!field->fresh_cpu) {
fresh.c:    status = Dev2Host2D(field);
fresh.c:    //    printf("Copying %s from Dev to Host\n",field->name);
fresh.c:      printf("Error %d in Dev2Host2D()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(EXIT_FAILURE);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Host.\n",field->name);
fresh.c:  field->fresh_cpu = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Input2D_GPU(Field2D *field, int line, const char *string){
fresh.c:#ifdef GPU
fresh.c:  if(!field->fresh_gpu) {
fresh.c:    status = Host2Dev2D(field);
fresh.c:    //    printf("Copying %s from Dev to Host\n",field->name);
fresh.c:      printf("Error %d in Host2Dev2D()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(EXIT_FAILURE);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Host.\n",field->name);
fresh.c:  field->fresh_gpu = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Input2DInt_CPU(FieldInt2D *field, int line, const char *string){
fresh.c:#ifdef GPU
fresh.c:  if(!field->fresh_cpu) {
fresh.c:    status = Dev2Host2DInt(field);
fresh.c:    //    printf("Copying %s from Dev to Host\n",field->name);
fresh.c:      printf("Error %d in Dev2Host2DInt()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(EXIT_FAILURE);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Host.\n",field->name);
fresh.c:  field->fresh_cpu = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Input2DInt_GPU(FieldInt2D *field, int line, const char *string){
fresh.c:#ifdef GPU
fresh.c:  if(!field->fresh_gpu) {
fresh.c:    status = Host2Dev2DInt(field);
fresh.c:    //    printf("Copying %s from Dev to Host\n",field->name);
fresh.c:      printf("Error %d in Host2Dev2DInt()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(EXIT_FAILURE);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Host.\n",field->name);
fresh.c:  field->fresh_gpu = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Input_CPU(Field *field, int line, const char *string){
fresh.c:  boolean problem = NO, take_action = NO;
fresh.c:  if (*(field->owner) == NULL) {
fresh.c:    printf ("Error ! You pretend to use as an input\n");
fresh.c:    printf ("the field %s, at line %d of file %s.\n", field->name, line, string);
fresh.c:    printf ("However, this storage has been altered and used as a temporary field\n");
fresh.c:    printf ("At line %d in file %s\n", field->line_origin, field->file_origin);
fresh.c:    prs_exit (EXIT_FAILURE);
fresh.c:  if (*(field->owner) != field) {
fresh.c:    printf ("Error ! You pretend to use as input a shared storage (see CreateFieldAlias()) for\n");
fresh.c:    printf ("the field %s, at line %d of file %s.\n", field->name, line, string);
fresh.c:    printf ("However, its storage area is presently used by %s\n", (*(field->owner))->name);
fresh.c:    printf ("Since the line %d of file %s\n", (*(field->owner))->line_origin, (*(field->owner))->file_origin);
fresh.c:    prs_exit (EXIT_FAILURE);
fresh.c:#ifdef GPU
fresh.c:  if (!field->fresh_cpu) take_action = YES;
fresh.c:    if (field->fresh_inside_contour_cpu[i] == NO) take_action = YES;
fresh.c:    if (field->fresh_outside_contour_cpu[i] == NO) take_action = YES;
fresh.c:  if(take_action) {
fresh.c:    if (field->fresh_gpu == NO) problem = YES;
fresh.c:      if (field->fresh_inside_contour_gpu[i] == NO) problem = YES;
fresh.c:      if (field->fresh_outside_contour_gpu[i] == NO) problem = YES;
fresh.c:    if (problem) {
fresh.c:      printf ("Problem on CPU %d: you want to transfer the field %s\n", CPU_Rank, field->name);
fresh.c:      printf ("From device to host in file %s at line %d, but the\n", string, line);
fresh.c:      printf ("field is not fresh everywhere. Here are the values of\n");
fresh.c:      printf ("'fresh' on the mesh, on the inside contour, and outside contour\n");
fresh.c:      INSPECT_INT (field->fresh_gpu);
fresh.c:	INSPECT_INT(field->fresh_inside_contour_gpu[i]);
fresh.c:	INSPECT_INT(field->fresh_outside_contour_gpu[i]);
fresh.c:    status = Dev2Host3D(field);
fresh.c:    //    printf("D==>H: %s\n",field->name);
fresh.c:      printf("Error %d in Dev2Host3D()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(0);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Host.\n",field->name);
fresh.c:  field->fresh_cpu = YES;
fresh.c:    field->fresh_inside_contour_cpu[i] = YES;
fresh.c:    field->fresh_outside_contour_cpu[i] = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Input_GPU(Field *field, int line, const char *string){
fresh.c:  boolean problem=NO, take_action=NO;
fresh.c:  if (*(field->owner) == NULL) {
fresh.c:    printf ("Error ! You pretend to use as an input\n");
fresh.c:    printf ("the field %s, at line %d of file %s.\n", field->name, line, string);
fresh.c:    printf ("However, its storage area has been altered and used as a temporary field\n");
fresh.c:    printf ("At line %d in file %s\n", field->line_origin, field->file_origin);
fresh.c:    prs_exit (EXIT_FAILURE);
fresh.c:  if (*(field->owner) != field) {
fresh.c:    printf ("Error ! You pretend to use as input a shared storage (see CreateFieldAlias()) for\n");
fresh.c:    printf ("the field %s, at line %d of file %s.\n", field->name, line, string);
fresh.c:    printf ("However, its storage area is presently used by %s\n", (*(field->owner))->name);
fresh.c:    printf ("Since the line %d of file %s\n", (*(field->owner))->line_origin, (*(field->owner))->file_origin);
fresh.c:    prs_exit (EXIT_FAILURE);
fresh.c:#ifdef GPU
fresh.c:  if (!field->fresh_gpu) take_action = YES;
fresh.c:    if (field->fresh_inside_contour_gpu[i] == NO) take_action = YES;
fresh.c:    if (field->fresh_outside_contour_gpu[i] == NO) take_action = YES;
fresh.c:  if(take_action) {
fresh.c:    if (field->fresh_cpu == NO) problem = YES;
fresh.c:      if (field->fresh_inside_contour_cpu[i] == NO) problem = YES;
fresh.c:      if (field->fresh_outside_contour_cpu[i] == NO) problem = YES;
fresh.c:    if (problem) {
fresh.c:      printf ("Problem on CPU %d: you want to transfer the field %s\n", CPU_Rank, field->name);
fresh.c:      printf ("From host to device in file %s at line %d, but the\n", string, line);
fresh.c:      printf ("field is not fresh everywhere. Here are the values of\n");
fresh.c:      printf ("'fresh' on the mesh, on the inside contour, and outside contour\n");
fresh.c:      INSPECT_INT (field->fresh_cpu);
fresh.c:	INSPECT_INT(field->fresh_inside_contour_cpu[i]);
fresh.c:	INSPECT_INT(field->fresh_outside_contour_cpu[i]);
fresh.c:    status = Host2Dev3D(field);
fresh.c:    //    printf("H==>D: %s\n",field->name);
fresh.c:      printf("Error %d in Host2Dev3D()! Field: %s\n",status,field->name);
fresh.c:      printf("called from line %d of file %s\n", line, string);
fresh.c:      exit(0);
fresh.c://  else {
fresh.c://    printf("Field %s is up to date on Device.\n",field->name);
fresh.c:  field->fresh_gpu = YES;
fresh.c:    field->fresh_inside_contour_gpu[i] = YES;
fresh.c:    field->fresh_outside_contour_gpu[i] = YES;
fresh.c:#endif
fresh.c:  return;
fresh.c:void Output_CPU(Field *field, int line, const char *string){
fresh.c:  field->line_origin = line;
fresh.c:  strncpy(field->file_origin, string, MAXLINELENGTH-1);
fresh.c:  field->fresh_cpu = YES;
fresh.c:  field->fresh_gpu = NO;
fresh.c:    field->fresh_inside_contour_cpu[i] = YES;
fresh.c:    field->fresh_outside_contour_cpu[i] = YES;
fresh.c:    field->fresh_inside_contour_gpu[i] = NO;
fresh.c:    field->fresh_outside_contour_gpu[i] = NO;
fresh.c:  *(field->owner) = field;
fresh.c:void Output_GPU(Field *field, int line, const char *string){
fresh.c:  field->line_origin = line;
fresh.c:  strncpy(field->file_origin, string, MAXLINELENGTH-1);
fresh.c:  field->fresh_cpu = NO;
fresh.c:  field->fresh_gpu = YES;
fresh.c:    field->fresh_inside_contour_cpu[i] = NO;
fresh.c:    field->fresh_outside_contour_cpu[i] = NO;
fresh.c:    field->fresh_inside_contour_gpu[i] = YES;
fresh.c:    field->fresh_outside_contour_gpu[i] = YES;
fresh.c:  *(field->owner) = field;
fresh.c:void Output2D_CPU(Field2D *field, int line, const char *string){
fresh.c:  field->fresh_cpu = YES;
fresh.c:  field->fresh_gpu = NO;
fresh.c:void Output2D_GPU(Field2D *field, int line, const char *string){
fresh.c:  field->fresh_gpu = YES;
fresh.c:  field->fresh_cpu = NO;
fresh.c:void Output2DInt_CPU(FieldInt2D *field, int line, const char *string){
fresh.c:  field->fresh_cpu = YES;
fresh.c:  field->fresh_gpu = NO;
fresh.c:void Output2DInt_GPU(FieldInt2D *field, int line, const char *string){
fresh.c:  field->fresh_gpu = YES;
fresh.c:  field->fresh_cpu = NO;
fresh.c:void Draft (Field *field, int line, const char *string) {
fresh.c:  *(field->owner) = NULL;
fresh.c:  strncpy (field->file_origin, string, MAXLINELENGTH-1);
fresh.c:  field->line_origin = line;
fresh.c:void WhereIsField(Field *field) {
fresh.c:  if(field->fresh_cpu){
fresh.c:    printf("Field %s is fresh on the CPU %d\n",field->name,id);
fresh.c:  if(field->fresh_gpu)
fresh.c:    printf("Field %s is fresh on the GPU %d\n",field->name,id);
fresh.c:void WhereIsFieldInt2D(FieldInt2D *field) {
fresh.c:  if(field->fresh_cpu){
fresh.c:    printf("Field %s is fresh on the CPU %d\n",field->name,id);
fresh.c:  if(field->fresh_gpu)
fresh.c:    printf("Field %s is fresh on the GPU %d\n",field->name,id);
fresh.c:void WhoOwns (Field *field) {
fresh.c:  printf ("Field %s is currently storing %s\n", field->name, (*(field->owner))->name);
fresh.c:void SynchronizeHD () {
fresh.c:#ifdef GPU
fresh.c:  Field *current;
fresh.c:  current = ListOfGrids;
fresh.c:  while (current != NULL) {
fresh.c:    if (*(current->owner) == current) {
fresh.c:      if ((current->fresh_cpu == YES) && (current->fresh_gpu == NO)) {
fresh.c:	Host2Dev3D (current);
fresh.c:	//      printf ("Sending %s to device\n", current->name);
fresh.c:	current->fresh_gpu = YES;
fresh.c:      if ((current->fresh_cpu == NO) && (current->fresh_gpu == YES)) {
fresh.c:	Dev2Host3D (current);
fresh.c:	//printf ("Sending %s to host\n", current->name);
fresh.c:	current->fresh_cpu = YES;
fresh.c:    current = current->next;
fresh.c:#endif
fresh.c:void WhereIsWho () {
fresh.c:#ifdef GPU
fresh.c:  Field *current;
fresh.c:  current = ListOfGrids;
fresh.c:  while (current != NULL) {
fresh.c:    if (*(current->owner) == current) {
fresh.c:      if ((current->fresh_cpu == YES) && (current->fresh_gpu == YES))
fresh.c:      if ((current->fresh_cpu == NO) && (current->fresh_gpu == YES))
fresh.c:      if ((current->fresh_cpu == YES) && (current->fresh_gpu == NO))
fresh.c:      if ((current->fresh_cpu == NO) && (current->fresh_gpu == NO))
fresh.c:      printf ("%-20s%s\n",current->name, loc);
fresh.c:    current = current->next;
fresh.c:#endif
init_stockholm.c:#include "fargo3d.h"
init_stockholm.c:  INPUT(Density);
init_stockholm.c:  OUTPUT2D(Density0);
init_stockholm.c:#ifdef ADIABATIC
init_stockholm.c:  INPUT(Energy);
init_stockholm.c:  OUTPUT2D(Energy0);
init_stockholm.c:#endif
init_stockholm.c:#ifdef X
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:#endif
init_stockholm.c:  boolean error_density = TRUE;
init_stockholm.c:  boolean error_vx      = TRUE;
init_stockholm.c:  boolean error_vy      = TRUE;
init_stockholm.c:  boolean error_vz      = TRUE;
init_stockholm.c:  boolean error_energy  = TRUE;
init_stockholm.c:  char outputname[MAXLINELENGTH];
init_stockholm.c:  if ((Restart == YES) || (Restart_Full == YES)) {
init_stockholm.c:    sprintf(outputname,"%s0_2d.dat",Density->name);
init_stockholm.c:    error_density = Read2D(Density0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#ifdef X
init_stockholm.c:    sprintf(outputname,"%s0_2d.dat",Vx->name);
init_stockholm.c:    error_vx = Read2D(Vx0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:    sprintf(outputname,"%s0_2d.dat",Vy->name);
init_stockholm.c:    error_vy = Read2D(Vy0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:    sprintf(outputname,"%s0_2d.dat",Vz->name);
init_stockholm.c:    error_vz = Read2D(Vz0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef ADIABATIC
init_stockholm.c:    sprintf(outputname,"%s0_2d.dat",Energy->name);
init_stockholm.c:    error_energy = Read2D(Energy0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef X
init_stockholm.c:  real* vx  = Vx->field_cpu;
init_stockholm.c:  real* vx0 = Vx0->field_cpu;
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:  real* vy  = Vy->field_cpu;
init_stockholm.c:  real* vy0 = Vy0->field_cpu;
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:  real* vz  = Vz->field_cpu;
init_stockholm.c:  real* vz0 = Vz0->field_cpu;
init_stockholm.c:#endif
init_stockholm.c:#ifdef ADIABATIC
init_stockholm.c:  real* e    = Energy->field_cpu;
init_stockholm.c:  real* e0   = Energy0->field_cpu;
init_stockholm.c:#endif
init_stockholm.c:  real* rho  = Density->field_cpu;
init_stockholm.c:  real* rho0 = Density0->field_cpu;
init_stockholm.c:#ifdef Z
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:#endif
init_stockholm.c:#ifdef ADIABATIC
init_stockholm.c:      if (error_energy)
init_stockholm.c:	e0[l2D]   = e[l];
init_stockholm.c:#endif
init_stockholm.c:#ifdef X
init_stockholm.c:      if (error_vx)
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:      if (error_vy)
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:      if (error_vz)
init_stockholm.c:#endif
init_stockholm.c:      if (error_density)
init_stockholm.c:#ifdef Y
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:#endif
init_stockholm.c:  sprintf(outputname,"%s0_2d.dat",Density->name);
init_stockholm.c:  Write2D(Density0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#ifdef X
init_stockholm.c:  sprintf(outputname,"%s0_2d.dat",Vx->name);
init_stockholm.c:  Write2D(Vx0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef Y
init_stockholm.c:  sprintf(outputname,"%s0_2d.dat",Vy->name);
init_stockholm.c:  Write2D(Vy0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef Z
init_stockholm.c:  sprintf(outputname,"%s0_2d.dat",Vz->name);
init_stockholm.c:  Write2D(Vz0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:#ifdef ADIABATIC
init_stockholm.c:  sprintf(outputname,"%s0_2d.dat",Energy->name);
init_stockholm.c:  Write2D(Energy0, outputname, OUTPUTDIR, GHOSTINC);
init_stockholm.c:#endif
init_stockholm.c:  static boolean init = TRUE;
integrate_emf.c://#define __GPU
integrate_emf.c://#define __NOPROTO
integrate_emf.c:#include "fargo3d.h"
integrate_emf.c:/* Orbital advection (FARGO) for MHD */
integrate_emf.c:/* We exclusively evaluate the electric field in the y and z
integrate_emf.c:direction, as there is no electric field along the direction of motion */
integrate_emf.c:void EMF_Upstream_Integrate_cpu (real dt) {
integrate_emf.c:  real* emfx = Emfx->field_cpu;
integrate_emf.c:  real* emfy = Emfy->field_cpu;
integrate_emf.c:  real* emfz = Emfz->field_cpu;
integrate_emf.c:  real* by = By->field_cpu;
integrate_emf.c:  real* bz = Bz->field_cpu;
integrate_emf.c:  real* vxhyr = Vxhyr->field_cpu;
integrate_emf.c:  real* vxhzr = Vxhzr->field_cpu;
integrate_emf.c:  int* nxhy = Nxhy->field_cpu;
integrate_emf.c:  int* nxhz = Nxhz->field_cpu;
integrate_emf.c:  int stride = Stride_cpu;
integrate_emf.c:  int size_x = Nx+2*NGHX;
integrate_emf.c:  int size_y = Ny+2*NGHY;
integrate_emf.c:  int size_z = Nz+2*NGHZ;
integrate_emf.c:// real xmin(Nx+1);
integrate_emf.c:// real ymin(Ny+2*NGHY+1);
integrate_emf.c:// real zmin(Nz+2*NGHZ+1);
integrate_emf.c:  for (k = 1; k < size_z; k++) {
integrate_emf.c:    for (j = 1; j < size_y; j++) {
integrate_emf.c:      for (i = 0; i < size_x; i++) {
integrate_emf.c:	emfx[ll] = 0.0;
integrate_emf.c:	emfz[ll] *= -vxhyr[ll2D]*dt;
integrate_emf.c:	emfy[ll] *= vxhzr[ll2D]*dt;
integrate_emf.c:	    emfz[ll] += -by[l_plus_m]*edge_size_x_middlez_lowy(i,j,k);
integrate_emf.c:	} else {
integrate_emf.c:	    emfz[ll] += by[l_plus_m]*edge_size_x_middlez_lowy(i,j,k);
integrate_emf.c:	    emfy[ll] += bz[l_plus_m]*edge_size_x_middley_lowz(i,j,k);
integrate_emf.c:	} else {
integrate_emf.c:	    emfy[ll] += -bz[l_plus_m]*edge_size_x_middley_lowz(i,j,k);
light_global_dev.c:#include "fargo3d.h"
light_global_dev.c:void LightGlobalDev(){
light_global_dev.c:#ifdef GPU
light_global_dev.c:  DevMemcpyH2D(Xmin_d,Xmin,sizeof(real)*(Nx+2*NGHX+1));
light_global_dev.c:  DevMemcpyH2D(Ymin_d,Ymin,sizeof(real)*(Ny+2*NGHY+1));
light_global_dev.c:  DevMemcpyH2D(Zmin_d,Zmin,sizeof(real)*(Nz+2*NGHZ+1));
light_global_dev.c:  DevMemcpyH2D(Sxi_d,Sxi,sizeof(real)*(Nx+2*NGHX));
light_global_dev.c:  DevMemcpyH2D(Sxj_d,Sxj,sizeof(real)*(Ny+2*NGHY));
light_global_dev.c:  DevMemcpyH2D(Syj_d,Syj,sizeof(real)*(Ny+2*NGHY));
light_global_dev.c:  DevMemcpyH2D(Szj_d,Szj,sizeof(real)*(Ny+2*NGHY));
light_global_dev.c:  DevMemcpyH2D(Sxk_d,Sxk,sizeof(real)*(Nz+2*NGHZ));
light_global_dev.c:  DevMemcpyH2D(Syk_d,Syk,sizeof(real)*(Nz+2*NGHZ));
light_global_dev.c:  DevMemcpyH2D(Szk_d,Szk,sizeof(real)*(Nz+2*NGHZ));
light_global_dev.c:  DevMemcpyH2D(InvVj_d,InvVj,sizeof(real)*(Ny+2*NGHY));
light_global_dev.c:  DevMemcpyH2D(InvDiffXmed_d,InvDiffXmed,sizeof(real)*(Nx+2*NGHX));
light_global_dev.c:#endif
lorentz_force.c://#define __GPU
lorentz_force.c://#define __NOPROTO
lorentz_force.c:#include "fargo3d.h"
lorentz_force.c:void LorentzForce(real dt, Field *Bs1, Field *Bs2, int idx, int idy, int idz) {
lorentz_force.c:  //Be careful with the order of bs1 and bs2!!
lorentz_force.c:  int stride1;
lorentz_force.c:  int stride2;
lorentz_force.c:  Field* B1;
lorentz_force.c:  Field* B2;
lorentz_force.c:  Field* V;
lorentz_force.c:    stride1 = (Nx+2*NGHX);
lorentz_force.c:    stride2 = (Nx+2*NGHX)*(Ny+2*NGHY); 
lorentz_force.c:#ifdef GPU
lorentz_force.c:    if ( _LorentzForce ==  _LorentzForce_gpu) {
lorentz_force.c:      stride1 = Pitch_gpu;
lorentz_force.c:      stride2 = Stride_gpu;
lorentz_force.c:#endif
lorentz_force.c:    stride1 = (Nx+2*NGHX)*(Ny+2*NGHY);
lorentz_force.c:    stride2 = 1;    
lorentz_force.c:#ifdef GPU
lorentz_force.c:    if ( _LorentzForce ==  _LorentzForce_gpu) {
lorentz_force.c:      stride1 = Stride_gpu;
lorentz_force.c:      stride2 = 1;
lorentz_force.c:#endif
lorentz_force.c:    stride1 = 1;
lorentz_force.c:    stride2 = Nx+2*NGHX;
lorentz_force.c:#ifdef GPU
lorentz_force.c:    if ( _LorentzForce ==  _LorentzForce_gpu) {
lorentz_force.c:      stride1 = 1;
lorentz_force.c:      stride2 = Pitch_gpu;
lorentz_force.c:#endif
lorentz_force.c:  FARGO_SAFE (_LorentzForce(dt, idx, idy, idz, idx1, idy1, idz1, idx2, idy2, idz2, stride1, stride2, B1, B2,V,Bs1,Bs2));
lorentz_force.c:void _LorentzForce_cpu(real dt, int idx, int idy, int idz, int idx1, int idy1, int idz1, int idx2, int idy2, int idz2, int stride1, int stride2, Field* B1, Field* B2,Field*V, Field *Bs1,Field *Bs2) {
lorentz_force.c:  INPUT (Density);
lorentz_force.c:  real* b1 = B1->field_cpu;
lorentz_force.c:  real* b2 = B2->field_cpu;
lorentz_force.c:  real* rho = Density->field_cpu;
lorentz_force.c:  real* v = V->field_cpu;
lorentz_force.c:  real* bs1 = Bs1->field_cpu;
lorentz_force.c:  real* bs2 = Bs2->field_cpu;
lorentz_force.c:  int stride = Stride_cpu;
lorentz_force.c:  int size_x = XIP;
lorentz_force.c:  int size_y = Ny+2*NGHY-1;
lorentz_force.c:  int size_z = Nz+2*NGHZ-1;
lorentz_force.c:  real nx = Nx;
lorentz_force.c:  int lmperp1plus;
lorentz_force.c:  int lmperp2plus;
lorentz_force.c:  real b1_mean;
lorentz_force.c:  real b2_mean;
lorentz_force.c:  real b1_mean1;
lorentz_force.c:  real b2_mean1;
lorentz_force.c:  real b1_mean2;
lorentz_force.c:  real b2_mean2;
lorentz_force.c:  real delta1;
lorentz_force.c:  real delta2;
lorentz_force.c:  real d1bs1;
lorentz_force.c:  real d2bs2;
lorentz_force.c:// real xmin(Nx+1);
lorentz_force.c:// real ymin(Ny+2*NGHY+1);
lorentz_force.c:// real zmin(Nz+2*NGHZ+1);
lorentz_force.c:// real Sxj(Ny+2*NGHY);
lorentz_force.c:// real Syj(Ny+2*NGHY);
lorentz_force.c:// real Szj(Ny+2*NGHY);
lorentz_force.c:// real Sxk(Nz+2*NGHZ);
lorentz_force.c:// real Syk(Nz+2*NGHZ);
lorentz_force.c:// real Szk(Nz+2*NGHZ);
lorentz_force.c:  for (k=1; k<size_z; k++) {
lorentz_force.c:    for (j=1; j<size_y; j++) {
lorentz_force.c:      for (i=XIM; i<size_x; i++) {
lorentz_force.c:	lmperp1plus = lm+stride1;
lorentz_force.c:	lmperp2plus = lm+stride2;
lorentz_force.c:	delta1 = (zone_size_x(i,j,k)*idx1	+ \
lorentz_force.c:		  zone_size_y(j,k)*idy1 + \
lorentz_force.c:		  zone_size_z(j,k)*idz1);
lorentz_force.c:	delta2 = (zone_size_x(i,j,k)*idx2 + \
lorentz_force.c:		  zone_size_y(j,k)*idy2 + \
lorentz_force.c:		  zone_size_z(j,k)*idz2);
lorentz_force.c:	/* The test below MUST be "if (idz == 1)" and NOT "if (stride1
lorentz_force.c:	   == 1)". What is intended is to flush the index to the mesh
lorentz_force.c:	   in X **if the direction 1 is X**. Now we could have stride1
lorentz_force.c:	   being 1 and yet the direction 1 not being X (if Nx =
lorentz_force.c:#ifndef GHOSTSX
lorentz_force.c:	    lmperp1plus -= nx;
lorentz_force.c:	/* Similar considerations apply below */
lorentz_force.c:	    lmperp2plus -= nx;
lorentz_force.c:#endif
lorentz_force.c:	b1_mean1 = 0.5*(b1[lp1]+b1[lmperp1plus]);
lorentz_force.c:	b1_mean2 = 0.5*(b1[ll]+b1[lm]);
lorentz_force.c:	b1_mean  = 0.5*(b1_mean1+b1_mean2);
lorentz_force.c:	b2_mean1 = 0.5*(b2[lp2]+b2[lmperp2plus]);
lorentz_force.c:	b2_mean2 = 0.5*(b2[ll]+b2[lm]);
lorentz_force.c:	b2_mean  = 0.5*(b2_mean1+b2_mean2);
lorentz_force.c:	d1bs1 = (bs1[lp1]-bs1[ll])/delta1;
lorentz_force.c:	d2bs2 = (bs2[lp2]-bs2[ll])/delta2;
lorentz_force.c:	v[ll] += 2.0*dt/(rho[ll]+rho[lm])*(b1_mean*d1bs1 + b2_mean*d2bs2)/MU0;
main.c:/** \file main.c
main.c:Main file of the distribution. 
main.c:Manages the call to initialization
main.c:functions, then the main loop.
main.c:#include "fargo3d.h"
main.c:int   begin_i = 0, NbRestart = 0;
main.c:int   InnerOutputCounter=0, StillWriteOneOutput;
main.c:real dt;
main.c:real dtemp = 0.0;
main.c:  int   i=0, OutputNumber = 0, d;
main.c:  char  sepline[]="===========================";
main.c:  sprintf (CommandLine, "%s ", argv[0]);
main.c:  while (++i < argc) {
main.c:    strncat (CommandLine, argv[i], 1023);
main.c:    strncat (CommandLine, " ", 1023);
main.c:#ifdef LONGSUMMARY
main.c:  strncpy (StickyOptions, ExtractFromExecutable (YES, "", 1), 1023);
main.c:  strncpy (BoundaryFile, ExtractFromExecutable (YES, "", 3), 4095);
main.c:#endif
main.c:  strcpy (ParameterFile, "");
main.c:	  != strlen (argv[i]))
main.c:	PrintUsage (argv[0]);
main.c:	EarlyOutputRename = YES;
main.c:	  masterprint ("Incorrect Array number after +# flag\n");
main.c:	  PrintUsage (argv[0]);
main.c:	strcpy (DeviceFile, argv[i+1]);
main.c:	DeviceFileSpecified = YES;
main.c:	StretchNumber = atoi(argv[i+1]);
main.c:	StretchOldOutput = YES;
main.c:	  != strlen (argv[i]))
main.c:	PrintUsage (argv[0]);
main.c:	TimeInfo = YES;
main.c:	ForwardOneStep = YES;
main.c:	EverythingOnCPU = YES;
main.c:#ifdef GPU
main.c:	mastererr ("WARNING: Forcing execution of all functions on CPU\n");
main.c:#else
main.c:	mastererr ("WARNING: Flag -C meaningless for a CPU built\n");
main.c:#endif
main.c:	Merge = YES;
main.c:	Merge = NO;
main.c:	RedefineOptions = YES;
main.c:	ParseRedefinedOptions (argv[i+1]) ;
main.c:	Restart = YES;
main.c:	NbRestart = atoi(argv[i+1]);
main.c:	if ((NbRestart < 0)) {
main.c:	  masterprint ("Incorrect restart number\n");
main.c:	  PrintUsage (argv[0]);
main.c:	  masterprint ("Incorrect Array number after -# flag\n");
main.c:	  PrintUsage (argv[0]);
main.c:	PostRestart = YES;
main.c:	Restart_Full = YES;
main.c:	NbRestart = atoi(argv[i+1]);
main.c:	if ((NbRestart < 0)) {
main.c:	  masterprint ("Incorrect restart number\n");
main.c:	  PrintUsage (argv[0]);
main.c:	Restart_Full = YES;
main.c:	NbRestart = atoi(argv[i+1]);
main.c:	if ((NbRestart < 0)) {
main.c:	  masterprint ("Incorrect output number\n");
main.c:	  PrintUsage (argv[0]);	  
main.c:	Restart_Full = YES;
main.c:	NbRestart = atoi(argv[i+1]);
main.c:	if ((NbRestart < 0)) {
main.c:	  masterprint ("Incorrect output number\n");
main.c:	  PrintUsage (argv[0]);	  
main.c:	DeviceManualSelection = atoi(argv[i+1]);
main.c:    else strcpy (ParameterFile, argv[i]);
main.c:#ifdef WRITEGHOSTS
main.c:  if (Merge == YES) {
main.c:	mastererr ("Cannot merge outputs when dumping ghost values.\n");
main.c:	mastererr ("'make nofulldebug' could fix this problem.\n");
main.c:	mastererr ("Using the -k flag could be another solution.\n");
main.c:	prs_exit (1);
main.c:#endif
main.c:#ifdef MPICUDA
main.c:  EarlyDeviceSelection();
main.c:#endif
main.c:  MPI_Comm_size (MPI_COMM_WORLD, &CPU_Number);
main.c:  CPU_Master = (CPU_Rank == 0 ? 1 : 0);
main.c:  if (strlen(xstr(VERSION)) < 2)
main.c:    sprintf (VersionString, "FARGO3D Public version 1.3");
main.c:  else
main.c:    sprintf (VersionString, "FARGO3D git version %s", xstr(VERSION));
main.c:  masterprint("\n\n%s\n%s\nSETUP: '%s'\n%s\n\n",
main.c:	      sepline, VersionString, xstr(SETUPNAME), sepline);
main.c:  if ((ParameterFile[0] == 0) || (argc == 1)) PrintUsage (argv[0]);
main.c:#ifndef MPICUDA
main.c:  SelectDevice(CPU_Rank);
main.c:#endif
main.c:  InitVariables ();
main.c:  MPI_Barrier(MPI_COMM_WORLD);
main.c:  ReadDefaultOut ();
main.c:  ReadVarFile (ParameterFile);
main.c:    ThereArePlanets = YES;
main.c:  if (ORBITALRADIUS > 1.0e-30){
main.c:  SubsDef (OUTPUTDIR, DefaultOut);
main.c:  /* This must be placed ***BEFORE*** reading the input files in case of a restart */
main.c:  if ((ArrayNb) && (EarlyOutputRename == YES)) {
main.c:    i = strlen(OUTPUTDIR);
main.c:    if (OUTPUTDIR[i-1] == '/') OUTPUTDIR[i-1] = 0;//Remove trailing slash if any
main.c:    sprintf (OUTPUTDIR, "%s%06d/", OUTPUTDIR, ArrayNb); //Append numerical suffix
main.c:    /* There is no need to perform the wildcard (@) substitution. This has already been done */
main.c:    printf ("\n\n***\n\nNew Output Directory is %s\n\n***\n\n", OUTPUTDIR);
main.c:    MakeDir(OUTPUTDIR); /*Create the output directory*/
main.c:  MakeDir(OUTPUTDIR); /*Create the output directory*/
main.c:#if !defined(X)
main.c:#endif
main.c:#if !defined(Y)
main.c:#endif
main.c:#if !defined(Z)
main.c:#endif
main.c:  SelectWriteMethod();
main.c:#if !defined(Y) && !defined(Z)
main.c:    prs_error ("You cannot split a 1D mesh in x. Sequential runs only!");
main.c:  if (CPU_Number > 1) {
main.c:    MPI_Finalize();
main.c:    prs_exit(EXIT_FAILURE);
main.c:#endif
main.c:  ListVariables ("variables.par"); //Writes all variables defined in set up
main.c:  ListVariablesIDL ("IDL.var");
main.c:  ChangeArch(); /*Changes the name of the main functions
main.c:		  ChangeArch adds _cpu or _gpu if GPU is activated.*/
main.c:  split(&Gridd); /*Split mesh over PEs*/
main.c:  InitSpace();
main.c:  WriteDim();
main.c:  InitSurfaces();
main.c:  LightGlobalDev(); /* Copy light arrays to the device global memory */
main.c:  CreateFields(); // Allocate all fields.
main.c:  Sys = InitPlanetarySystem(PLANETCONFIG);
main.c:  ListPlanets();
main.c:    OMEGAFRAME = GetPsysInfo(FREQUENCY);
main.c:  /* We need to keep track of initial azimuthal velocity to correct
main.c:the target velocity in Stockholm's damping prescription. We copy the
main.c:value above *after* rescaling, and after any initial correction to
main.c:OMEGAFRAME (which is used afterwards to build the initial Vx field. */
main.c:  if(Restart == YES || Restart_Full == YES) {
main.c:    CondInit (); //Needed even for restarts: some setups have custom
main.c:		 //definitions (eg potential for setup MRI) or custom
main.c:		 //scaling laws (eg. setup planetesimalsRT).
main.c:    MULTIFLUID( begin_i  = RestartSimulation(NbRestart));
main.c:    if (ThereArePlanets) {
main.c:      PhysicalTime  = GetfromPlanetFile (NbRestart, 9, 0);
main.c:      OMEGAFRAME  = GetfromPlanetFile (NbRestart, 10, 0);
main.c:      RestartPlanetarySystem (NbRestart, Sys);
main.c:  else {
main.c:    if (ThereArePlanets)
main.c:      EmptyPlanetSystemFiles ();
main.c:    CondInit(); // Initialize set up
main.c:    // Note: CondInit () must be called only ONCE (otherwise some
main.c:    // custom scaling laws may be applied several times).
main.c:  if (StretchOldOutput == YES) {
main.c:    StretchOutput (StretchNumber);
main.c:  MULTIFLUID(comm(ENERGY)); //Very important for isothermal cases!
main.c:  /* This must be placed ***after*** reading the input files in case of a restart */
main.c:  if ((ArrayNb) && (EarlyOutputRename == NO)) {
main.c:    i = strlen(OUTPUTDIR);
main.c:    if (OUTPUTDIR[i-1] == '/') OUTPUTDIR[i-1] = 0;//Remove trailing slash if any
main.c:    sprintf (OUTPUTDIR, "%s%06d/", OUTPUTDIR, ArrayNb); //Append numerical suffix
main.c:    /* There is no need to perform the wildcard (@) substitution. This has already been done */
main.c:    printf ("\n\n***\n\nNew Output Directory is %s\n\n***\n\n", OUTPUTDIR);
main.c:    MakeDir(OUTPUTDIR); /*Create the output directory*/
main.c:    ListVariables ("variables.par"); //Writes all variables defined in set up
main.c:    ListVariablesIDL ("IDL.var");
main.c:    InitSpace();
main.c:    WriteDim ();
main.c:#if !defined(STANDARD) && !defined(RAM)
main.c:  mastererr ("Warning: Mesh must be unifrom in x-direction to use FARGO advection.\n");
main.c:  mastererr ("Warning: If SPACING is set to 'N', use -DSTANDARD or -DRAM in .opt file.\n");
main.c:  prs_exit (1);
main.c:#endif
main.c:#if defined(MHD) && defined(RAM)
main.c:  mastererr ("Warning: Current version of MHD module does not include RAM.\n");
main.c:  mastererr ("Warning: If SPACING is set to 'N', use -DSTANDARD in .opt file.\n");
main.c:  prs_exit (1);
main.c:#endif
main.c:  GetHostsList ();
main.c:  SelectArchFileName ();
main.c:#ifdef LONGSUMMARY
main.c:  ExtractFromExecutable (NO, ArchFile, 2);
main.c:#endif
main.c:  MULTIFLUID(FillGhosts(PrimitiveVariables()));
main.c:#ifdef STOCKHOLM 
main.c:#endif
main.c:#ifdef GHOSTSX
main.c:  masterprint ("\n\nNew version with ghost zones in X activated\n");
main.c:#else
main.c:  masterprint ("Standard version with no ghost zones in X\n");
main.c:#endif
main.c:  for (i = begin_i; i<=NTOT; i++) { // MAIN LOOP
main.c:    if (NINTERM * (TimeStep = (i / NINTERM)) == i) {
main.c:#if defined(MHD) && defined(DEBUG)
main.c:      FARGO_SAFE(ComputeDivergence(Bx, By, Bz));
main.c:#endif
main.c:      if (ThereArePlanets)
main.c:	WritePlanetSystemFile(TimeStep, NO);
main.c:#ifndef NOOUTPUTS
main.c:      MULTIFLUID(WriteOutputs(ALL));
main.c:#ifdef MATPLOTLIB
main.c:#endif
main.c:      if(CPU_Master) printf("OUTPUTS %d at date t = %f OK\n", TimeStep, PhysicalTime);
main.c:#endif
main.c:      if (TimeInfo == YES) GiveTimeInfo (TimeStep);
main.c:      if (NSNAP * (TimeStep = (i / NSNAP)) == i) {
main.c:	MULTIFLUID(WriteOutputs(SPECIFIC));
main.c:#ifdef MATPLOTLIB
main.c:#endif
main.c:      break;
main.c:    dtemp = 0.0;
main.c:    while (dtemp<DT) { // DT LOOP
main.c:#ifdef X
main.c:#ifndef STANDARD
main.c:      MULTIFLUID(ComputeVmed(Vx)); // FARGO algorithm -- very important to have it here!
main.c:#endif
main.c:#endif
main.c:      /// NOW THE 2D MESH VxMed CONTAINS THE AZIMUTHAL AVERAGE OF Vx in X
main.c:#ifdef FLOOR
main.c:#endif
main.c:#ifdef MHD
main.c:#ifdef OHMICDIFFUSION
main.c:      FARGO_SAFE(OhmicDiffusion_coeff());
main.c:#endif
main.c:#ifdef AMBIPOLARDIFFUSION
main.c:      FARGO_SAFE(AmbipolarDiffusion_coeff());
main.c:#endif
main.c:#ifdef HALLEFFECT
main.c:      FARGO_SAFE(HallEffect_coeff());
main.c:#endif
main.c:#endif
main.c:      // CFL condition is applied below ----------------------------------------
main.c:      CflFluidsMin(); /*Fills StepTime with the " global min " of the
main.c:			cfl, computed from each fluid.*/
main.c:      dt = StepTime; //cfl works with the 'StepTime' global variable.
main.c:      dtemp+=dt;
main.c:      if(dtemp>DT)  dt = DT - (dtemp-dt); //updating dt
main.c:      /* We now compute the total density of the mesh. We need first
main.c:	 reset an array and then fill it by adding the density of each
main.c:      FARGO_SAFE(Reset_field(Total_Density)); 
main.c:      MULTIFLUID(ComputeTotalDensity()); 
main.c:#ifdef COLLISIONPREDICTOR
main.c:      FARGO_SAFE(Collisions(0.5*dt, 0)); // 0 --> V is used and we update v_half.
main.c:#endif
main.c:      MULTIFLUID(Sources(dt)); //v_half is used in the R.H.S
main.c:#ifdef DRAGFORCE
main.c:      FARGO_SAFE(Collisions(dt, 1)); // 1 --> V_temp is used.
main.c:#endif
main.c:#ifdef DUSTDIFFUSION
main.c:#endif
main.c:      PhysicalTime+=dt;
main.c:      Timestepcount++;
main.c:#ifdef STOCKHOLM
main.c:#endif
main.c:      //We apply comms and boundaries at the end of the step
main.c:      MULTIFLUID(FillGhosts(PrimitiveVariables()));
main.c:      if(CPU_Master) {
main.c:	else {
main.c:	  else
main.c:#ifndef NOFLUSH
main.c:#endif
main.c:    if(CPU_Master) printf("%s", "\n");
main.c:    if (ThereArePlanets) {
main.c:      WritePlanetSystemFile(TimeStep, YES);
main.c:      SolveOrbits (Sys);
main.c:  MPI_Finalize();
main.c:  masterprint("End of the simulation!\n");
main.c:  return 0;  
matplotlib.c:#include <Python.h>
matplotlib.c:#include "fargo3d.h"
matplotlib.c:#define YZSIM 1
matplotlib.c:#define XZSIM 2
matplotlib.c:#define XYSIM 3
matplotlib.c:  va_end(list);
matplotlib.c:  PyRun_SimpleString(string);
matplotlib.c:void finalize_python() {
matplotlib.c:int check_simtype() {
matplotlib.c:    return XYSIM;
matplotlib.c:    return XZSIM;
matplotlib.c:    return YZSIM;
matplotlib.c:  printf("Fatal error in matplotlib.c. Check the function check_simtype()\n");
matplotlib.c:    return -1;
matplotlib.c:void initialize_python() {
matplotlib.c:  Py_InitializeEx(1);
matplotlib.c:  //Bug with python event handler!!!! http://www.vtk.org/Bug/view.php?id=13788
matplotlib.c:  pyrun("matplotlib.use('TKAgg')");
matplotlib.c:  pyrun("mpl.rcParams['toolbar'] = 'None'");
matplotlib.c:  pyrun("fig = plt.figure('FARGO3D - %02d')", CPU_Rank);
matplotlib.c:void plot1d(char* name, int n, int merge) {
matplotlib.c:  real x1, x2, y1, y2;
matplotlib.c:  if (merge) {
matplotlib.c:  else {
matplotlib.c:    initialize_python();
matplotlib.c:  if (merge){
matplotlib.c:#ifndef FLOAT
matplotlib.c:    pyrun("field = np.fromfile('%s%s%d.dat')",OUTPUTDIR, name, n);
matplotlib.c:#else
matplotlib.c:    pyrun("field = np.fromfile('%s%s%d.dat',dtype='f32')",OUTPUTDIR, name, n);
matplotlib.c:#endif
matplotlib.c:  else {
matplotlib.c:    pyrun("field = np.fromfile('%s%s%d_%d.dat')",OUTPUTDIR, name, n, CPU_Rank);
matplotlib.c:    pyrun("field = np.log10(field)");
matplotlib.c:    pyrun("ax.set_title('Field: %s',color='w')",name);  
matplotlib.c:    pyrun("ax.set_ylabel('%s')",name);
matplotlib.c:#ifdef X
matplotlib.c:    pyrun("ax.set_xlabel('X')");
matplotlib.c:#endif
matplotlib.c:#ifdef Y
matplotlib.c:    pyrun("ax.set_xlabel('Y')");
matplotlib.c:#endif
matplotlib.c:#ifdef Z
matplotlib.c:    pyrun("ax.set_xlabel('Z')");
matplotlib.c:#endif
matplotlib.c:#ifdef FLOAT
matplotlib.c:    pyrun("domain = np.linspace(%f,%f,%d)",x1,x2,dim);
matplotlib.c:#else
matplotlib.c:    pyrun("domain = np.linspace(%lf,%lf,%d)",x1,x2,dim);
matplotlib.c:#endif
matplotlib.c:    pyrun("time = ax.text(0.98, 0.97,'Time: %3.5f',"
matplotlib.c:	  "horizontalalignment='right',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", PhysicalTime);
matplotlib.c:    pyrun("output = ax.text(0.02, 0.97,'Output: %03d',"
matplotlib.c:	  "horizontalalignment='left',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", n);
matplotlib.c:    pyrun("plot = plt.plot(domain,field,'w-',linewidth=2)");
matplotlib.c:      pyrun("ax.relim()");
matplotlib.c:    else {
matplotlib.c:#ifdef FLOAT
matplotlib.c:      pyrun("ax.set_ylim([%f,%f])",VMIN,VMAX);
matplotlib.c:#else
matplotlib.c:      pyrun("ax.set_ylim([%lf,%lf])",VMIN,VMAX);
matplotlib.c:#endif
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:  else {
matplotlib.c:    pyrun("time.set_text('Time: %3.5f')", PhysicalTime);
matplotlib.c:    pyrun("output.set_text('Output: %03d')", n);
matplotlib.c:    pyrun("plot[0].set_data(domain,field)");
matplotlib.c:      pyrun("ax.relim()");
matplotlib.c:    else {
matplotlib.c:#ifdef FLOAT
matplotlib.c:      pyrun("ax.set_ylim([%f,%f])",VMIN,VMAX);
matplotlib.c:#else
matplotlib.c:      pyrun("ax.set_ylim([%lf,%lf])",VMIN,VMAX);
matplotlib.c:#endif
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:void plot2d(char* name, int n, int merge) {
matplotlib.c:  real x1, x2, y1, y2;
matplotlib.c:  if (merge) {
matplotlib.c:  else {
matplotlib.c:    initialize_python();
matplotlib.c:#ifdef FLOAT
matplotlib.c:  pyrun("dtype = np.float32");
matplotlib.c:#else
matplotlib.c:  pyrun("dtype = np.float64");
matplotlib.c:#endif
matplotlib.c:  if (merge) {
matplotlib.c:      pyrun("f = open('%s%s%d.vtk')",OUTPUTDIR, name, n);
matplotlib.c:    else {
matplotlib.c:      pyrun("f = open('%s%s%d.dat')",OUTPUTDIR, name, n);
matplotlib.c:  else {
matplotlib.c:      pyrun("f = open('%s%s%d_%d.vtk')",OUTPUTDIR, name, n,CPU_Rank);
matplotlib.c:    else
matplotlib.c:      pyrun("f = open('%s%s%d_%d.dat')",OUTPUTDIR, name, n,CPU_Rank);
matplotlib.c:    pyrun("f.seek(%d,0)",VtkPosition);
matplotlib.c:      pyrun("field = np.fromfile(f,dtype=dtype).newbyteorder().reshape([%d,%d])", n2,n1);
matplotlib.c:    else {
matplotlib.c:      pyrun("field = np.swapaxes(np.fromfile(f,dtype=dtype).newbyteorder().reshape([%d,%d]),0,1)", n1, n2);
matplotlib.c:  else
matplotlib.c:    pyrun("field = np.fromfile(f,dtype=dtype).reshape([%d,%d])",n2, n1);
matplotlib.c:  pyrun("f.close()");
matplotlib.c:    pyrun("field = np.log10(field)");
matplotlib.c:    pyrun("ax.set_title('Field: %s',color='w')",name);
matplotlib.c:    int simtype = check_simtype();
matplotlib.c:    if (simtype == YZSIM) {
matplotlib.c:      pyrun("ax.set_xlabel('Y')");
matplotlib.c:      pyrun("ax.set_ylabel('Z')");
matplotlib.c:    if (simtype == XZSIM) {
matplotlib.c:      pyrun("ax.set_xlabel('X')");
matplotlib.c:      pyrun("ax.set_ylabel('Z')");
matplotlib.c:    if (simtype == XYSIM) {
matplotlib.c:      pyrun("ax.set_xlabel('X')");
matplotlib.c:      pyrun("ax.set_ylabel('Y')");
matplotlib.c:    pyrun("time = ax.text(0.98, 0.97,'Time: %3.5f',"
matplotlib.c:	  "horizontalalignment='right',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", PhysicalTime);
matplotlib.c:    pyrun("output = ax.text(0.02, 0.97,'Output: %03d',"
matplotlib.c:	  "horizontalalignment='left',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", n);
matplotlib.c:    pyrun("image = plt.imshow(field,"
matplotlib.c:	  "extent = [%lf,%lf,%lf,%lf],"
matplotlib.c:	  "aspect = '%s', origin='lower')",
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:  else {
matplotlib.c:    pyrun("time.set_text('Time: %3.5f')", PhysicalTime);
matplotlib.c:    pyrun("output.set_text('Output: %03d')", n);
matplotlib.c:    pyrun("image.set_data(field)");
matplotlib.c:      pyrun("image.autoscale()");
matplotlib.c:    else {
matplotlib.c:      pyrun("image.set_clim(%lf,%lf)",VMIN,VMAX);
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:void plot3d(char* name, int n, int merge) {
matplotlib.c:  static boolean init = YES;  
matplotlib.c:    initialize_python();
matplotlib.c:    pyrun("ax.set_title('Field: %s',color='w')",name);
matplotlib.c:  if (merge) {
matplotlib.c:  else {
matplotlib.c:#ifdef FLOAT
matplotlib.c:  pyrun("dtype = np.float32");
matplotlib.c:#else
matplotlib.c:  pyrun("dtype = np.float64");
matplotlib.c:#endif
matplotlib.c:  if (merge) {
matplotlib.c:      pyrun("f = open('%s%s%d.vtk')",OUTPUTDIR, name, n);
matplotlib.c:    else
matplotlib.c:      pyrun("f = open('%s%s%d.dat')",OUTPUTDIR, name, n);
matplotlib.c:  else {
matplotlib.c:      pyrun("f = open('%s%s%d_%d.vtk')",OUTPUTDIR, name, n,CPU_Rank);
matplotlib.c:    else
matplotlib.c:      pyrun("f = open('%s%s%d_%d.dat')",OUTPUTDIR, name, n,CPU_Rank);
matplotlib.c:    pyrun("f.seek(%d,0)",VtkPosition);
matplotlib.c:    pyrun("field = np.fromfile(f,dtype=dtype).newbyteorder().reshape([%d,%d,%d])", n3,n2,n1);
matplotlib.c:  else
matplotlib.c:    pyrun("field = np.fromfile(f,dtype=dtype).reshape([%d,%d,%d])", n3, n2, n1);
matplotlib.c:  pyrun("f.close()");
matplotlib.c:    pyrun("field = np.log10(field)");
matplotlib.c:    pyrun("time = ax.text(0.98, 0.97,'Time: %3.5f',"
matplotlib.c:	  "horizontalalignment='right',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", PhysicalTime);
matplotlib.c:    pyrun("output = ax.text(0.02, 0.97,'Output: %03d',"
matplotlib.c:	  "horizontalalignment='left',"
matplotlib.c:	  "verticalalignment='center',"
matplotlib.c:	  "transform = ax.transAxes, color='w')", n);
matplotlib.c:    pyrun("image = plt.imshow(%s,"
matplotlib.c:	  "aspect = '%s')",
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:  else {
matplotlib.c:    pyrun("time.set_text('Time: %3.5f')", PhysicalTime);
matplotlib.c:    pyrun("output.set_text('Output: %03d')", n);
matplotlib.c:    pyrun("image.set_data(%s)",PLOTLINE);
matplotlib.c:      pyrun("image.autoscale()");
matplotlib.c:    else {
matplotlib.c:      pyrun("image.set_clim(%lf,%lf)",VMIN,VMAX);
matplotlib.c:    pyrun("fig.canvas.flush_events()");
matplotlib.c:#if ((defined(X) && defined(Y) && !defined(Z)) || \
matplotlib.c:     (defined(X) && defined(Z) && !defined(Y)) || \
matplotlib.c:     (defined(Y) && defined(Z) && !defined(X)))
matplotlib.c:  if (Merge) {
matplotlib.c:    if (CPU_Master) {
matplotlib.c:      plot2d(FIELD, TimeStep, Merge);
matplotlib.c:  else {
matplotlib.c:    plot2d(FIELD, TimeStep, Merge);
matplotlib.c:#endif
matplotlib.c:#if (defined(X) && defined(Y) && defined(Z))
matplotlib.c:  if (Merge) {
matplotlib.c:    if (CPU_Master) {
matplotlib.c:      plot3d(FIELD, TimeStep, Merge);
matplotlib.c:  else {
matplotlib.c:    plot3d(FIELD, TimeStep, Merge);
matplotlib.c:#endif
matplotlib.c:#if ((defined(X) & !(defined(Y) || defined(Z))) ||  \
matplotlib.c:     (defined(Y) & !(defined(X) || defined(Z)))  || \
matplotlib.c:     (defined(Z) & !(defined(X) || defined(Y))))
matplotlib.c:  plot1d(FIELD, TimeStep, Merge);
matplotlib.c:#endif
mesh.c:#include <stdlib.h>
mesh.c:#include <stdio.h>
mesh.c:#include <math.h>
mesh.c:#include "fargo3d.h"
mesh.c:real x_mesh_I;
mesh.c:real y_mesh_I;
mesh.c:real fx(real x) {
mesh.c:  return x/x_mesh_I;
mesh.c:real gx_p(real x) {
mesh.c:  return 0.5*(2.0+XMC)*x/x_mesh_I - XMC*(XMB-XMA)/(2.0*M_PI*x_mesh_I)*sin(M_PI*(XMA+x)/(XMA-XMB));
mesh.c:real gx_m(real x) {
mesh.c:  return 0.5*(2.0+XMC)*x/x_mesh_I - XMC*(XMB-XMA)/(2.0*M_PI*x_mesh_I)*sin(M_PI*(x-XMA)/(XMA-XMB));
mesh.c:real hx(real x) {
mesh.c:  return (1.0+XMC)*fx(x);
mesh.c:real ux(real x) { //Integral of \psi
mesh.c:  if( XMA>XMB ) prs_error("Error! XMA>XMB\n");
mesh.c:  if( XMB>fabs(XMAX) || XMB>fabs(XMIN) ) prs_error("Error! XMB outside domain \n");
mesh.c:  x_mesh_I = (XMAX-XMIN) + XMC*(XMA + XMB);  
mesh.c:  if ( x <= -XMB              ) return fx   (x) - fx   (XMIN)             ;
mesh.c:  if ( x >  -XMB && x <= -XMA ) return gx_p (x) - gx_p (-XMB) + ux(-XMB) ; 
mesh.c:  if ( x >  -XMA && x <=  XMA ) return hx   (x) - hx   (-XMA) + ux(-XMA) ;
mesh.c:  if ( x >   XMA && x <=  XMB ) return gx_m (x) - gx_m ( XMA) + ux( XMA) ;
mesh.c:  if ( x >   XMB              ) return fx   (x) - fx   ( XMB) + ux( XMB) ;
mesh.c:  return 0.0; //default return
mesh.c:void compute_ux_constants(){
mesh.c:  X_mesh_I  = (XMAX-XMIN) + XMC*(XMA + XMB);
mesh.c:real psi_x(real x) { //Mesh density function
mesh.c:  x_mesh_I = (XMAX-XMIN) + XMC*(XMA + XMB);  
mesh.c:  if      (fabs(x) <= XMA)                    return (1+XMC)/x_mesh_I;
mesh.c:  else if (fabs(x)  > XMA && fabs(x) < XMB)   return (1+XMC*pow(cos(M_PI*(fabs(x)-XMA)/(2*(XMB-XMA))),2))/x_mesh_I;
mesh.c:  else                                        return  1/x_mesh_I;
mesh.c:real fy(real y) {
mesh.c:  return log(y)/y_mesh_I;
mesh.c:real gy_p(real y) {
mesh.c:  return log(y)/y_mesh_I + 0.5*YMC*y/y_mesh_I - YMC*(YMB-YMA)/(2.0*M_PI*y_mesh_I)*sin(M_PI*(YMA+(y-YMY0))/(YMA-YMB));
mesh.c:real gy_m(real y) {
mesh.c:  return log(y)/y_mesh_I + 0.5*YMC*y/y_mesh_I - YMC*(YMB-YMA)/(2.0*M_PI*y_mesh_I)*sin(M_PI*(-YMA+(y-YMY0))/(YMA-YMB));
mesh.c:real hy(real y) {
mesh.c:  return (log(y) + YMC*y)/y_mesh_I;
mesh.c:real uy(real y) { //Integral of \psi
mesh.c:  if( YMA>YMB ) prs_error("Error! YMA>YMB\n");
mesh.c:  if( (YMB+YMY0)> YMAX || (YMY0-YMB)< YMIN ) prs_error("Error! YMY0-YMB or YMY0+YMB outside domain \n");
mesh.c:  y_mesh_I = log(YMAX/YMIN) + YMC*(YMA + YMB); 
mesh.c:  if ( y <= YMY0-YMB                    ) return fy   (y) - fy   (YMIN)                     ;
mesh.c:  if ( y >  YMY0-YMB && y <= YMY0-YMA   ) return gy_p (y) - gy_p (YMY0-YMB) + uy(YMY0-YMB) ; 
mesh.c:  if ( y >  YMY0-YMA && y <= YMY0+YMA   ) return hy   (y) - hy   (YMY0-YMA) + uy(YMY0-YMA) ;
mesh.c:  if ( y >  YMY0+YMA && y <= YMY0+YMB   ) return gy_m (y) - gy_m (YMY0+YMA) + uy(YMY0+YMA) ;
mesh.c:  if ( y >  YMY0+YMB                    ) return fy   (y) - fy   (YMY0+YMB) + uy(YMY0+YMB) ;  
mesh.c:  return 0.0; //default return
mesh.c:real psi_y(real y) { //Mesh density function
mesh.c:  y_mesh_I = log(YMAX/YMIN) + YMC*(YMA + YMB);
mesh.c:  if      (fabs(y-YMY0) <= YMA)                   return (1/y+YMC)/y_mesh_I;
mesh.c:  else if (fabs(y-YMY0) > YMA && fabs(y-YMY0) < YMB)   return (1/y+YMC*pow(cos(M_PI*(fabs(y-YMY0)-YMA)/(2*(YMB-YMA))),2))/y_mesh_I;
mesh.c:  else                                            return 1/y/y_mesh_I;
mesh.c:real bisect(real a, real b, int N, real (*u)(real), int option) {
mesh.c:  if (a>b) prs_error("Error! a>b\n");
mesh.c:  real delta = 1e-16;
mesh.c:  int nmax = (int)((log(b-a)-log(delta))/log(2)) - 1;
mesh.c:  real du = 1.0/(real)(N-1); 
mesh.c:  real rhs, fa, fb, fc, c;
mesh.c:  if (option == 1) rhs = u(b) - du; // Used to fill ghost zones
mesh.c:    if (fabs(fc) <= 1e-16) return c;
mesh.c:    else if (fb*fc < 0.0)
mesh.c:    else {
mesh.c:      masterprint("Error! No root in the interval [%16.16lf,%16.16lf]\n",a,b);
mesh.c:      prs_exit(1); 
mesh.c:  return c;  
mhd.c:#include "fargo3d.h"
mhd.c:void ComputeMHD(real dt) {
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vy,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,By,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vz,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bz,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,1,0, 0,0,1, 1, B1_star,V1_star,Slope_b2,Slope_v2,Slope_b1,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,0,1, 0,1,0, 1, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeEmf(dt, 1, 0, 0, B1_star, V1_star, B2_star, V2_star));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vz,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Bz,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vx,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Bx,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,0,1, 1,0,0, 1, B1_star,V1_star,Slope_b2,Slope_v2,Slope_b1,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 1,0,0, 0,0,1, 1, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeEmf(dt, 0, 1, 0, B1_star, V1_star, B2_star, V2_star));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vx,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bx,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vy,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,By,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 1,0,0, 0,1,0, 1, B1_star,V1_star,Slope_b2,Slope_v2,Slope_b1,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,1,0, 1,0,0, 1, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeEmf(dt, 0, 0, 1, B1_star, V1_star, B2_star, V2_star));
mhd.c:#ifdef OHMICDIFFUSION
mhd.c:#endif
mhd.c:#ifdef AMBIPOLARDIFFUSION
mhd.c:#endif
mhd.c:#ifdef HALLEFFECT
mhd.c:  FARGO_SAFE(HallEffect(dt));
mhd.c:#endif
mhd.c:#ifndef PASSIVEMHD
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bx,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vx,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,By,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vy,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,1,0, 1,0,0, 0, B1_star,V1_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Bx,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vx,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Bz,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vz,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,0,1, 1,0,0, 0, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(LorentzForce(dt, B1_star, B2_star, 1, 0, 0));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,By,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vy,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bz,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vz,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,0,1, 0,1,0, 0, B1_star,V1_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,By,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vy,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bx,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vx,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 1,0,0, 0,1,0, 0, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(LorentzForce(dt, B1_star, B2_star, 0, 1, 0));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Bz,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(1,0,0,Vz,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Bx,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vx,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 1,0,0, 0,0,1, 0, B1_star,V1_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Bz,Slope_b1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,1,0,Vz,Slope_v1));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,By,Slope_b2));
mhd.c:  FARGO_SAFE(ComputeSlopes(0,0,1,Vy,Slope_v2));
mhd.c:  FARGO_SAFE(ComputeStar(dt, 0,1,0, 0,0,1, 0, B2_star,V2_star,Slope_b1,Slope_v1,Slope_b2,Slope_v2));
mhd.c:  FARGO_SAFE(LorentzForce(dt, B1_star, B2_star, 0, 0, 1));
mhd.c:#endif
mhd.c:void ComputeDivergence(Field *CompX, Field *CompY, Field *CompZ){
mhd.c:  real *bx,*by,*bz,*d;
mhd.c:  real *sxj;
mhd.c:  real *sxk;
mhd.c:  real *syj;
mhd.c:  real *syk;
mhd.c:  real *szj;
mhd.c:  real *szk;
mhd.c:  OUTPUT (Divergence);
mhd.c:  bx = CompX->field_cpu;
mhd.c:  by = CompY->field_cpu;
mhd.c:  bz = CompZ->field_cpu;
mhd.c:  d = Divergence->field_cpu;
momenta_x.c://#define __GPU
momenta_x.c://#define __NOPROTO
momenta_x.c:#include "fargo3d.h"
momenta_x.c:void momenta_x_cpu() {
momenta_x.c:  INPUT(Density);
momenta_x.c:#ifdef X
momenta_x.c:  INPUT(Vx_temp);
momenta_x.c:#endif
momenta_x.c:  real* rho = Density->field_cpu;
momenta_x.c:#ifdef X  
momenta_x.c:  real* vx = Vx_temp->field_cpu;
momenta_x.c:  real* mmx = Mmx->field_cpu;
momenta_x.c:  real* mpx = Mpx->field_cpu;
momenta_x.c:#endif
momenta_x.c:  int stride = Stride_cpu;
momenta_x.c:  int size_x = XIP; 
momenta_x.c:  int size_y = Ny+2*NGHY;
momenta_x.c:  int size_z = Nz+2*NGHZ;
momenta_x.c:  int i; //Reserved variables 
momenta_x.c:  int j; //for the topology
momenta_x.c:  int k; //of the kernels
momenta_x.c:  real rcyl;
momenta_x.c:// real zmin(Nz+2*NGHZ+1);
momenta_x.c:// real ymin(Ny+2*NGHY+1);
momenta_x.c:// real OMEGAFRAME(1);
momenta_x.c:#ifdef Z
momenta_x.c:  for (k=0; k<size_z; k++) {
momenta_x.c:#endif
momenta_x.c:#ifdef Y
momenta_x.c:    for (j=0; j<size_y; j++) {
momenta_x.c:#endif
momenta_x.c:#ifdef X
momenta_x.c:      for (i=0; i<size_x; i++) {
momenta_x.c:#endif
momenta_x.c:#ifdef X
momenta_x.c:#ifdef CARTESIAN
momenta_x.c:#ifdef SHEARINGBOX
momenta_x.c:	mmx[ll] += 2.0*OMEGAFRAME*ymed(j)*rho[ll];
momenta_x.c:	mpx[ll] += 2.0*OMEGAFRAME*ymed(j)*rho[ll];
momenta_x.c:#endif
momenta_x.c:#endif
momenta_x.c:#ifdef CYLINDRICAL
momenta_x.c:	mmx[ll] = (vx[ll] + ymed(j)*OMEGAFRAME) * ymed(j) * rho[ll];
momenta_x.c:	mpx[ll] = (vx[llxp] + ymed(j)*OMEGAFRAME) * ymed(j) * rho[ll];
momenta_x.c:#endif
momenta_x.c:#ifdef SPHERICAL
momenta_x.c:	rcyl = ymed(j) * sin(zmed(k));
momenta_x.c:#endif
momenta_x.c:#endif
momenta_x.c:#ifdef X
momenta_x.c:#endif
momenta_x.c:#ifdef Y
momenta_x.c:#endif
momenta_x.c:#ifdef Z
momenta_x.c:#endif
momenta_y.c://#define __GPU
momenta_y.c://#define __NOPROTO
momenta_y.c:#include "fargo3d.h"
momenta_y.c:void momenta_y_cpu() {
momenta_y.c:  INPUT(Density);
momenta_y.c:#ifdef Y
momenta_y.c:  INPUT(Vy_temp);
momenta_y.c:#endif
momenta_y.c:  real* rho = Density->field_cpu;
momenta_y.c:#ifdef Y
momenta_y.c:  real* vy = Vy_temp->field_cpu;
momenta_y.c:  real* mmy = Mmy->field_cpu;
momenta_y.c:  real* mpy = Mpy->field_cpu;
momenta_y.c:#endif
momenta_y.c:  int stride = Stride_cpu;
momenta_y.c:  int size_x = Nx+2*NGHX;
momenta_y.c:  int size_y = Ny+2*NGHY-1;
momenta_y.c:  int size_z = Nz+2*NGHZ;
momenta_y.c:  int i; //Reserved variables 
momenta_y.c:  int j; //for the topology
momenta_y.c:  int k; //of the kernels
momenta_y.c:#ifdef Z
momenta_y.c:  for (k=0; k<size_z; k++) {
momenta_y.c:#endif
momenta_y.c:#ifdef Y
momenta_y.c:    for (j=0; j<size_y; j++) {
momenta_y.c:#endif
momenta_y.c:#ifdef X
momenta_y.c:      for (i=0; i<size_x; i++) {
momenta_y.c:#endif
momenta_y.c:#ifdef Y
momenta_y.c:#endif
momenta_y.c:#ifdef X
momenta_y.c:#endif
momenta_y.c:#ifdef Y
momenta_y.c:#endif
momenta_y.c:#ifdef Z
momenta_y.c:#endif
momenta_z.c://#define __GPU
momenta_z.c://#define __NOPROTO
momenta_z.c:#include "fargo3d.h"
momenta_z.c:void momenta_z_cpu() {
momenta_z.c:  INPUT(Density);
momenta_z.c:#ifdef Z
momenta_z.c:  INPUT(Vz_temp);
momenta_z.c:#endif
momenta_z.c:  real* rho = Density->field_cpu;
momenta_z.c:#ifdef Z
momenta_z.c:  real* vz = Vz_temp->field_cpu;
momenta_z.c:  real* mmz = Mmz->field_cpu;
momenta_z.c:  real* mpz = Mpz->field_cpu;
momenta_z.c:#endif
momenta_z.c:  int stride = Stride_cpu;
momenta_z.c:  int size_x = Nx+2*NGHX;
momenta_z.c:  int size_y = Ny+2*NGHY;
momenta_z.c:  int size_z = Nz+2*NGHZ-1;
momenta_z.c:  int i; //Reserved variables 
momenta_z.c:  int j; //for the topology
momenta_z.c:  int k; //of the kernels
momenta_z.c:// real ymin(Ny+2*NGHY+1);
momenta_z.c:#ifdef Z
momenta_z.c:  for (k=0; k<size_z; k++) {
momenta_z.c:#endif
momenta_z.c:#ifdef Y
momenta_z.c:    for (j=0; j<size_y; j++) {
momenta_z.c:#endif
momenta_z.c:#ifdef X
momenta_z.c:      for (i=0; i<size_x; i++) {
momenta_z.c:#endif
momenta_z.c:#ifdef Z
momenta_z.c:#ifdef SPHERICAL
momenta_z.c:	mpz[ll] *= ymed(j);
momenta_z.c:	mmz[ll] *= ymed(j);
momenta_z.c:#endif
momenta_z.c:#endif
momenta_z.c:#ifdef X
momenta_z.c:#endif
momenta_z.c:#ifdef Y
momenta_z.c:#endif
momenta_z.c:#ifdef Z
momenta_z.c:#endif
mon_bxflux.c://#define __GPU
mon_bxflux.c://#define __NOPROTO
mon_bxflux.c:#include "fargo3d.h"
mon_bxflux.c:  OUTPUT(Slope);
mon_bxflux.c:  real* bx = Bx->field_cpu;
mon_bxflux.c:  real* interm = Slope->field_cpu;
mon_bxflux.c:  int stride = Stride_cpu;
mon_bxflux.c:  int size_x = Nx+2*NGHX;
mon_bxflux.c:  int size_y = Ny+2*NGHY;
mon_bxflux.c:  int size_z = Nz+2*NGHZ;
mon_bxflux.c:// real Sxj(Ny+2*NGHY);
mon_bxflux.c:// real Sxk(Nz+2*NGHZ);
mon_bxflux.c:#ifdef Z
mon_bxflux.c:  for (k=0; k<size_z; k++) {
mon_bxflux.c:#endif
mon_bxflux.c:#ifdef Y
mon_bxflux.c:    for (j=0; j<size_y; j++) {
mon_bxflux.c:#endif
mon_bxflux.c:#ifdef X
mon_bxflux.c:      for (i=0; i<size_x; i++ ) {
mon_bxflux.c:#endif
mon_bxflux.c:	interm[ll] = bx[ll]*SurfX(j,k);
mon_bxflux.c:#ifdef X
mon_bxflux.c:#endif
mon_bxflux.c:#ifdef Y
mon_bxflux.c:#endif
mon_bxflux.c:#ifdef Z
mon_bxflux.c:#endif
mon_dens.c://#define __GPU
mon_dens.c://#define __NOPROTO
mon_dens.c:#include "fargo3d.h"
mon_dens.c:void mon_dens_cpu () {
mon_dens.c:  INPUT(Density);
mon_dens.c:  OUTPUT(Slope);
mon_dens.c:  real* dens = Density->field_cpu;
mon_dens.c:  real* interm = Slope->field_cpu;
mon_dens.c:  int stride = Stride_cpu;
mon_dens.c:  int size_x = Nx+2*NGHX;
mon_dens.c:  int size_y = Ny+2*NGHY;
mon_dens.c:  int size_z = Nz+2*NGHZ;
mon_dens.c:// real Sxi(Nx);
mon_dens.c:// real Syk(Nz+2*NGHZ);
mon_dens.c:// real InvVj(Ny+2*NGHY);
mon_dens.c:#ifdef Z
mon_dens.c:  for (k=0; k<size_z; k++) {
mon_dens.c:#endif
mon_dens.c:#ifdef Y
mon_dens.c:    for (j=0; j<size_y; j++) {
mon_dens.c:#endif
mon_dens.c:#ifdef X
mon_dens.c:      for (i=0; i<size_x; i++ ) {
mon_dens.c:#endif
mon_dens.c:	interm[ll] = dens[ll]*Vol(i,j,k);
mon_dens.c:#ifdef X
mon_dens.c:#endif
mon_dens.c:#ifdef Y
mon_dens.c:#endif
mon_dens.c:#ifdef Z
mon_dens.c:#endif
mon_maxwell.c://#define __GPU
mon_maxwell.c://#define __NOPROTO
mon_maxwell.c:#include "fargo3d.h"
mon_maxwell.c:void mon_maxwell_cpu () {
mon_maxwell.c:  INPUT(Density);
mon_maxwell.c:  OUTPUT(Slope);
mon_maxwell.c:  real* dens = Density->field_cpu;
mon_maxwell.c:  real* bx = Bx->field_cpu;
mon_maxwell.c:  real* by = By->field_cpu;
mon_maxwell.c:  real* interm = Slope->field_cpu;
mon_maxwell.c:  int stride = Stride_cpu;
mon_maxwell.c:  int size_x = Nx+2*NGHX;
mon_maxwell.c:  int size_y = Ny+2*NGHY-1;
mon_maxwell.c:  int size_z = Nz+2*NGHZ;
mon_maxwell.c:// real Sxi(Nx);
mon_maxwell.c:// real Syk(Nz+2*NGHZ);
mon_maxwell.c:// real InvVj(Ny+2*NGHY);
mon_maxwell.c:#ifdef Z
mon_maxwell.c:  for (k=0; k<size_z; k++) {
mon_maxwell.c:#endif
mon_maxwell.c:#ifdef Y
mon_maxwell.c:    for (j=0; j<size_y; j++) {
mon_maxwell.c:#endif
mon_maxwell.c:#ifdef X
mon_maxwell.c:      for (i=0; i<size_x; i++ ) {
mon_maxwell.c:#endif
mon_maxwell.c:	interm[ll] = .25*(bx[ll]+bx[lxp])*(by[ll]+by[lyp])/MU0*Vol(i,j,k);
mon_maxwell.c:#ifdef X
mon_maxwell.c:#endif
mon_maxwell.c:#ifdef Y
mon_maxwell.c:#endif
mon_maxwell.c:#ifdef Z
mon_maxwell.c:#endif
mon_momx.c://#define __GPU
mon_momx.c://#define __NOPROTO
mon_momx.c:#include "fargo3d.h"
mon_momx.c:  INPUT(Density);
mon_momx.c:  OUTPUT(Slope);
mon_momx.c:  real* dens = Density->field_cpu;
mon_momx.c:  real* vx   = Vx->field_cpu;
mon_momx.c:  real* mom  = Slope->field_cpu;
mon_momx.c:  int stride = Stride_cpu;
mon_momx.c:  int size_x = XIP; 
mon_momx.c:  int size_y = Ny+2*NGHY;
mon_momx.c:  int size_z = Nz+2*NGHZ;
mon_momx.c:  real rcyl;
mon_momx.c:// real Sxi(Nx);
mon_momx.c:// real Syk(Nz+2*NGHZ);
mon_momx.c:// real InvVj(Ny+2*NGHY);
mon_momx.c:// real ymin(Ny+2*NGHY+1);
mon_momx.c:// real zmin(Nz+2*NGHZ+1);
mon_momx.c:// real OMEGAFRAME(1);
mon_momx.c:#ifdef Z
mon_momx.c:  for (k=0; k<size_z; k++) {
mon_momx.c:#endif
mon_momx.c:#ifdef Y
mon_momx.c:    for (j=0; j<size_y; j++) {
mon_momx.c:#endif
mon_momx.c:#ifdef X
mon_momx.c:      for (i=0; i<size_x; i++ ) {
mon_momx.c:#endif
mon_momx.c:#ifdef CARTESIAN
mon_momx.c:	mom[ll] = dens[ll]*.5*(vx[ll]+vx[lxp])*Vol(i,j,k);
mon_momx.c:#ifdef SHEARINGBOX //SHEARINGBOX is an option for the CARTESIAN geometry
mon_momx.c:	mom[ll] += 2.0*OMEGAFRAME*ymed(j)*dens[ll]*Vol(i,j,k);
mon_momx.c:#endif
mon_momx.c:#endif
mon_momx.c:#ifdef CYLINDRICAL
mon_momx.c:	mom[ll] = (.5*(vx[ll]+vx[lxp])+ymed(j)*OMEGAFRAME)*ymed(j)*dens[ll]*Vol(i,j,k);
mon_momx.c:#endif
mon_momx.c:#ifdef SPHERICAL
mon_momx.c:	rcyl = ymed(j) * sin(zmed(k));
mon_momx.c:	mom[ll] = (.5*(vx[ll]+vx[lxp]) + rcyl*OMEGAFRAME)*rcyl*dens[ll]*Vol(i,j,k);
mon_momx.c:#endif
mon_momx.c:#ifdef X
mon_momx.c:#endif
mon_momx.c:#ifdef Y
mon_momx.c:#endif
mon_momx.c:#ifdef Z
mon_momx.c:#endif
mon_momy.c://#define __GPU
mon_momy.c://#define __NOPROTO
mon_momy.c:#include "fargo3d.h"
mon_momy.c:  INPUT(Density);
mon_momy.c:  OUTPUT(Slope);
mon_momy.c:  real* dens = Density->field_cpu;
mon_momy.c:  real* vy   = Vy->field_cpu;
mon_momy.c:  real* mom  = Slope->field_cpu;
mon_momy.c:  int stride = Stride_cpu;
mon_momy.c:  int size_x = Nx+2*NGHX;
mon_momy.c:  int size_y = Ny+2*NGHY-1;
mon_momy.c:  int size_z = Nz+2*NGHZ;
mon_momy.c:// real Sxi(Nx);
mon_momy.c:// real Syk(Nz+2*NGHZ);
mon_momy.c:// real InvVj(Ny+2*NGHY);
mon_momy.c:#ifdef Z
mon_momy.c:  for (k=0; k<size_z; k++) {
mon_momy.c:#endif
mon_momy.c:#ifdef Y
mon_momy.c:    for (j=0; j<size_y; j++) {
mon_momy.c:#endif
mon_momy.c:#ifdef X
mon_momy.c:      for (i=0; i<size_x; i++ ) {
mon_momy.c:#endif
mon_momy.c:	mom[ll] = dens[ll]*.5*(vy[ll]+vy[lyp])*Vol(i,j,k);
mon_momy.c:#ifdef X
mon_momy.c:#endif
mon_momy.c:#ifdef Y
mon_momy.c:#endif
mon_momy.c:#ifdef Z
mon_momy.c:#endif
mon_momz.c://#define __GPU
mon_momz.c://#define __NOPROTO
mon_momz.c:#include "fargo3d.h"
mon_momz.c:  INPUT(Density);
mon_momz.c:  OUTPUT(Slope);
mon_momz.c:  real* dens = Density->field_cpu;
mon_momz.c:  real* vz   = Vz->field_cpu;
mon_momz.c:  real* mom  = Slope->field_cpu;
mon_momz.c:  int stride = Stride_cpu;
mon_momz.c:  int size_x = Nx+2*NGHX;
mon_momz.c:  int size_y = Ny+2*NGHY;
mon_momz.c:  int size_z = Nz+2*NGHZ-1;
mon_momz.c:// real Sxi(Nx);
mon_momz.c:// real Syk(Nz+2*NGHZ);
mon_momz.c:// real InvVj(Ny+2*NGHY);
mon_momz.c:// real ymin(Ny+2*NGHY+1);
mon_momz.c:#ifdef Z
mon_momz.c:  for (k=0; k<size_z; k++) {
mon_momz.c:#endif
mon_momz.c:#ifdef Y
mon_momz.c:    for (j=0; j<size_y; j++) {
mon_momz.c:#endif
mon_momz.c:#ifdef X
mon_momz.c:      for (i=0; i<size_x; i++ ) {
mon_momz.c:#endif
mon_momz.c:	mom[ll] = dens[ll]*.5*(vz[ll]+vz[lzp])*Vol(i,j,k);
mon_momz.c:#ifdef SPHERICAL
mon_momz.c:	mom[ll] *= ymed(j);
mon_momz.c:#endif
mon_momz.c:#ifdef X
mon_momz.c:#endif
mon_momz.c:#ifdef Y
mon_momz.c:#endif
mon_momz.c:#ifdef Z
mon_momz.c:#endif
mon_reynolds.c://#define __GPU
mon_reynolds.c://#define __NOPROTO
mon_reynolds.c:#include "fargo3d.h"
mon_reynolds.c:void mon_reynolds_cpu () {
mon_reynolds.c:  INPUT(Density);
mon_reynolds.c:  INPUT2D(VxMed);
mon_reynolds.c:  OUTPUT(Slope);
mon_reynolds.c:  real* dens = Density->field_cpu;
mon_reynolds.c:  real* vx = Vx->field_cpu;
mon_reynolds.c:  real* vxm = VxMed->field_cpu;
mon_reynolds.c:  real* vy = Vy->field_cpu;
mon_reynolds.c:  real* interm = Slope->field_cpu;
mon_reynolds.c:  int stride = Stride_cpu;
mon_reynolds.c:  int size_x = Nx+2*NGHX;
mon_reynolds.c:  int size_y = Ny+2*NGHY-1;
mon_reynolds.c:  int size_z = Nz+2*NGHZ;
mon_reynolds.c:// real Sxi(Nx);
mon_reynolds.c:// real Syk(Nz+2*NGHZ);
mon_reynolds.c:// real InvVj(Ny+2*NGHY);
mon_reynolds.c:#ifdef Z
mon_reynolds.c:  for (k=0; k<size_z; k++) {
mon_reynolds.c:#endif
mon_reynolds.c:#ifdef Y
mon_reynolds.c:    for (j=0; j<size_y; j++) {
mon_reynolds.c:#endif
mon_reynolds.c:#ifdef X
mon_reynolds.c:      for (i=0; i<size_x; i++ ) {
mon_reynolds.c:#endif
mon_reynolds.c:	interm[ll] = .25*dens[ll]*(vy[ll]+vy[lyp])*\
mon_reynolds.c:#ifdef X
mon_reynolds.c:#endif
mon_reynolds.c:#ifdef Y
mon_reynolds.c:#endif
mon_reynolds.c:#ifdef Z
mon_reynolds.c:#endif
mon_torque.c://#define __GPU
mon_torque.c://#define __NOPROTO
mon_torque.c:#include "fargo3d.h"
mon_torque.c:  INPUT(Density);
mon_torque.c:  OUTPUT(Slope);
mon_torque.c:  real rplanet = sqrt(Xplanet*Xplanet+Yplanet*Yplanet+Zplanet*Zplanet);
mon_torque.c:  real rsmoothing = THICKNESSSMOOTHING*ASPECTRATIO*pow(rplanet/R0,FLARINGINDEX)*rplanet;
mon_torque.c:  real* dens = Density->field_cpu;
mon_torque.c:  real* interm = Slope->field_cpu;
mon_torque.c:  int stride = Stride_cpu;
mon_torque.c:  int size_x = Nx+2*NGHX;
mon_torque.c:  int size_y = Ny+2*NGHY;
mon_torque.c:  int size_z = Nz+2*NGHZ;
mon_torque.c:  real rsm2 = rsmoothing*rsmoothing;
mon_torque.c:  real dx;
mon_torque.c:  real dy;
mon_torque.c:  real dz=0.0;
mon_torque.c:  real InvDist3;
mon_torque.c:  real cellmass;
mon_torque.c:  real dist2;
mon_torque.c:  real distance;
mon_torque.c:  real fxi;
mon_torque.c:  real fyi;
mon_torque.c:// real Xplanet(1);
mon_torque.c:// real Yplanet(1);
mon_torque.c:// real Zplanet(1);
mon_torque.c:// real VXplanet(1);
mon_torque.c:// real VYplanet(1);
mon_torque.c:// real VZplanet(1);
mon_torque.c:// real MplanetVirtual(1);
mon_torque.c:// real Syk(Nz+2*NGHZ);
mon_torque.c:// real InvVj(Ny+2*NGHY);
mon_torque.c:// real xmin(Nx+2*NGHX+1);
mon_torque.c:// real ymin(Ny+2*NGHY+1);
mon_torque.c:// real zmin(Nz+2*NGHZ+1);
mon_torque.c:// real Sxi(Nx);
mon_torque.c:#ifdef Z
mon_torque.c:  for (k=0; k<size_z; k++) {
mon_torque.c:#endif
mon_torque.c:#ifdef Y
mon_torque.c:    for (j=0; j<size_y; j++) {
mon_torque.c:#endif
mon_torque.c:#ifdef X
mon_torque.c:      for (i=0; i<size_x; i++ ) {
mon_torque.c:#endif
mon_torque.c:	cellmass = Vol(i,j,k)*dens[ll];
mon_torque.c:#ifdef CARTESIAN
mon_torque.c:	dx = xmed(i)-Xplanet;
mon_torque.c:	dy = ymed(j)-Yplanet;
mon_torque.c:#ifdef Z
mon_torque.c:	dz = zmed(k)-Zplanet;
mon_torque.c:#endif
mon_torque.c:#endif
mon_torque.c:#ifdef CYLINDRICAL
mon_torque.c:	dx = ymed(j)*cos(xmed(i))-Xplanet;
mon_torque.c:	dy = ymed(j)*sin(xmed(i))-Yplanet;
mon_torque.c:#ifdef Z
mon_torque.c:	dz = zmed(k)-Zplanet;
mon_torque.c:#endif
mon_torque.c:#endif
mon_torque.c:#ifdef SPHERICAL
mon_torque.c:	dx = ymed(j)*cos(xmed(i))*sin(zmed(k))-Xplanet;
mon_torque.c:	dy = ymed(j)*sin(xmed(i))*sin(zmed(k))-Yplanet;
mon_torque.c:#ifdef Z
mon_torque.c:	dz = ymed(j)*cos(zmed(k))-Zplanet;
mon_torque.c:#endif
mon_torque.c:#endif
mon_torque.c:	distance = sqrt(dist2);
mon_torque.c:	InvDist3 = 1.0/(dist2*distance);
mon_torque.c:	InvDist3 *= G*cellmass;
mon_torque.c:	interm[ll] = Xplanet*fyi-Yplanet*fxi;
mon_torque.c:#ifdef X
mon_torque.c:#endif
mon_torque.c:#ifdef Y
mon_torque.c:#endif
mon_torque.c:#ifdef Z
mon_torque.c:#endif
monitor.c:#include "fargo3d.h"
monitor.c:#define FORMAT "%.12g\t"
monitor.c:#define MAX_MONITOR 20
monitor.c:#define MAX_STRING  100
monitor.c:char mon_name[MAX_MONITOR][MAX_STRING];
monitor.c:char mon_cent[MAX_MONITOR][MAX_STRING];
monitor.c:static boolean func_declared = NO;
monitor.c:static int MonCounter=0;
monitor.c:int Index(int v) {
monitor.c:  unsigned int r = 0;
monitor.c:  while (v >>= 1) {
monitor.c:  return r;
monitor.c:void Write1DFile (char *filename, real *x, real *y, int n) {
monitor.c:  out = fopen_prs (filename, "w");
monitor.c:  fclose (out);
monitor.c:/* Below: 3D monitoring not implemented yet */
monitor.c:void InitMonitoring3D (int bitchoice) {
monitor.c:  while (bitchoice) {
monitor.c:    if (bitchoice & 1) {
monitor.c:      idx = Index(r);
monitor.c:      //      SetUpMonitoring (idx);
monitor.c:    bitchoice >>= 1;
monitor.c:  InitFunctionMonitoring (MASS,    mon_dens, "mass", TOTAL, "YCZC", INDEP_PLANET);
monitor.c:  InitFunctionMonitoring (REYNOLDS, mon_reynolds, "reynolds", TOTAL, "YCZC", INDEP_PLANET);
monitor.c:  InitFunctionMonitoring (MAXWELL, mon_maxwell, "maxwell", TOTAL, "YCZC", INDEP_PLANET);
monitor.c:  func_declared = YES;
monitor.c:void InitFunctionMonitoring (int bittype, void (*f)(), char *name,\
monitor.c:			     int kind, char *centering, int planetdep) {
monitor.c:  idx = Index(bittype);
monitor.c:    prs_error ("Too many quantities monitored. Rebuild code after increasing MAX_MONITOR in monitor.c\n");
monitor.c:  mon_pldp[idx] = planetdep;
monitor.c:  strncpy(mon_name[idx], name, MAX_STRING-1);
monitor.c:  strncpy(mon_cent[idx], centering, 5);
monitor.c:void MonitorFunction (int idx, int r, char *CurrentFineGrainDir, int plnb) {
monitor.c:  static real Profile[MAX1D];
monitor.c:  static real GProfile[MAX1D];
monitor.c:  static real Coord[MAX1D];
monitor.c:  static real GCoord[MAX1D];
monitor.c:  char filename[MAXLINELENGTH];
monitor.c:  char planet_number[MAXLINELENGTH];
monitor.c:  boolean centered;
monitor.c:  real lsum=0.0, gsum=0.0;
monitor.c:  if(MAX1D < NZ) masterprint("Error in monitor.c --- MAX1D < NZ --- increase the value of MAX1D in define.h\n");
monitor.c:  if(MAX1D < NY) masterprint("Error in monitor.c --- MAX1D < NY --- increase the value of MAX1D in define.h\n");
monitor.c:    sprintf (planet_number, "%s", "");
monitor.c:  else
monitor.c:    sprintf (planet_number, "_planet_%d", plnb);
monitor.c:    sprintf (filename, "%s_2d_%07d%s.dat", mon_name[idx], MonCounter, planet_number);
monitor.c:    Write2D (Reduction2D, filename, CurrentFineGrainDir, NOGHOSTINC);
monitor.c:    centered = NO;
monitor.c:    if ((mon_cent[idx][1] == 'C') || (mon_cent[idx][1] == 'c'))
monitor.c:      centered = YES;
monitor.c:    INPUT2D (Reduction2D);
monitor.c:      Profile[j] = 0.0;
monitor.c:      Coord[j] = -1e30;
monitor.c:      Coord[j+y0cell-NGHY] = (centered ? Ymed(j) : Ymin(j));
monitor.c:	Profile[j+y0cell-NGHY] += Reduction2D->field_cpu[l2D];
monitor.c:#ifndef FLOAT
monitor.c:    MPI_Reduce (Profile, GProfile, NY, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:    MPI_Reduce (Coord,   GCoord,   NY, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
monitor.c:#else
monitor.c:    MPI_Reduce (Profile, GProfile, NY, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:    MPI_Reduce (Coord,   GCoord,   NY, MPI_FLOAT, MPI_MAX, 0, MPI_COMM_WORLD);
monitor.c:#endif
monitor.c:    // Now GProfile contains the intended 1D profile
monitor.c:      sprintf (filename, "%s%s_1d_Y_%07d%s.dat",CurrentFineGrainDir,	\
monitor.c:	       mon_name[idx], MonCounter, planet_number);
monitor.c:      Write1DFile (filename, GCoord, GProfile, NY);
monitor.c:      sprintf (filename, "%smonitor/%s/%s_1d_Y_raw%s.dat", OUTPUTDIR, Fluids[FluidIndex]->name,mon_name[idx], planet_number);
monitor.c:      Out = fopen_prs (filename, "a");
monitor.c:	fwrite (GProfile, sizeof (real), NY, Out);
monitor.c:      fclose (Out);
monitor.c:    centered = NO;
monitor.c:    if ((mon_cent[idx][3] == 'C') || (mon_cent[idx][3] == 'c'))
monitor.c:      centered = YES;
monitor.c:    INPUT2D (Reduction2D);
monitor.c:      Profile[k] = 0.0;
monitor.c:      Coord[k+z0cell-NGHZ] = (centered ? Zmed(k) : Zmin(k));
monitor.c:	Profile[k+z0cell-NGHZ] += Reduction2D->field_cpu[l2D];
monitor.c:#ifndef FLOAT 
monitor.c:    MPI_Reduce (Profile, GProfile, NZ, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:    MPI_Reduce (Coord,   GCoord,   NZ, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
monitor.c:#else
monitor.c:    MPI_Reduce (Profile, GProfile, NZ, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:    MPI_Reduce (Coord,   GCoord,   NZ, MPI_FLOAT, MPI_MAX, 0, MPI_COMM_WORLD);
monitor.c:#endif
monitor.c:    // Now GProfile contains the intended 1D profile
monitor.c:      sprintf (filename, "%s/%s_1d_Z_%07d%s.dat",CurrentFineGrainDir,	\
monitor.c:	       mon_name[idx], MonCounter, planet_number);
monitor.c:      Write1DFile (filename, GCoord, GProfile, NZ);
monitor.c:      sprintf (filename, "%smonitor/%s/%s_1d_Z_raw%s.dat", OUTPUTDIR, Fluids[FluidIndex]->name,mon_name[idx], planet_number);
monitor.c:      Out = fopen_prs (filename, "a");
monitor.c:	fwrite (GProfile, sizeof (real), NZ, Out);
monitor.c:      fclose (Out);
monitor.c:    INPUT2D (Reduction2D);
monitor.c:	lsum += Reduction2D->field_cpu[l2D];
monitor.c:#ifndef FLOAT
monitor.c:    MPI_Reduce(&lsum, &gsum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:#else
monitor.c:    MPI_Reduce(&lsum, &gsum, 1, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);
monitor.c:#endif
monitor.c:    sprintf (filename, "%smonitor/%s/%s%s.dat", OUTPUTDIR, Fluids[FluidIndex]->name,mon_name[idx], planet_number);
monitor.c:    Out = fopen_prs (filename, "a");
monitor.c:      fprintf (Out, "%.12g\t%.12g\n", PhysicalTime, gsum);
monitor.c:    fclose (Out);
monitor.c:    if (ThereArePlanets) {
monitor.c:      Xplanet = Sys->x[i];
monitor.c:      Yplanet  = Sys->y[i];
monitor.c:      Zplanet  = Sys->z[i];
monitor.c:      VXplanet = Sys->vx[i];
monitor.c:      VYplanet = Sys->vy[i];
monitor.c:      VZplanet = Sys->vz[i];
monitor.c:      MplanetVirtual = Sys->mass[i];
monitor.c:    } else {
monitor.c:      Xplanet = Yplanet = Zplanet = VXplanet = VYplanet = VZplanet = MplanetVirtual = 0.0;
monitor.c:    reduction_SUM (Slope, NGHY, Ny+NGHY, NGHZ, Nz+NGHZ);
monitor.c:void MonitorGlobal (int bitchoice) {
monitor.c:  char CurrentFineGrainDir[MAXLINELENGTH];
monitor.c:  if (func_declared == NO) InitMonitoring ();
monitor.c:  sprintf (CurrentFineGrainDir, "%smonitor/%s/FG%06d/", OUTPUTDIR, Fluids[FluidIndex]->name,TimeStep);
monitor.c:  if (bitchoice & REYNOLDS)
monitor.c:    ComputeVmed (Vx);
monitor.c:  while (bitchoice) {
monitor.c:    if (bitchoice & 1) {
monitor.c:      idx = Index(r);
monitor.c:      DoMonitoring (idx, r, CurrentFineGrainDir);
monitor.c:    bitchoice >>= 1;
monitor.c:  if (FluidIndex == NFLUIDS-1) MonCounter++;
mpi_dummy.c:/** \file mpi_dummy.c
mpi_dummy.c:Dummy MPI functions library for sequential built.
mpi_dummy.c:It is used instead of the true MPI library in the
mpi_dummy.c:case of a sequential built (see makefile).
mpi_dummy.c:#include <stdio.h>
mpi_dummy.c:#include "mpi_dummy.h"
mpi_dummy.c:#pragma GCC diagnostic ignored "-Wmissing-prototypes"
mpi_dummy.c:void MPI_Comm_rank (int a, int *b) {*b = 0;} /* Only one process, with rank zero... */
mpi_dummy.c:void MPI_Comm_size (int a, int *b) {*b = 1;} /* Only one process in the world communicator... */
mpi_dummy.c:  fprintf (stderr, "\n       !!!! WARNING !!!!\n\n");
mpi_dummy.c:  fprintf (stderr, "This is a sequential built of the %s code\n", *argv[0]);
mpi_dummy.c:  fprintf (stderr, "If you planned to run the MPI-parallel version,\n");
mpi_dummy.c:  fprintf (stderr, "then you MUST rebuild the executable. In this case,\n");
mpi_dummy.c:  fprintf (stderr, " issue:\nmake PARALLEL=1 (or make para)\n");
mpi_dummy.c:  fprintf (stderr, "\nAny subsequent invocation of make will build an MPI version.\n");
mpi_dummy.c:void MPI_Allreduce (void *ptr, void *ptr2, int count, int type, int foo3, int foo4) {
mpi_dummy.c:    switch (type) {
mpi_dummy.c:    case MPI_FLOAT:
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_DOUBLE:
mpi_dummy.c:      *(((double *)ptr2)+i) = (double)(*(((double *)ptr)+i));
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_INT:
mpi_dummy.c:      break;
mpi_dummy.c:void MPI_Gather (void *s, int n, int type, void *r, int m, int type2, int root, int foo) {
mpi_dummy.c:    switch (type) {
mpi_dummy.c:    case MPI_FLOAT:
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_DOUBLE:
mpi_dummy.c:      *(((double *)r)+i) = (double)(*(((double *)s)+i));
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_INT:
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_CHAR:
mpi_dummy.c:      break;
mpi_dummy.c:void MPI_Reduce (void *ptr, void *ptr2, int count, int type, int foo3, int foo4, int foo5) {
mpi_dummy.c:    switch (type) {
mpi_dummy.c:    case MPI_FLOAT:
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_DOUBLE:
mpi_dummy.c:      *(((double *)ptr2)+i) = (double)(*(((double *)ptr)+i));
mpi_dummy.c:      break;
mpi_dummy.c:    case MPI_INT:
mpi_dummy.c:      break;
mpi_dummy.c:void MPI_Finalize(){}
mpi_dummy.c:void MPI_Isend(){}
mpi_dummy.c:void MPI_Irecv(){}
mpi_dummy.c:void MPI_Send(){}
mpi_dummy.c:void MPI_Recv(){}
mpi_dummy.c:void MPI_Barrier(){}
mpi_dummy.c:void MPI_Scan(){} //In place scans require no special action
newvel_x.c://#define __GPU
newvel_x.c://#define __NOPROTO
newvel_x.c:#include "fargo3d.h"
newvel_x.c:void NewVelocity_x_cpu () {
newvel_x.c:  INPUT(Density);
newvel_x.c:#ifdef X
newvel_x.c:#endif
newvel_x.c:  real* rho = Density->field_cpu;
newvel_x.c:#ifdef X
newvel_x.c:  real* vx  = Vx->field_cpu;
newvel_x.c:  real* mmx = Mmx->field_cpu;
newvel_x.c:  real* mpx = Mpx->field_cpu;
newvel_x.c:#endif
newvel_x.c:  int stride = Stride_cpu;
newvel_x.c:  int size_x = Nx+2*NGHX;
newvel_x.c:  int size_y = Ny+2*NGHY;
newvel_x.c:  int size_z = Nz+2*NGHZ;
newvel_x.c:  int i; //Variables reserved
newvel_x.c:  int j; //for the topology
newvel_x.c:  int k; //of the kernels
newvel_x.c:#ifdef SPHERICAL
newvel_x.c:  real rcyl;
newvel_x.c:#endif
newvel_x.c:// real xmin(Nx+1);
newvel_x.c:// real ymin(Ny+2*NGHY+1);
newvel_x.c:// real zmin(Nz+2*NGHZ+1);
newvel_x.c:// real OMEGAFRAME(1);
newvel_x.c:// real Syk(Nz+2*NGHZ);
newvel_x.c:// real InvVj(Ny+2*NGHY);
newvel_x.c:// real Sxi(Nx);
newvel_x.c:#ifdef Z
newvel_x.c:  for (k=1; k<size_z; k++) {
newvel_x.c:#endif
newvel_x.c:#ifdef Y
newvel_x.c:    for (j=1; j<size_y; j++) {
newvel_x.c:#endif
newvel_x.c:#ifdef X
newvel_x.c:      for (i=XIM; i<size_x; i++) {
newvel_x.c:#endif
newvel_x.c:#ifdef X
newvel_x.c:#ifdef CARTESIAN
newvel_x.c:#ifdef SHEARINGBOX
newvel_x.c:	vx[ll] -= 2.0*OMEGAFRAME*ymed(j);
newvel_x.c:#endif
newvel_x.c:#endif
newvel_x.c:#ifdef CYLINDRICAL
newvel_x.c:	vx[ll] = (mmx[ll]*Vol(i,j,k) + mpx[llxm]*Vol(ixm,j,k) )/((rho[ll]*Vol(i,j,k)+rho[llxm]*Vol(ixm,j,k))*ymed(j))-OMEGAFRAME*ymed(j);
newvel_x.c:#endif
newvel_x.c:#ifdef SPHERICAL
newvel_x.c:	rcyl = ymed(j) * sin(zmed(k));
newvel_x.c:#endif
newvel_x.c:#endif
newvel_x.c:#ifdef X
newvel_x.c:#endif
newvel_x.c:#ifdef Y
newvel_x.c:#endif
newvel_x.c:#ifdef Z
newvel_x.c:#endif
newvel_y.c://#define __GPU
newvel_y.c://#define __NOPROTO
newvel_y.c:#include "fargo3d.h"
newvel_y.c:void NewVelocity_y_cpu () {
newvel_y.c:  INPUT(Density);
newvel_y.c:#ifdef Y
newvel_y.c:#endif
newvel_y.c:  real* rho = Density->field_cpu;
newvel_y.c:#ifdef Y
newvel_y.c:  real* vy  = Vy -> field_cpu;
newvel_y.c:  real* mmy = Mmy->field_cpu;
newvel_y.c:  real* mpy = Mpy->field_cpu;
newvel_y.c:#endif
newvel_y.c:  int stride = Stride_cpu;
newvel_y.c:  int size_x = Nx+2*NGHX;
newvel_y.c:  int size_y = Ny+2*NGHY;
newvel_y.c:  int size_z = Nz+2*NGHZ;
newvel_y.c:  int i; //Variables reserved
newvel_y.c:  int j; //for the topology
newvel_y.c:  int k; //of the kernels
newvel_y.c:// real Syk(Nz+2*NGHZ);
newvel_y.c:// real InvVj(Ny+2*NGHY);
newvel_y.c:// real Sxi(Nx+2*NGHX);
newvel_y.c:#ifdef Z
newvel_y.c:  for (k=1; k<size_z; k++) {
newvel_y.c:#endif
newvel_y.c:#ifdef Y
newvel_y.c:    for (j=1; j<size_y; j++) {
newvel_y.c:#endif
newvel_y.c:#ifdef X
newvel_y.c:      for (i=XIM; i<size_x; i++) {
newvel_y.c:#endif
newvel_y.c:#ifdef Y
newvel_y.c:#endif
newvel_y.c:#ifdef X
newvel_y.c:#endif
newvel_y.c:#ifdef Y
newvel_y.c:#endif
newvel_y.c:#ifdef Z
newvel_y.c:#endif
newvel_z.c://#define __GPU
newvel_z.c://#define __NOPROTO
newvel_z.c:#include "fargo3d.h"
newvel_z.c:void NewVelocity_z_cpu () {
newvel_z.c:  INPUT(Density);
newvel_z.c:#ifdef Z
newvel_z.c:#endif
newvel_z.c:  real* rho = Density->field_cpu;
newvel_z.c:#ifdef Z
newvel_z.c:  real* vz  = Vz -> field_cpu;
newvel_z.c:  real* mmz = Mmz->field_cpu;
newvel_z.c:  real* mpz = Mpz->field_cpu;
newvel_z.c:#endif
newvel_z.c:  int stride = Stride_cpu;
newvel_z.c:  int size_x = Nx+2*NGHX;
newvel_z.c:  int size_y = Ny+2*NGHY;
newvel_z.c:  int size_z = Nz+2*NGHZ;
newvel_z.c:  int i; //Variables reserved
newvel_z.c:  int j; //for the topology
newvel_z.c:  int k; //of the kernels
newvel_z.c:// real xmin(Nx+1);
newvel_z.c:// real ymin(Ny+2*NGHY+1);
newvel_z.c:// real Syk(Nz+2*NGHZ);
newvel_z.c:// real InvVj(Ny+2*NGHY);
newvel_z.c:// real Sxi(Nx);
newvel_z.c:#ifdef Z
newvel_z.c:  for (k=1; k<size_z; k++) {
newvel_z.c:#endif
newvel_z.c:#ifdef Y
newvel_z.c:    for (j=1; j<size_y; j++) {
newvel_z.c:#endif
newvel_z.c:#ifdef X
newvel_z.c:      for (i=XIM; i<size_x; i++) {
newvel_z.c:#endif
newvel_z.c:#ifdef Z
newvel_z.c:#ifdef SPHERICAL
newvel_z.c:	vz[ll] /= ymed(j);
newvel_z.c:#endif
newvel_z.c:#endif
newvel_z.c:#ifdef X
newvel_z.c:#endif
newvel_z.c:#ifdef Y
newvel_z.c:#endif
newvel_z.c:#ifdef Z
newvel_z.c:#endif
nimhd_ambipolar_diffusion.c:#include "fargo3d.h"
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(ComputeJx());
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(ComputeJy());
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(ComputeJz());
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(AmbipolarDiffusion_emfx());
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(AmbipolarDiffusion_emfy());
nimhd_ambipolar_diffusion.c:  FARGO_SAFE(AmbipolarDiffusion_emfz());
nimhd_ambipolar_diffusion_coeff.c://#define __GPU
nimhd_ambipolar_diffusion_coeff.c://#define __NOPROTO
nimhd_ambipolar_diffusion_coeff.c:#include "fargo3d.h"
nimhd_ambipolar_diffusion_coeff.c:void AmbipolarDiffusion_coeff_cpu () {
nimhd_ambipolar_diffusion_coeff.c:  real* eta  = EtaAD->field_cpu;
nimhd_ambipolar_diffusion_coeff.c:  real etaad = AMBIPOLARDIFFUSIONCOEFF;
nimhd_ambipolar_diffusion_coeff.c:  int stride = Stride_cpu;
nimhd_ambipolar_diffusion_coeff.c:  int size_x = Nx+2*NGHX;
nimhd_ambipolar_diffusion_coeff.c:  int size_y = Ny+2*NGHY;
nimhd_ambipolar_diffusion_coeff.c:  int size_z = Nz+2*NGHZ;
nimhd_ambipolar_diffusion_coeff.c:#ifdef Z
nimhd_ambipolar_diffusion_coeff.c:  for (k=0; k<size_z; k++) {
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_coeff.c:#ifdef Y
nimhd_ambipolar_diffusion_coeff.c:    for (j=0; j<size_y; j++) {
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_coeff.c:#ifdef X
nimhd_ambipolar_diffusion_coeff.c:      for (i=0; i<size_x; i++ ) {
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_coeff.c:	eta[l] = etaad;
nimhd_ambipolar_diffusion_coeff.c:#ifdef X
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_coeff.c:#ifdef Y
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_coeff.c:#ifdef Z
nimhd_ambipolar_diffusion_coeff.c:#endif
nimhd_ambipolar_diffusion_emfx.c://#define __GPU
nimhd_ambipolar_diffusion_emfx.c://#define __NOPROTO
nimhd_ambipolar_diffusion_emfx.c:#include "fargo3d.h"
nimhd_ambipolar_diffusion_emfx.c:void AmbipolarDiffusion_emfx_cpu(){
nimhd_ambipolar_diffusion_emfx.c:  real* bx = Bx->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* by = By->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* bz = Bz->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* jx = Jx->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* jy = Jy->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* jz = Jz->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* eta = EtaAD->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  real* emf = Emfx->field_cpu;
nimhd_ambipolar_diffusion_emfx.c:  int stride = Stride_cpu;
nimhd_ambipolar_diffusion_emfx.c:  int size_x = Nx;
nimhd_ambipolar_diffusion_emfx.c:  int size_y = Ny+2*NGHY-1;
nimhd_ambipolar_diffusion_emfx.c:  int size_z = Nz+2*NGHZ-1;
nimhd_ambipolar_diffusion_emfx.c:  real j1;
nimhd_ambipolar_diffusion_emfx.c:  real j2;
nimhd_ambipolar_diffusion_emfx.c:  real j3;
nimhd_ambipolar_diffusion_emfx.c:  real b1;
nimhd_ambipolar_diffusion_emfx.c:  real b2;
nimhd_ambipolar_diffusion_emfx.c:  real b3;
nimhd_ambipolar_diffusion_emfx.c:  real bmod;
nimhd_ambipolar_diffusion_emfx.c:  real etac;
nimhd_ambipolar_diffusion_emfx.c:  real eps = 1e-30;
nimhd_ambipolar_diffusion_emfx.c:  for (k=1; k<size_z; k++) {
nimhd_ambipolar_diffusion_emfx.c:    for (j=1; j<size_y; j++) {
nimhd_ambipolar_diffusion_emfx.c:      for (i=0; i<size_x; i++) {
nimhd_ambipolar_diffusion_emfx.c:	j3 = 0.25*(jz[ll] + jz[lzm] + jz[lxp] + jz[lxp-stride]);
nimhd_ambipolar_diffusion_emfx.c:	b1 = 0.125*(bx[ll] + bx[lxp] + bx[lzm] + bx[lxp-stride] + bx[lym] + bx[lxp-pitch] + bx[lym-stride] + bx[lxp-pitch-stride]);
nimhd_ambipolar_diffusion_emfx.c:	bmod = b1*b1 + b2*b2 + b3*b3 + eps;
nimhd_ambipolar_diffusion_emfx.c:	etac = 0.25*(eta[ll]+eta[lym]+eta[lzm]+eta[lym-stride]);
nimhd_ambipolar_diffusion_emfx.c:#if (defined(CARTESIAN) || defined(SPHERICAL) )
nimhd_ambipolar_diffusion_emfx.c:	emf[ll] += etac*(j1 - (b1*j1+b2*j2+b3*j3)*b1/bmod);
nimhd_ambipolar_diffusion_emfx.c:#endif
nimhd_ambipolar_diffusion_emfx.c:#ifdef CYLINDRICAL
nimhd_ambipolar_diffusion_emfx.c:	emf[ll] -= etac*(j1 - (b1*j1+b2*j2+b3*j3)*b1/bmod);
nimhd_ambipolar_diffusion_emfx.c:#endif
nimhd_ambipolar_diffusion_emfy.c://#define __GPU
nimhd_ambipolar_diffusion_emfy.c://#define __NOPROTO
nimhd_ambipolar_diffusion_emfy.c:#include "fargo3d.h"
nimhd_ambipolar_diffusion_emfy.c:void AmbipolarDiffusion_emfy_cpu(){
nimhd_ambipolar_diffusion_emfy.c:  real* bx = Bx->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* by = By->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* bz = Bz->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* jx = Jx->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* jy = Jy->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* jz = Jz->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* eta = EtaAD->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  real* emf = Emfy->field_cpu;
nimhd_ambipolar_diffusion_emfy.c:  int stride = Stride_cpu;
nimhd_ambipolar_diffusion_emfy.c:  int size_x = Nx;
nimhd_ambipolar_diffusion_emfy.c:  int size_y = Ny+2*NGHY-1;
nimhd_ambipolar_diffusion_emfy.c:  int size_z = Nz+2*NGHZ-1;
nimhd_ambipolar_diffusion_emfy.c:  real j1;
nimhd_ambipolar_diffusion_emfy.c:  real j2;
nimhd_ambipolar_diffusion_emfy.c:  real j3;
nimhd_ambipolar_diffusion_emfy.c:  real b1;
nimhd_ambipolar_diffusion_emfy.c:  real b2;
nimhd_ambipolar_diffusion_emfy.c:  real b3;
nimhd_ambipolar_diffusion_emfy.c:  real bmod;
nimhd_ambipolar_diffusion_emfy.c:  real etac;
nimhd_ambipolar_diffusion_emfy.c:  real eps = 1e-30;
nimhd_ambipolar_diffusion_emfy.c:  for (k=1; k<size_z; k++) {
nimhd_ambipolar_diffusion_emfy.c:    for (j=1; j<size_y; j++) {
nimhd_ambipolar_diffusion_emfy.c:      for (i=0; i<size_x; i++) {
nimhd_ambipolar_diffusion_emfy.c:	j3 = 0.25*(jz[ll] + jz[lzm] + jz[lyp] + jz[lyp-stride]);
nimhd_ambipolar_diffusion_emfy.c:	b2 = 0.125*(by[ll] + by[lxm] + by[lzm] + by[lxm-stride] + by[lyp] + by[lxm+pitch] + by[lyp-stride] + by[lxm+pitch-stride]);
nimhd_ambipolar_diffusion_emfy.c:	bmod = b1*b1 + b2*b2 + b3*b3 + eps;
nimhd_ambipolar_diffusion_emfy.c:	etac = 0.25*( eta[ll] + eta[lzm] + eta[lxm] + eta[lxm-stride]);
nimhd_ambipolar_diffusion_emfy.c:#if( defined(CARTESIAN) || defined(SPHERICAL) )
nimhd_ambipolar_diffusion_emfy.c:	emf[ll] += etac*(j2 - (b1*j1+b2*j2+b3*j3)*b2/bmod);
nimhd_ambipolar_diffusion_emfy.c:#endif
nimhd_ambipolar_diffusion_emfy.c:#ifdef CYLINDRICAL
nimhd_ambipolar_diffusion_emfy.c:	emf[ll] -= etac*(j2 - (b1*j1+b2*j2+b3*j3)*b2/bmod); 
nimhd_ambipolar_diffusion_emfy.c:#endif
nimhd_ambipolar_diffusion_emfz.c://#define __GPU
nimhd_ambipolar_diffusion_emfz.c://#define __NOPROTO
nimhd_ambipolar_diffusion_emfz.c:#include "fargo3d.h"
nimhd_ambipolar_diffusion_emfz.c:void AmbipolarDiffusion_emfz_cpu(){
nimhd_ambipolar_diffusion_emfz.c:  real* bx = Bx->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* by = By->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* bz = Bz->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* jx = Jx->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* jy = Jy->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* jz = Jz->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* eta = EtaAD->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  real* emf = Emfz->field_cpu;
nimhd_ambipolar_diffusion_emfz.c:  int stride = Stride_cpu;
nimhd_ambipolar_diffusion_emfz.c:  int size_x = Nx;
nimhd_ambipolar_diffusion_emfz.c:  int size_y = Ny+2*NGHY-1;
nimhd_ambipolar_diffusion_emfz.c:  int size_z = Nz+2*NGHZ-1;
nimhd_ambipolar_diffusion_emfz.c:  real j1;
nimhd_ambipolar_diffusion_emfz.c:  real j2;
nimhd_ambipolar_diffusion_emfz.c:  real j3;
nimhd_ambipolar_diffusion_emfz.c:  real b1;
nimhd_ambipolar_diffusion_emfz.c:  real b2;
nimhd_ambipolar_diffusion_emfz.c:  real b3;
nimhd_ambipolar_diffusion_emfz.c:  real bmod;
nimhd_ambipolar_diffusion_emfz.c:  real etac;
nimhd_ambipolar_diffusion_emfz.c:  real eps = 1e-30;
nimhd_ambipolar_diffusion_emfz.c:  for (k=1; k<size_z; k++) {
nimhd_ambipolar_diffusion_emfz.c:    for (j=1; j<size_y; j++) {
nimhd_ambipolar_diffusion_emfz.c:      for (i=0; i<size_x; i++) {
nimhd_ambipolar_diffusion_emfz.c:	j1 = 0.25*(jx[ll] + jx[lzp] + jx[lxm] + jx[lxm+stride]);
nimhd_ambipolar_diffusion_emfz.c:	b3 = 0.125*(bz[ll] + bz[lym] + bz[lxm] + bz[lxm-pitch] + bz[lzp] + bz[lym+stride] + bz[lxm+stride] + bz[lxm-pitch+stride]);
nimhd_ambipolar_diffusion_emfz.c:	bmod = b1*b1 + b2*b2 + b3*b3 + eps;
nimhd_ambipolar_diffusion_emfz.c:	etac = 0.25*( eta[ll] + eta[lxm] + eta[lym] + eta[lxm-pitch] );
nimhd_ambipolar_diffusion_emfz.c:#if ( defined(CARTESIAN) || defined(SPHERICAL) )    
nimhd_ambipolar_diffusion_emfz.c:       	emf[ll] += etac*(j3 - (b1*j1+b2*j2+b3*j3)*b3/bmod);
nimhd_ambipolar_diffusion_emfz.c:#endif
nimhd_ambipolar_diffusion_emfz.c:#ifdef CYLINDRICAL
nimhd_ambipolar_diffusion_emfz.c:	emf[ll] -= etac*(j3 - (b1*j1+b2*j2+b3*j3)*b3/bmod);
nimhd_ambipolar_diffusion_emfz.c:#endif
nimhd_hall_effect.c://#define __GPU
nimhd_hall_effect.c://#define __NOPROTO
nimhd_hall_effect.c:#include "fargo3d.h"
nimhd_hall_effect.c:void HallEffect(real dt){
nimhd_hall_effect.c:  // We need to reset the EMFs before updating them.
nimhd_hall_effect.c:  FARGO_SAFE(Reset_field(EmfxH));
nimhd_hall_effect.c:  FARGO_SAFE(Reset_field(EmfyH));
nimhd_hall_effect.c:  FARGO_SAFE(Reset_field(EmfzH));
nimhd_hall_effect.c:  // We use as working arrays BxH, ByH, BzH
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(BxH,Bx));
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(ByH,By));
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(BzH,Bz));
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJx());
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJy());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_emfz());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_UpdateB(dt,1,0,0));
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_UpdateB(dt,0,1,0));
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJy());
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJz());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_emfx());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_UpdateB(dt,0,2,0));
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_UpdateB(dt,0,0,1));
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJx());
nimhd_hall_effect.c:  FARGO_SAFE(ComputeJz());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_emfy());
nimhd_hall_effect.c:  FARGO_SAFE(HallEffect_UpdateEmfs());
nimhd_hall_effect.c:  // Once we have the EMFs, we recover the original B
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(Bx,BxH));
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(By,ByH));
nimhd_hall_effect.c:  FARGO_SAFE(copy_field(Bz,BzH));
nimhd_hall_effect_coeff.c://#define __GPU
nimhd_hall_effect_coeff.c://#define __NOPROTO
nimhd_hall_effect_coeff.c:#include "fargo3d.h"
nimhd_hall_effect_coeff.c:void HallEffect_coeff_cpu () {
nimhd_hall_effect_coeff.c:  real* eta  = EtaHall->field_cpu;
nimhd_hall_effect_coeff.c:  real etah  = HALLEFFECTCOEFF;
nimhd_hall_effect_coeff.c:  int stride = Stride_cpu;
nimhd_hall_effect_coeff.c:  int size_x = Nx+2*NGHX;
nimhd_hall_effect_coeff.c:  int size_y = Ny+2*NGHY;
nimhd_hall_effect_coeff.c:  int size_z = Nz+2*NGHZ;
nimhd_hall_effect_coeff.c:#ifdef Z
nimhd_hall_effect_coeff.c:  for (k=0; k<size_z; k++) {
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_coeff.c:#ifdef Y
nimhd_hall_effect_coeff.c:    for (j=0; j<size_y; j++) {
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_coeff.c:#ifdef X
nimhd_hall_effect_coeff.c:      for (i=0; i<size_x; i++ ) {
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_coeff.c:	eta[l] = etah;
nimhd_hall_effect_coeff.c:#ifdef X
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_coeff.c:#ifdef Y
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_coeff.c:#ifdef Z
nimhd_hall_effect_coeff.c:#endif
nimhd_hall_effect_emfx.c://#define __GPU
nimhd_hall_effect_emfx.c://#define __NOPROTO
nimhd_hall_effect_emfx.c:#include "fargo3d.h"
nimhd_hall_effect_emfx.c:void HallEffect_emfx_cpu(){
nimhd_hall_effect_emfx.c:  real* bx = Bx->field_cpu;
nimhd_hall_effect_emfx.c:  real* by = By->field_cpu;
nimhd_hall_effect_emfx.c:  real* bz = Bz->field_cpu;
nimhd_hall_effect_emfx.c:  real* jy = Jy->field_cpu;
nimhd_hall_effect_emfx.c:  real* jz = Jz->field_cpu;
nimhd_hall_effect_emfx.c:  real* emf = EmfxH->field_cpu;
nimhd_hall_effect_emfx.c:  real* eta = EtaHall->field_cpu;
nimhd_hall_effect_emfx.c:  int stride = Stride_cpu;
nimhd_hall_effect_emfx.c:  int size_x = Nx;
nimhd_hall_effect_emfx.c:  int size_y = Ny+2*NGHY-1;
nimhd_hall_effect_emfx.c:  int size_z = Nz+2*NGHZ-1;
nimhd_hall_effect_emfx.c:  real j1;
nimhd_hall_effect_emfx.c:  real j2;
nimhd_hall_effect_emfx.c:  real b1;
nimhd_hall_effect_emfx.c:  real b2;
nimhd_hall_effect_emfx.c:  real b3;
nimhd_hall_effect_emfx.c:  real bmod;
nimhd_hall_effect_emfx.c:  real etac;
nimhd_hall_effect_emfx.c:  real eps = 1.0e-30;
nimhd_hall_effect_emfx.c:  for (k=1; k<size_z; k++) {
nimhd_hall_effect_emfx.c:    for (j=1; j<size_y; j++) {
nimhd_hall_effect_emfx.c:      for (i=0; i<size_x; i++) {
nimhd_hall_effect_emfx.c:	b3 = 0.125*(bx[ll] + bx[lxp] + bx[lzm] + bx[lxp-stride] + bx[lym] + bx[lxp-pitch] + bx[lym-stride] + bx[lxp-pitch-stride]);
nimhd_hall_effect_emfx.c:	bmod = sqrt(b1*b1 + b2*b2 + b3*b3 + eps);
nimhd_hall_effect_emfx.c:	j2 = 0.25*(jz[ll] + jz[lzm] + jz[lxp] + jz[lxp-stride]);
nimhd_hall_effect_emfx.c:	etac = 0.25*(eta[ll]+eta[lym]+eta[lzm]+eta[lym-stride]);
nimhd_hall_effect_emfx.c:#ifdef CYLINDRICAL 
nimhd_hall_effect_emfx.c:	emf[ll]  = etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfx.c:#else
nimhd_hall_effect_emfx.c:	emf[ll]  = -etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfx.c:#endif	
nimhd_hall_effect_emfy.c://#define __GPU
nimhd_hall_effect_emfy.c://#define __NOPROTO
nimhd_hall_effect_emfy.c:#include "fargo3d.h"
nimhd_hall_effect_emfy.c:void HallEffect_emfy_cpu(){
nimhd_hall_effect_emfy.c:  real* bx = Bx->field_cpu;
nimhd_hall_effect_emfy.c:  real* by = By->field_cpu;
nimhd_hall_effect_emfy.c:  real* bz = Bz->field_cpu;
nimhd_hall_effect_emfy.c:  real* jx = Jx->field_cpu;
nimhd_hall_effect_emfy.c:  real* jz = Jz->field_cpu;
nimhd_hall_effect_emfy.c:  real* emf = EmfyH->field_cpu;
nimhd_hall_effect_emfy.c:  real* eta = EtaHall->field_cpu;
nimhd_hall_effect_emfy.c:  int stride = Stride_cpu;
nimhd_hall_effect_emfy.c:  int size_x = Nx;
nimhd_hall_effect_emfy.c:  int size_y = Ny+2*NGHY-1;
nimhd_hall_effect_emfy.c:  int size_z = Nz+2*NGHZ-1;
nimhd_hall_effect_emfy.c:  real j1;
nimhd_hall_effect_emfy.c:  real j2;
nimhd_hall_effect_emfy.c:  real b1;
nimhd_hall_effect_emfy.c:  real b2;
nimhd_hall_effect_emfy.c:  real b3;
nimhd_hall_effect_emfy.c:  real bmod;
nimhd_hall_effect_emfy.c:  real etac;
nimhd_hall_effect_emfy.c:  real eps = 1.0e-30;
nimhd_hall_effect_emfy.c:  for (k=1; k<size_z; k++) {
nimhd_hall_effect_emfy.c:    for (j=1; j<size_y; j++) {
nimhd_hall_effect_emfy.c:      for (i=0; i<size_x; i++) {
nimhd_hall_effect_emfy.c:	j1 = 0.25*(jz[ll] + jz[lzm] + jz[lyp] + jz[lyp-stride]);
nimhd_hall_effect_emfy.c:	b3 = 0.125*(by[ll] + by[lxm] + by[lzm] + by[lxm-stride] + by[lyp] + by[lxm+pitch] + by[lyp-stride] + by[lxm+pitch-stride]);
nimhd_hall_effect_emfy.c:	bmod = sqrt(b1*b1 + b2*b2 + b3*b3 + eps);
nimhd_hall_effect_emfy.c:	etac = 0.25*( eta[ll] + eta[lzm] + eta[lxm] + eta[lxm-stride]);
nimhd_hall_effect_emfy.c:#ifdef CYLINDRICAL
nimhd_hall_effect_emfy.c:	emf[ll] =  etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfy.c:#else
nimhd_hall_effect_emfy.c:	emf[ll] = -etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfy.c:#endif
nimhd_hall_effect_emfz.c://#define __GPU
nimhd_hall_effect_emfz.c://#define __NOPROTO
nimhd_hall_effect_emfz.c:#include "fargo3d.h"
nimhd_hall_effect_emfz.c:void HallEffect_emfz_cpu(){
nimhd_hall_effect_emfz.c:  real* bx = Bx->field_cpu;
nimhd_hall_effect_emfz.c:  real* by = By->field_cpu;
nimhd_hall_effect_emfz.c:  real* bz = Bz->field_cpu;
nimhd_hall_effect_emfz.c:  real* jx = Jx->field_cpu;
nimhd_hall_effect_emfz.c:  real* jy = Jy->field_cpu;
nimhd_hall_effect_emfz.c:  real* emf = EmfzH->field_cpu;
nimhd_hall_effect_emfz.c:  real* eta = EtaHall->field_cpu;
nimhd_hall_effect_emfz.c:  int stride = Stride_cpu;
nimhd_hall_effect_emfz.c:  int size_x = Nx;
nimhd_hall_effect_emfz.c:  int size_y = Ny+2*NGHY-1;
nimhd_hall_effect_emfz.c:  int size_z = Nz+2*NGHZ-1;
nimhd_hall_effect_emfz.c:  real j1;
nimhd_hall_effect_emfz.c:  real j2;
nimhd_hall_effect_emfz.c:  real b1;
nimhd_hall_effect_emfz.c:  real b2;
nimhd_hall_effect_emfz.c:  real b3;
nimhd_hall_effect_emfz.c:  real bmod;
nimhd_hall_effect_emfz.c:  real etac;
nimhd_hall_effect_emfz.c:  real eps = 1.0e-30;
nimhd_hall_effect_emfz.c:  for (k=1; k<size_z; k++) {
nimhd_hall_effect_emfz.c:    for (j=1; j<size_y; j++) {
nimhd_hall_effect_emfz.c:      for (i=0; i<size_x; i++) {
nimhd_hall_effect_emfz.c:	j1 = 0.25*(jx[ll] + jx[lxm] + jx[lzp] + jx[lxm+stride]);
nimhd_hall_effect_emfz.c:	j2 = 0.25*(jy[ll] + jy[lym] + jy[lzp] + jy[lym+stride]);
nimhd_hall_effect_emfz.c:	b3 = 0.125*(bz[ll] + bz[lym] + bz[lxm] + bz[lxm-pitch] + bz[lzp] + bz[lym+stride] + bz[lxm+stride] + bz[lxm-pitch+stride]);
nimhd_hall_effect_emfz.c:	bmod = sqrt(b1*b1 + b2*b2 + b3*b3 + eps);
nimhd_hall_effect_emfz.c:	etac = 0.25*( eta[ll] + eta[lxm] + eta[lym] + eta[lxm-pitch] );
nimhd_hall_effect_emfz.c:#ifdef CYLINDRICAL
nimhd_hall_effect_emfz.c:	emf[ll] =  etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfz.c:#else
nimhd_hall_effect_emfz.c:	emf[ll] = -etac*(j1*b2 - j2*b1)/bmod;
nimhd_hall_effect_emfz.c:#endif
nimhd_hall_effect_updateB.c://#define __GPU
nimhd_hall_effect_updateB.c://#define __NOPROTO
nimhd_hall_effect_updateB.c:#include "fargo3d.h"
nimhd_hall_effect_updateB.c:void HallEffect_UpdateB(real dt,int idx, int idy, int idz) { 
nimhd_hall_effect_updateB.c:  int mutex = 1;
nimhd_hall_effect_updateB.c:  int mutez = 1;
nimhd_hall_effect_updateB.c:  Field* Emf1;
nimhd_hall_effect_updateB.c:  Field* Emf2;
nimhd_hall_effect_updateB.c:  Field* B;
nimhd_hall_effect_updateB.c:  if(idx == 2) {                     //this flag allows Bx to be updated using 
nimhd_hall_effect_updateB.c:    B = Bx;                          //the EmfzH.
nimhd_hall_effect_updateB.c:    mutex = 0;
nimhd_hall_effect_updateB.c:    mutex = 0;
nimhd_hall_effect_updateB.c:  if(idz == 2) {                    //this allow update Bz only with
nimhd_hall_effect_updateB.c:    B = Bz;                         //EmfyH as required Hall algorithm
nimhd_hall_effect_updateB.c:    mutez = 0;
nimhd_hall_effect_updateB.c:  FARGO_SAFE(_HallEffect_UpdateB(dt, mutex, mutez, idx, idy, idz, idx1, idy1, idz1, idx2, idy2, idz2, B, Emf1, Emf2));
nimhd_hall_effect_updateB.c:void _HallEffect_UpdateB_cpu(real dt, int mutex, int mutez,int idx,int idy,int idz,int idx1,int idy1,int idz1, int idx2,int idy2,int idz2,Field* B,Field* Emf1,Field* Emf2) {
nimhd_hall_effect_updateB.c:  real* b    = B->field_cpu; 
nimhd_hall_effect_updateB.c:  real* emf1 = Emf1->field_cpu; 
nimhd_hall_effect_updateB.c:  real* emf2 = Emf2->field_cpu; 
nimhd_hall_effect_updateB.c:  int stride = Stride_cpu;
nimhd_hall_effect_updateB.c:  int size_x = Nx;
nimhd_hall_effect_updateB.c:  int size_y = Ny+2*NGHY-1;
nimhd_hall_effect_updateB.c:  int size_z = Nz+2*NGHZ-1;
nimhd_hall_effect_updateB.c:  real dp1p,dp1m,dp2p,dp2m; 
nimhd_hall_effect_updateB.c:  real surf; 
nimhd_hall_effect_updateB.c:// real xmin(Nx+1);
nimhd_hall_effect_updateB.c:// real ymin(Ny+2*NGHY+1);
nimhd_hall_effect_updateB.c:// real zmin(Nz+2*NGHZ+1);
nimhd_hall_effect_updateB.c:// real Sxi(Nx);
nimhd_hall_effect_updateB.c:// real Sxj(Ny+2*NGHY);
nimhd_hall_effect_updateB.c:// real Syj(Ny+2*NGHY);
nimhd_hall_effect_updateB.c:// real Szj(Ny+2*NGHY);
nimhd_hall_effect_updateB.c:// real Sxk(Nz+2*NGHZ);
nimhd_hall_effect_updateB.c:// real Syk(Nz+2*NGHZ);
nimhd_hall_effect_updateB.c:// real Szk(Nz+2*NGHZ);
nimhd_hall_effect_updateB.c:  for (k=1; k<size_z; k++) { 
nimhd_hall_effect_updateB.c:    for (j=1; j<size_y; j++) { 
nimhd_hall_effect_updateB.c:      for (i=XIM; i<size_x; i++) {
nimhd_hall_effect_updateB.c:	dp1m = (edge_size_x(i,j,k)*idx2 +
nimhd_hall_effect_updateB.c: 		edge_size_y(j,k)*idy2 +
nimhd_hall_effect_updateB.c:		edge_size_z(j,k)*idz2); 
nimhd_hall_effect_updateB.c:	dp1p = (edge_size_x(i,j+idy1,k+idz1)*idx2 + 
nimhd_hall_effect_updateB.c:		edge_size_y(j+idy1,k+idz1)*idy2 + 
nimhd_hall_effect_updateB.c:		edge_size_z(j+idy1,k+idz1)*idz2); 
nimhd_hall_effect_updateB.c:	dp2m = (edge_size_x(i,j,k)*idx1 + 
nimhd_hall_effect_updateB.c:		edge_size_y(j,k)*idy1 + 
nimhd_hall_effect_updateB.c:		edge_size_z(j,k)*idz1); 
nimhd_hall_effect_updateB.c:	dp2p = (edge_size_x(i,j+idy2,k+idz2)*idx1 + 
nimhd_hall_effect_updateB.c:		edge_size_y(j+idy2,k+idz2)*idy1 + 
nimhd_hall_effect_updateB.c:		edge_size_z(j+idy2,k+idz2)*idz1); 
nimhd_hall_effect_updateB.c:	b[l] += dt/surf * (  (emf1[lp2]*dp2p - emf1[l]*dp2m)*mutez
nimhd_hall_effect_updateB.c:			   - (emf2[lp1]*dp1p - emf2[l]*dp1m)*mutex);
nimhd_hall_effect_update_emfs.c://#define __GPU
nimhd_hall_effect_update_emfs.c://#define __NOPROTO
nimhd_hall_effect_update_emfs.c:#include "fargo3d.h"
nimhd_hall_effect_update_emfs.c:void HallEffect_UpdateEmfs_cpu(){
nimhd_hall_effect_update_emfs.c:  real* emfx = Emfx->field_cpu;
nimhd_hall_effect_update_emfs.c:  real* emfy = Emfy->field_cpu;
nimhd_hall_effect_update_emfs.c:  real* emfz = Emfz->field_cpu;
nimhd_hall_effect_update_emfs.c:  real* emfxH = EmfxH->field_cpu;
nimhd_hall_effect_update_emfs.c:  real* emfyH = EmfyH->field_cpu;
nimhd_hall_effect_update_emfs.c:  real* emfzH = EmfzH->field_cpu;
nimhd_hall_effect_update_emfs.c:  int stride = Stride_cpu;
nimhd_hall_effect_update_emfs.c:  int size_x = Nx;
nimhd_hall_effect_update_emfs.c:  int size_y = Ny+2*NGHY-1;
nimhd_hall_effect_update_emfs.c:  int size_z = Nz+2*NGHZ-1;
nimhd_hall_effect_update_emfs.c:  for (k=1; k<size_z; k++) {
nimhd_hall_effect_update_emfs.c:    for (j=1; j<size_y; j++) {
nimhd_hall_effect_update_emfs.c:      for (i=0; i<size_x; i++) {
nimhd_hall_effect_update_emfs.c:	emfx[ll] += emfxH[ll];
nimhd_hall_effect_update_emfs.c:	emfy[ll] += emfyH[ll];
nimhd_hall_effect_update_emfs.c:       	emfz[ll] += emfzH[ll];      
nimhd_ohmic_diffusion.c://#define __GPU
nimhd_ohmic_diffusion.c://#define __NOPROTO
nimhd_ohmic_diffusion.c:#include "fargo3d.h"
nimhd_ohmic_diffusion.c:  FARGO_SAFE(OhmicDiffusion_emf(1,0,0));
nimhd_ohmic_diffusion.c:  FARGO_SAFE(OhmicDiffusion_emf(0,1,0));
nimhd_ohmic_diffusion.c:  FARGO_SAFE(OhmicDiffusion_emf(0,0,1));
nimhd_ohmic_diffusion.c:void OhmicDiffusion_emf(int idx, int idy, int idz) {
nimhd_ohmic_diffusion.c:  Field *B1;
nimhd_ohmic_diffusion.c:  Field *B2;
nimhd_ohmic_diffusion.c:  Field *Emf;
nimhd_ohmic_diffusion.c:  FARGO_SAFE(_OhmicDiffusion_emf(idx, idy, idz, idx1, idy1, idz1, idx2, idy2, idz2, B1, B2, Emf));
nimhd_ohmic_diffusion.c:void _OhmicDiffusion_emf_cpu (int idx, int idy, int idz, int idx1, int idy1, int idz1, int idx2, int idy2, int idz2, Field *B1, Field *B2, Field *Emf) {
nimhd_ohmic_diffusion.c:  real* b1 = B1->field_cpu;
nimhd_ohmic_diffusion.c:  real* b2 = B2->field_cpu;
nimhd_ohmic_diffusion.c:  real* emf = Emf->field_cpu;
nimhd_ohmic_diffusion.c:  real* eta = EtaOhm->field_cpu;
nimhd_ohmic_diffusion.c:  int stride = Stride_cpu;
nimhd_ohmic_diffusion.c:  int size_x = XIP; 
nimhd_ohmic_diffusion.c:  int size_y = Ny+2*NGHY-1;
nimhd_ohmic_diffusion.c:  int size_z = Nz+2*NGHZ-1;
nimhd_ohmic_diffusion.c:  real diff1;
nimhd_ohmic_diffusion.c:  real diff2;
nimhd_ohmic_diffusion.c:// real xmin(Nx);
nimhd_ohmic_diffusion.c:// real ymin(Ny+2*NGHY+1);
nimhd_ohmic_diffusion.c:// real zmin(Nz+2*NGHZ+1);
nimhd_ohmic_diffusion.c:  for (k=1; k<size_z; k++) {
nimhd_ohmic_diffusion.c:    for (j=1; j<size_y; j++) {
nimhd_ohmic_diffusion.c:      for (i=XIM; i<size_x; i++) {
nimhd_ohmic_diffusion.c:	/* Ideally it should not be the zone size but the distance
nimhd_ohmic_diffusion.c:	   between zone centers. The different is very minute here and
nimhd_ohmic_diffusion.c:	   does not matter */
nimhd_ohmic_diffusion.c:	diff1 = zone_size_x(i,j,k)*idx1+zone_size_y(j,k)*idy1+zone_size_z(j,k)*idz1;
nimhd_ohmic_diffusion.c:	diff2 = zone_size_x(i,j,k)*idx2+zone_size_y(j,k)*idy2+zone_size_z(j,k)*idz2;
nimhd_ohmic_diffusion.c:	//Warning: staggering of eta can be improved. 
nimhd_ohmic_diffusion.c:	emf[ll] += eta[ll]*((b2[ll]-b2[l1m])/diff1-(b1[ll]-b1[l2m])/diff2);
nimhd_ohmic_diffusion.c:#ifdef CYLINDRICAL
nimhd_ohmic_diffusion.c:	if (idz1+idz2 == 0) // Considering vertical component of Emf
nimhd_ohmic_diffusion.c:	  emf[ll] -= eta[ll]*(b1[ll]+b1[l2m])*.5/ymin(j); 
nimhd_ohmic_diffusion.c://Note that (phi,r,z) has a left-handed orientation.
nimhd_ohmic_diffusion.c:#endif
nimhd_ohmic_diffusion.c:#ifdef SPHERICAL
nimhd_ohmic_diffusion.c:	if (idy1+idy2 == 0) // Considering radial component of Emf
nimhd_ohmic_diffusion.c:	  emf[ll] += eta[ll]*(b2[ll]+b2[l1m])*.5/ymed(j)*cos(zmin(k))/sin(zmin(k));
nimhd_ohmic_diffusion.c:	if (idz1+idz2 == 0) // Considering colatitude component of Emf
nimhd_ohmic_diffusion.c:	  emf[ll] -= eta[ll]*(b1[ll]+b1[l2m])*.5/ymin(j);
nimhd_ohmic_diffusion.c:	if (idx1+idx2 == 0) // Considering azimuthal component of Emf
nimhd_ohmic_diffusion.c:	  emf[ll] += eta[ll]*(b2[ll]+b2[l1m])*.5/ymin(j);
nimhd_ohmic_diffusion.c:#endif
nimhd_ohmic_diffusion_coeff.c://#define __GPU
nimhd_ohmic_diffusion_coeff.c://#define __NOPROTO
nimhd_ohmic_diffusion_coeff.c:#include "fargo3d.h"
nimhd_ohmic_diffusion_coeff.c:void OhmicDiffusion_coeff_cpu() {
nimhd_ohmic_diffusion_coeff.c:  real* eta  = EtaOhm->field_cpu;
nimhd_ohmic_diffusion_coeff.c:  real etao  = OHMICDIFFUSIONCOEFF;
nimhd_ohmic_diffusion_coeff.c:  int stride = Stride_cpu;
nimhd_ohmic_diffusion_coeff.c:  int size_x = Nx+2*NGHX;
nimhd_ohmic_diffusion_coeff.c:  int size_y = Ny+2*NGHY;
nimhd_ohmic_diffusion_coeff.c:  int size_z = Nz+2*NGHZ;
nimhd_ohmic_diffusion_coeff.c:#ifdef Z
nimhd_ohmic_diffusion_coeff.c:  for (k=0; k<size_z; k++) {
nimhd_ohmic_diffusion_coeff.c:#endif
nimhd_ohmic_diffusion_coeff.c:#ifdef Y
nimhd_ohmic_diffusion_coeff.c:    for (j=0; j<size_y; j++) {
nimhd_ohmic_diffusion_coeff.c:#endif
nimhd_ohmic_diffusion_coeff.c:#ifdef X
nimhd_ohmic_diffusion_coeff.c:      for (i=0; i<size_x; i++ ) {
nimhd_ohmic_diffusion_coeff.c:#endif
nimhd_ohmic_diffusion_coeff.c:	  eta[l] = etao;
nimhd_ohmic_diffusion_coeff.c:#ifdef X
nimhd_ohmic_diffusion_coeff.c:#endif
nimhd_ohmic_diffusion_coeff.c:#ifdef Y
nimhd_ohmic_diffusion_coeff.c:#endif
nimhd_ohmic_diffusion_coeff.c:#ifdef Z
nimhd_ohmic_diffusion_coeff.c:#endif
output.c:#include "fargo3d.h"
output.c:void SelectWriteMethod() {
output.c:  __WriteField = WriteFieldGhost;
output.c:#if !defined(WRITEGHOSTS)
output.c:  masterprint ("I do not output the ghost values\n");
output.c:  __WriteField = WriteField;
output.c:  if (Merge) {
output.c:    __WriteField = WriteMerging;
output.c:#endif
output.c:    __WriteField = WriteVTK;
output.c:    if (Merge) {
output.c:      __WriteField = WriteVTKMerging;
output.c:    __WriteField = WriteVTKMerging;
output.c:    __WriteField = WriteMerging;
output.c:void EmptyPlanetSystemFiles () {
output.c:  char name[256];
output.c:  if (Sys == NULL) return;
output.c:  if (!CPU_Master) return;
output.c:    sprintf (name, "%splanet%d.dat", OUTPUTDIR, i);
output.c:    output = fopen_prs(name, "w"); /* This empties the file */
output.c:    fclose (output);
output.c:void WritePlanetFile (int TimeStep, int n, boolean big) {
output.c:  char name[256];
output.c:  if (Sys == NULL) return;
output.c:  if (!CPU_Master) return;
output.c:  //  printf ("Updating 'planet%d.dat'...", n);
output.c:    sprintf (name, "%sbigplanet%d.dat", OUTPUTDIR, n);
output.c:  else
output.c:    sprintf (name, "%splanet%d.dat", OUTPUTDIR, n);
output.c:  output = fopen_prs (name, "a");
output.c:	   TimeStep,
output.c:	   Xplanet,
output.c:	   Yplanet,
output.c:	   Zplanet,
output.c:	   VXplanet,
output.c:	   VYplanet,
output.c:	   VZplanet,
output.c:	   MplanetVirtual,
output.c:	   PhysicalTime,
output.c:  fclose (output);
output.c:  //printf ("done\n");
output.c:real GetfromPlanetFile (int TimeStep, int column, int n) {
output.c:  char name[256];
output.c:  char testline[256];
output.c:  int time;
output.c:  double value;
output.c:  sprintf (name, "%splanet%d.dat", OUTPUTDIR, n);
output.c:  input = fopen (name, "r");
output.c:    mastererr ("Can't read 'planet%d.dat' file. Aborting restart.\n",n);
output.c:    prs_exit (1);
output.c:    mastererr ("Invalid column number in 'planet%d.dat'. Aborting restart.\n",n);
output.c:    prs_exit (1);
output.c:    pt = fgets (testline, 255, input);
output.c:    sscanf (testline, "%d", &time);
output.c:  } while ((time != TimeStep) && (pt != NULL));
output.c:    mastererr ("Can't read entry %d in 'planet%d.dat' file. Aborting restart.\n", TimeStep,n);
output.c:    prs_exit (1);
output.c:  fclose (input);
output.c:  pt = testline;
output.c:  while (column > 1) {
output.c:    pt += strspn(pt, "eE0123456789-+.");
output.c:  sscanf (pt, "%lf", &value);
output.c:  return (real)value;
output.c:void RestartPlanetarySystem (int timestep, PlanetarySystem *sys){
output.c:    sys->x[k] = GetfromPlanetFile (timestep, 2, k);
output.c:    sys->y[k] = GetfromPlanetFile (timestep, 3, k);
output.c:    sys->z[k] = GetfromPlanetFile (timestep, 4, k);
output.c:    sys->vx[k] = GetfromPlanetFile (timestep, 5, k);
output.c:    sys->vy[k] = GetfromPlanetFile (timestep, 6, k);
output.c:    sys->vz[k] = GetfromPlanetFile (timestep, 7, k);
output.c:    sys->mass[k] = GetfromPlanetFile (timestep, 8, k);
output.c:void WriteTorqueAndWork(int TimeStep, int n) {
output.c:  char name[256];
output.c:  Force force;
output.c:  real x,y,z;
output.c:  real vx,vy,vz;
output.c:  real m,r,smoothing;
output.c:  if (Sys == NULL) return;
output.c:  else
output.c:  force = ComputeForce(x,y,z,smoothing,m);
output.c:  sprintf (name, "%stqwk%d.dat", OUTPUTDIR, n);
output.c:  else
output.c:  if (!CPU_Master) return;
output.c:  output = fopen_prs (name, "a");
output.c:	   TimeStep,
output.c:	   x*force.fy_inner-y*force.fx_inner,
output.c:	   x*force.fy_outer-y*force.fx_outer,
output.c:	   x*force.fy_ex_inner-y*force.fx_ex_inner,
output.c:	   x*force.fy_ex_outer-y*force.fx_ex_outer,
output.c:	   vx*force.fx_inner+vy*force.fy_inner,
output.c:	   vx*force.fx_outer+vy*force.fy_outer,
output.c:	   vx*force.fx_ex_inner+vy*force.fy_ex_inner,
output.c:	   vx*force.fx_ex_outer+vy*force.fy_ex_outer,
output.c:	   PhysicalTime);
output.c:  fclose (output);
output.c:void WritePlanetSystemFile (int t, boolean big) {
output.c:  if (Sys == NULL) return;
output.c:    Xplanet  = Sys->x[i];
output.c:    Yplanet  = Sys->y[i];
output.c:    Zplanet  = Sys->z[i];
output.c:    VXplanet = Sys->vx[i];
output.c:    VYplanet = Sys->vy[i];
output.c:    VZplanet = Sys->vz[i];
output.c:    MplanetVirtual = Sys->mass[i];
output.c:    WriteTorqueAndWork(t, i);
output.c:    WritePlanetFile (t, i, big);
output.c:void WriteDim () {
output.c:  char filename[200];
output.c:  int temp;
output.c:#ifdef DEBUG
output.c:    sprintf(filename, "%sdimensions.dat", OUTPUTDIR);
output.c:    dims = fopen(filename, "w");
output.c:    fclose(dims);
output.c:#endif
output.c:#ifdef LEGACY
output.c:    sprintf(filename, "%sdims.dat", OUTPUTDIR);
output.c:    dims = fopen(filename, "w");
output.c:    fclose(dims);
output.c:    sprintf (command, "cp %sdomain_y.dat %stemprad", OUTPUTDIR, OUTPUTDIR);
output.c:    temp = system (command);
output.c:    sprintf (command, "tail -n %d %stemprad | head -n %d > %sused_rad.dat",NY+1+NGHY,\
output.c:    temp = system (command);
output.c:    sprintf (command, "rm -f %stemprad", OUTPUTDIR);
output.c:    temp = system (command);
output.c:#endif
output.c:void WriteField2D(Field2D *f, int n) {
output.c:  char filename[200];
output.c:  sprintf(filename, "%s%s%d_%d.dat", OUTPUTDIR, f->name, n, CPU_Rank);
output.c:  fo = fopen(filename,"w");
output.c:  fwrite(f->field_cpu, sizeof(real), (Ny+2*NGHY)*(Nz+2*NGHZ), fo);
output.c:  fclose(fo);
output.c:void WriteFieldInt2D(FieldInt2D *f, int n) {
output.c:  char filename[200];
output.c:  sprintf(filename, "%s%s%d_%d.dat", OUTPUTDIR, f->name, n, CPU_Rank);
output.c:  fo = fopen(filename,"w");
output.c:  fwrite(f->field_cpu, sizeof(int), (Ny+2*NGHY)*(Nz+2*NGHZ), fo);
output.c:  fclose(fo);
output.c:void WriteField(Field *f, int n) {
output.c:  char filename[200];
output.c:  sprintf(filename, "%s%s%d_%d.dat", OUTPUTDIR, f->name, n, CPU_Rank);
output.c:  fo = fopen(filename,"w");
output.c:  for (k=NGHZ; k<Nz+NGHZ; k++) { //Write grid without ghost cells
output.c:      fwrite(f->field_cpu+j*(Nx+2*NGHX)+k*Stride+NGHX, sizeof(real), Nx, fo);
output.c:  fclose(fo);
output.c:void WriteFieldGhost(Field *f, int n) { // Diagnostic function
output.c:  char filename[200];
output.c:  sprintf(filename, "%s%s%d_%d.dat", OUTPUTDIR, f->name, n, CPU_Rank);
output.c:  fo = fopen(filename,"w");
output.c:  for (k=0; k<Nz+2*NGHZ; k++) { //Write grid with ghost cells
output.c:      fwrite(f->field_cpu+j*(Nx+2*NGHX)+k*Stride, sizeof(real), Nx+2*NGHX, fo);
output.c:  fclose(fo);
output.c:void WriteMerging(Field *f, int n) {
output.c:  char outname[MAXLINELENGTH];
output.c:  int relay;
output.c:  sprintf(outname, "%s%s%d.dat", OUTPUTDIR, f->name, n);
output.c:  if (CPU_Rank > 0) // Force sequential write
output.c:    MPI_Recv (&relay, 1, MPI_INT, CPU_Rank-1, 42, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
output.c:  if (CPU_Master) fo = fopen(outname, "w");
output.c:  else            fo = fopen(outname, "r+");
output.c:  long offset = Nx*Y0 + Nx*NY*Z0;
output.c:    fseek(fo, offset*sizeof(real), SEEK_SET);
output.c:      fwrite(f->field_cpu+k*Stride+j*(Nx+2*NGHX)+NGHX, sizeof(real)*Nx, 1, fo);
output.c:    offset += (Nx+2*NGHX)*NY;
output.c:  fclose(fo);
output.c:  if (CPU_Rank < CPU_Number-1)  // Force sequential write
output.c:    MPI_Send (&relay, 1, MPI_INT, CPU_Rank+1, 42, MPI_COMM_WORLD);
output.c:void Write_offset(int file_offset, char* fieldname, char* fluidname){
output.c:  char filename[MAXNAMELENGTH];
output.c:  if(CPU_Master){
output.c:    sprintf(filename, "%s/output%s.dat", OUTPUTDIR, fluidname);
output.c:    fp = fopen(filename,"a");
output.c:    fprintf(fp, "%d\t%s\n", file_offset, fieldname);
output.c:    fclose(fp);
output.c:#ifdef MPIIO
output.c:MPI_Offset ParallelIO(Field *field, int n, int mode, MPI_Offset file_offset, int writeoffset) {
output.c:  INPUT(field);
output.c:  char filename[MAXNAMELENGTH];
output.c:  //subarray of memory (fields)
output.c:  MPI_Datatype mpi_memtype;
output.c:  int mem_global_size[3]; 
output.c:  int mem_local_size[3];
output.c:  int mem_start[3];
output.c:  //subarray of file (fields)
output.c:  MPI_Datatype mpi_filetype;
output.c:  int file_global_size[3];
output.c:  int file_local_size[3];
output.c:  int file_start[3];
output.c:  MPI_File mpi_file;
output.c:  sprintf(filename, "%s%s_%d.mpiio", OUTPUTDIR, Fluids[FluidIndex]->name, n);
output.c:  //Setting memory space per rank
output.c:  mem_global_size[0] = Nz+2*NGHZ;
output.c:  mem_global_size[1] = Ny+2*NGHY;
output.c:  mem_global_size[2] = Nx;
output.c:#if !defined(WRITEGHOSTS)
output.c:  mem_local_size[0] = Nz;
output.c:  mem_local_size[1] = Ny;
output.c:  mem_local_size[2] = Nx;
output.c:  mem_start[0] = NGHZ;
output.c:  mem_start[1] = NGHY;
output.c:  mem_start[2] = NGHX;
output.c:#else
output.c:  if (CPU_Number>1) {
output.c:    mastererr("This version doesn't write ghosts in the parallel version.\n");
output.c:    exit(1);
output.c:  mem_local_size[0] = Nz+2*NGHZ;
output.c:  mem_local_size[1] = Ny+2*NGHY;
output.c:  mem_local_size[2] = Nx+2*NGHX;
output.c:  mem_start[0] = 0;
output.c:  mem_start[1] = 0;
output.c:  mem_start[2] = 0;
output.c:#endif
output.c:  MPI_Type_create_subarray(3, mem_global_size, mem_local_size, mem_start,  
output.c:			   MPI_ORDER_C, MPI_DOUBLE, &mpi_memtype);
output.c:  MPI_Type_commit(&mpi_memtype);
output.c:  //Setting file space
output.c:#if !defined(WRITEGHOSTS)
output.c:  file_global_size[0] = NZ;
output.c:  file_global_size[1] = NY;
output.c:  file_global_size[2] = NX;
output.c:  file_local_size[0] = Nz;
output.c:  file_local_size[1] = Ny;
output.c:  file_local_size[2] = Nx;
output.c:#else
output.c:  file_global_size[0] = NZ+2*NGHZ;
output.c:  file_global_size[1] = NY+2*NGHY;
output.c:  file_global_size[2] = NX+2*NGHX;
output.c:  file_local_size[0] = Nz+2*NGHZ;
output.c:  file_local_size[1] = Ny+2*NGHY;
output.c:  file_local_size[2] = Nx+2*NGHX;
output.c:#endif
output.c:  file_start[0] = Z0;
output.c:  file_start[1] = Y0;
output.c:  file_start[2] = 0;
output.c:  MPI_Type_create_subarray(3, file_global_size, file_local_size, file_start,  
output.c:			   MPI_ORDER_C, MPI_DOUBLE, &mpi_filetype);
output.c:  MPI_Type_commit(&mpi_filetype);
output.c:  MPI_File_open(MPI_COMM_WORLD, filename, mode, MPI_INFO_NULL, &mpi_file);
output.c:  //We write the only at the begining of the file
output.c:  if (file_offset == 0) {
output.c:    if (mode & MPI_MODE_WRONLY) {
output.c:      if (CPU_Master)
output.c:	MPI_File_write_at(mpi_file, 0, Xmin, NX+1, MPI_DOUBLE, &status);
output.c:    else {
output.c:      MPI_File_read_at(mpi_file, 0, Xmin, NX+1, MPI_DOUBLE, &status);
output.c:    file_offset += NX+1;
output.c:    if (mode & MPI_MODE_WRONLY) {
output.c:	  MPI_File_write_at(mpi_file, (file_offset+Y0)*sizeof(real),
output.c:	else
output.c:	  MPI_File_write_at(mpi_file, (file_offset+Y0)*sizeof(real),
output.c:      file_offset += NY+1;
output.c:	  MPI_File_write_at(mpi_file, (file_offset+Z0)*sizeof(real),
output.c:	else
output.c:	  MPI_File_write_at(mpi_file, (file_offset+Z0)*sizeof(real),
output.c:      file_offset += (NZ+1);
output.c:    else { //If LOADFIELDS
output.c:	MPI_File_read_at(mpi_file, (file_offset+Y0)*sizeof(real),
output.c:      else
output.c:	MPI_File_read_at(mpi_file, (file_offset+Y0)*sizeof(real),
output.c:    file_offset += NY+1;
output.c:      MPI_File_read_at(mpi_file, (file_offset+Z0)*sizeof(real),
output.c:    else
output.c:      MPI_File_read_at(mpi_file, (file_offset+Z0)*sizeof(real),
output.c:    file_offset += (NZ+1);
output.c:  //We append more fields on the same file
output.c:  MPI_File_set_view(mpi_file, file_offset*sizeof(real), MPI_DOUBLE, mpi_filetype,
output.c:		    "native", MPI_INFO_NULL);
output.c:  if (mode & MPI_MODE_WRONLY)
output.c:    MPI_File_write_all(mpi_file, field->field_cpu, 1,
output.c:		       mpi_memtype, &status);
output.c:  else
output.c:    MPI_File_read_all(mpi_file, field->field_cpu, 1,
output.c:		      mpi_memtype, &status);
output.c:  if(writeoffset == TRUE ) Write_offset(file_offset, field->name, Fluids[FluidIndex]->name);  
output.c:#if !defined(WRITEGHOSTS)
output.c:  file_offset += NX*NY*NZ;
output.c:#else
output.c:  file_offset += (NX+2*NGHX)*(NY+2*NGHY)*(NZ+2*NGHZ);
output.c:#endif
output.c:  MPI_File_close(&mpi_file);
output.c:  return file_offset;
output.c:#endif
output.c:void WriteBinFile(int n1, int n2, int n3,	\
output.c:		  real *var1, char *filename) {
output.c:  int ntemp; 
output.c:  F = fopen(filename,"w"); 
output.c:  if(F == NULL) prs_exit(1);
output.c:  static boolean init=TRUE;
output.c:    var = (float*)malloc(sizeof(float)*n1*n2*n3);
output.c:  ntemp = 12;
output.c:  fwrite(&ntemp,4,1,F);
output.c:  fwrite(&n1,4,1,F);
output.c:  fwrite(&n2,4,1,F);
output.c:  fwrite(&n3,4,1,F);
output.c:  fwrite(&ntemp,4,1,F);
output.c:  ntemp = n1*n2*n3*sizeof(float);
output.c:  fwrite(&ntemp,4,1,F); fwrite(var,sizeof(float)*n1*n2*n3,1,F); fwrite(&ntemp,4,1,F);
output.c:  fclose(F);
output.c:void DumpAllFields (int number) {
output.c:  Field *current;
output.c:  current = ListOfGrids;
output.c:  printf ("Dumping at #%d\t", number);
output.c:  while (current != NULL) {
output.c:    if (*(current->owner) == current) {
output.c:	printf ("%s ", current->name);
output.c:      __WriteField (current, number);
output.c:    current = current->next;
output.c:void WriteOutputs(int type) {
output.c: /* If type=ALL, all fields are dumped (This is the old fashion
output.c:     style). If type=SPECIFIC, this routine only dumps specific
output.c:     fields, given by the .par variables WRITE+FIELD. By default all
output.c:     WRITE parameters are NO. */ 
output.c:  boolean writedensity;
output.c:  boolean writeenergy;
output.c:  boolean writedivergence;
output.c:  boolean writebx;
output.c:  boolean writeby;
output.c:  boolean writebz;
output.c:  boolean writevx;
output.c:  boolean writevy;
output.c:  boolean writevz;
output.c:  boolean writeenergyrad;
output.c:  boolean writetau;
output.c:  static int writeoffset = TRUE;
output.c:  static int counter = 0;
output.c:  MPI_Offset offset;
output.c:  char filename[MAXNAMELENGTH];
output.c:  Summary (TimeStep);
output.c:  if (type == ALL){ //We store the .par variables' value for a while.
output.c:    writedensity = WRITEDENSITY;
output.c:    writeenergy = WRITEENERGY;
output.c:    writebx = WRITEBX;
output.c:    writeby = WRITEBY;
output.c:    writebz = WRITEBZ;
output.c:    writevx = WRITEVX;
output.c:    writevy = WRITEVY;
output.c:    writevz = WRITEVZ;
output.c:    writeenergyrad = WRITEENERGYRAD;
output.c:    writetau = WRITETAU;
output.c:  else {
output.c:      MakeDir(OUTPUTDIR);
output.c:  // we truncate the output.dat file
output.c:  if(CPU_Master && (writeoffset == TRUE)) {
output.c:    sprintf(filename, "%s/output%s.dat", OUTPUTDIR, Fluids[FluidIndex]->name);
output.c:    fp = fopen(filename,"w");
output.c:    fclose(fp);
output.c:  /// MPIIO ouput version
output.c:#ifdef MPIIO
output.c:  offset = 0; //We start at the begining of the file  
output.c:    offset = ParallelIO(Density, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:        if(Fluidtype != DUST) offset = ParallelIO(Energy, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:#ifdef X
output.c:    offset = ParallelIO(Vx, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:#endif
output.c:#ifdef Y
output.c:    offset = ParallelIO(Vy, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:#endif
output.c:#ifdef Z
output.c:    offset = ParallelIO(Vz, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:#endif
output.c:#ifdef MHD //MHD is 3D.
output.c:  if(Fluidtype == GAS){
output.c:      offset = ParallelIO(Bx, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:      offset = ParallelIO(By, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:      offset = ParallelIO(Bz, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:      offset = ParallelIO(Divergence, TimeStep, MPI_MODE_WRONLY|MPI_MODE_CREATE, offset,writeoffset);
output.c:#endif
output.c:  if (counter < 2*NFLUIDS) {
output.c:      if (counter == NFLUIDS-1 || Restart == YES || Restart_Full == YES) {
output.c:	writeoffset = FALSE;
output.c:    else {
output.c:      if (counter == 2*NFLUIDS-1 || Restart == YES || Restart_Full == YES) {
output.c:	writeoffset = FALSE;
output.c:    counter += 1;
output.c:#endif
output.c:  /// Standard ouput version
output.c:#ifndef MPIIO
output.c:    __WriteField(Density, TimeStep);
output.c:    if(Fluidtype != DUST) __WriteField(Energy, TimeStep);
output.c:#ifdef MHD //MHD is 3D.
output.c:  if(Fluidtype == GAS){
output.c:      __WriteField(Divergence,TimeStep);
output.c:      __WriteField(Bx, TimeStep);
output.c:      __WriteField(By, TimeStep);
output.c:      __WriteField(Bz, TimeStep);
output.c:#endif
output.c:#ifdef X
output.c:    __WriteField(Vx, TimeStep);
output.c:#endif
output.c:#ifdef Y
output.c:    __WriteField(Vy, TimeStep);
output.c:#endif
output.c:#ifdef Z
output.c:    __WriteField(Vz, TimeStep);
output.c:#endif
output.c:#endif
output.c:if (type == ALL){ //We recover the .par variables' value
output.c:    WRITEDENSITY = writedensity;
output.c:    WRITEENERGY = writeenergy;
output.c:    WRITEBX = writebx;
output.c:    WRITEBY = writeby;
output.c:    WRITEBZ = writebz;
output.c:    WRITEVX = writevx;
output.c:    WRITEVY = writevy;
output.c:    WRITEVZ = writevz;
output.c:    prs_exit(EXIT_SUCCESS);
output.c:    prs_exit(EXIT_SUCCESS);
output.c: if (type != ALL)
output.c:    prs_exit(EXIT_SUCCESS);
output2d.c:#include "fargo3d.h"
output2d.c:void Write2D (Field2D *f, char *filename, char *dir, int kind) {
output2d.c:  real profile[MAX1D], gprofile[MAX1D], value;
output2d.c:  char name[MAXLINELENGTH];
output2d.c:  sprintf (name, "%s/%s", dir, filename);
output2d.c:  out = fopen_prs (name, "w");
output2d.c:      profile[jg] = gprofile[jg] = 0.0;
output2d.c:      j = jg-y0cell;
output2d.c:      k = kg-z0cell;
output2d.c:	value = f->field_cpu[l2D];
output2d.c:	profile[jg] = value;
output2d.c:      // In the tests below we deal with the different kinds of ghosts if we have to dump them
output2d.c:	if ((j < NGHY) && (Gridd.J == 0) && (k >= NGHZ) && (k < NGHZ+Nz)) //Left edge
output2d.c:	  profile[jg] = value;
output2d.c:	if ((j >= NGHY+Ny) && (Gridd.J == Gridd.NJ-1) && (k >= NGHZ) && (k < NGHZ+Nz)) //Right edge
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k < NGHZ) && (Gridd.K == 0) && (j >= NGHY) && (j < NGHY+Ny)) //Bottom edge
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k >= NGHZ+Nz) && (Gridd.K == Gridd.NK-1) && (j >= NGHY) && (j < NGHY+Ny)) //Top edge
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k < NGHZ) && (Gridd.K == 0) && (j < NGHY) && (Gridd.J == 0)) //Bottom-left corner
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k >= NGHZ+Nz) && (Gridd.K == Gridd.NK-1) && (j < NGHY) && (Gridd.J == 0)) //Top-left corner
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k < NGHZ) && (Gridd.K == 0) && (j >= Ny+NGHY) && (Gridd.J == Gridd.NJ-1)) //Bottom-right corner
output2d.c:	  profile[jg] = value;
output2d.c:	if ((k >= NGHZ+Nz) && (Gridd.K == Gridd.NK-1) && (j >= Ny+NGHY) && (Gridd.J == Gridd.NJ-1)) //Top-right corner
output2d.c:	  profile[jg] = value;
output2d.c:#ifndef FLOAT
output2d.c:    MPI_Reduce (profile, gprofile, NY+2*NGHY, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
output2d.c:#else
output2d.c:    MPI_Reduce (profile, gprofile, NY+2*NGHY, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);
output2d.c:#endif
output2d.c:	fwrite (gprofile+NGHY, sizeof(real), NY, out);
output2d.c:	fwrite (gprofile, sizeof(real), NY+2*NGHY, out);
output2d.c:  fclose (out);
output2d.c:boolean Read2D (Field2D *f, char *filename, char *dir, int kind) {
output2d.c:  real profile[MAX1D], gprofile[MAX1D], value;
output2d.c:  char name[MAXLINELENGTH];
output2d.c:  boolean error_occured=FALSE;
output2d.c:  int relay, filesize, sz;
output2d.c:  filesize = (2*NGHZ+NZ)*(2*NGHY+NY)*sizeof(real);
output2d.c:    filesize = NZ*NY*sizeof(real);
output2d.c:  sprintf (name, "%s/%s", dir, filename);
output2d.c:  if (CPU_Rank > 0) { // Force sequential read
output2d.c:    MPI_Recv (&relay, 1, MPI_INT, CPU_Rank-1, 42, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
output2d.c:  in = fopen (name, "r");
output2d.c:    error_occured = TRUE;
output2d.c:  } else {
output2d.c:    fseek (in, 0, SEEK_END);
output2d.c:    sz = ftell(in);
output2d.c:    fseek (in, 0, SEEK_SET);
output2d.c:    // We check that the file has the right size in order to avoid reading an older file
output2d.c:    if (sz != filesize) error_occured = TRUE; 
output2d.c:	if (fread (gprofile+NGHY, sizeof(real), NY, in) == 0) error_occured = TRUE;
output2d.c:	if (fread (gprofile, sizeof(real), NY+2*NGHY, in) == 0) error_occured = TRUE;
output2d.c:	j = jg-y0cell;
output2d.c:	k = kg-z0cell;
output2d.c:	  f->field_cpu[l2D] = gprofile[jg];
output2d.c:	  f->field_cpu[l2D] = gprofile[jg];
output2d.c:    fclose (in);
output2d.c:  if (CPU_Rank < CPU_Number-1) {  // Force sequential read
output2d.c:    MPI_Send (&relay, 1, MPI_INT, CPU_Rank+1, 42, MPI_COMM_WORLD);
output2d.c:  if (error_occured == FALSE) {
output2d.c:    masterprint ("File %s was read successfully\n", filename);
output2d.c:  if ((error_occured == TRUE) && ((Restart == TRUE) || (Restart_Full == TRUE))) {
output2d.c:    printf ("Problem reading %s, CPU %d\n", filename, CPU_Rank);
output2d.c:  /* The MPI_Barrier below MUST NOT be commented. Several files are
output2d.c:     read upon restart (density, energy, vx, etc.), and the relay sent
output2d.c:     by CPU 0 in order to read one of them could be caught by CPU 1 when
output2d.c:     trying to read another one, which may result in race
output2d.c:     condition. Another solution could be to have an MPI tag that is a
output2d.c:     hash of the filename, but using the barrier is much simpler. */
output2d.c:  MPI_Barrier (MPI_COMM_WORLD);
output2d.c:  return error_occured;
output_vtk.c:#include <fargo3d.h>
output_vtk.c:void write_vtk_header(FILE *ofile, Field *field, int n) {
output_vtk.c:  fprintf(ofile, "# vtk DataFile Version 2.0\n");
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "Output %d - Field: %s - Physical time %f\n",
output_vtk.c:	  n, field->name, PhysicalTime);  
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "Output %d - Field: %s - Physical time %lf\n",
output_vtk.c:	  n, field->name, PhysicalTime);  
output_vtk.c:#endif
output_vtk.c:  fprintf(ofile, "BINARY\n");
output_vtk.c:  fprintf(ofile, "DATASET RECTILINEAR_GRID\n");
output_vtk.c:#ifndef SPHERICAL
output_vtk.c:  fprintf(ofile, "DIMENSIONS %d %d %d\n", Ny, Nx, Nz);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "DIMENSIONS %d %d %d\n", Ny, Nz, Nx);
output_vtk.c:#endif
output_vtk.c:void write_vtk_coordinates(FILE *ofile, Field *field) {
output_vtk.c:  /*There is a difference between the coordinates defined
output_vtk.c:    in FARGO3D and the coordinates used by Visit in Cylindrical &
output_vtk.c:    Spherical case. Be careful with the meaning of X,Y,Z in the
output_vtk.c:    VTK File.*/
output_vtk.c:  real temp;
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "X_COORDINATES %d FLOAT\n", Ny);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "X_COORDINATES %d DOUBLE\n", Ny);
output_vtk.c:#endif
output_vtk.c:    temp = Swap(field->y[i]);
output_vtk.c:    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:  fprintf(ofile, "\n");
output_vtk.c:#ifndef SPHERICAL
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "Y_COORDINATES %d FLOAT\n", Nx);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "Y_COORDINATES %d DOUBLE\n", Nx);
output_vtk.c:#endif
output_vtk.c:    temp = Swap(field->x[i]);
output_vtk.c:    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:  fprintf(ofile, "\n");
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "Z_COORDINATES %d FLOAT\n", Nz);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "Z_COORDINATES %d DOUBLE\n", Nz);
output_vtk.c:#endif
output_vtk.c:    temp = Swap(field->z[i]);
output_vtk.c:    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:  fprintf(ofile, "\n");
output_vtk.c:#else
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "Y_COORDINATES %d FLOAT\n", Nz);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "Y_COORDINATES %d DOUBLE\n", Nz);
output_vtk.c:#endif
output_vtk.c:    temp = Swap(field->z[i]);
output_vtk.c:    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:  fprintf(ofile, "\n");
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "Z_COORDINATES %d FLOAT\n", Nx);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "Z_COORDINATES %d DOUBLE\n", Nx);
output_vtk.c:#endif
output_vtk.c:    temp = Swap(field->x[i]);
output_vtk.c:    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:  fprintf(ofile, "\n");
output_vtk.c:#endif
output_vtk.c:  fprintf(ofile, "POINT_DATA %d\n", Nx*Ny*Nz);
output_vtk.c:void write_vtk_scalar(FILE *ofile, Field *f) {
output_vtk.c:  real temp;
output_vtk.c:#ifdef FLOAT
output_vtk.c:  fprintf(ofile, "SCALARS %s FLOAT\n", f->name);
output_vtk.c:#else
output_vtk.c:  fprintf(ofile, "SCALARS %s DOUBLE\n", f->name);
output_vtk.c:#endif
output_vtk.c:  fprintf(ofile, "LOOKUP_TABLE default\n");
output_vtk.c:  if (strcmp(f->name,FIELD) == 0)
output_vtk.c:    VtkPosition = ftell(ofile);
output_vtk.c:#ifndef SPHERICAL
output_vtk.c:#ifdef Z
output_vtk.c:#endif
output_vtk.c:#ifdef X
output_vtk.c:#endif
output_vtk.c:#ifdef Y
output_vtk.c:#endif
output_vtk.c:#else
output_vtk.c:#ifdef X
output_vtk.c:#endif
output_vtk.c:#ifdef Z
output_vtk.c:#endif
output_vtk.c:#ifdef Y
output_vtk.c:#endif
output_vtk.c:#endif
output_vtk.c:	temp = Swap(f->field_cpu[l]);
output_vtk.c:	fwrite(&temp, sizeof(real), 1, ofile);
output_vtk.c:#ifdef Y
output_vtk.c:#endif
output_vtk.c:#ifdef X
output_vtk.c:#endif
output_vtk.c:#ifdef Z
output_vtk.c:#endif
output_vtk.c:void WriteVTK(Field *f, int n) {
output_vtk.c:  char filename[MAXLINELENGTH];
output_vtk.c:  FILE *ofile;
output_vtk.c:  sprintf(filename, "%s%s%d_%d.vtk", OUTPUTDIR, f->name, n, CPU_Rank);
output_vtk.c:  ofile = fopen(filename,"w");
output_vtk.c:  write_vtk_header(ofile, f, n);
output_vtk.c:  write_vtk_coordinates(ofile, f);
output_vtk.c:  write_vtk_scalar(ofile, f);
output_vtk.c:  fclose(ofile);
output_vtk_merging.c:#include <fargo3d.h>
output_vtk_merging.c:void WriteVTKMerging(Field *f, int n) {
output_vtk_merging.c:  char outname[MAXLINELENGTH];
output_vtk_merging.c:  real temp;
output_vtk_merging.c:  FILE *ofile;
output_vtk_merging.c:  static boolean init = YES;
output_vtk_merging.c:  sprintf(outname, "%s%s%d.vtk", OUTPUTDIR, f->name, n);
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:    ofile = fopen(outname, "w");
output_vtk_merging.c:    fclose(ofile);
output_vtk_merging.c:    ofile = fopen(outname, "a+");
output_vtk_merging.c:  else {
output_vtk_merging.c:    ofile = fopen(outname,"a");
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:    fprintf(ofile, "# vtk DataFile Version 2.0\n");
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "Output %d - Field: %s - Physical time %f\n",
output_vtk_merging.c:	    n, f->name, PhysicalTime);  
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "Output %d - Field: %s - Physical time %lf\n",
output_vtk_merging.c:	    n, f->name, PhysicalTime);
output_vtk_merging.c:#endif
output_vtk_merging.c:    fprintf(ofile, "BINARY\n");
output_vtk_merging.c:    fprintf(ofile, "DATASET RECTILINEAR_GRID\n");
output_vtk_merging.c:#ifndef SPHERICAL
output_vtk_merging.c:    fprintf(ofile, "DIMENSIONS %d %d %d\n", NY, NX, NZ);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "DIMENSIONS %d %d %d\n", NY, NZ, NX);
output_vtk_merging.c:#endif
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "X_COORDINATES %d FLOAT\n", NY);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "X_COORDINATES %d DOUBLE\n", NY);
output_vtk_merging.c:#endif
output_vtk_merging.c:	temp = Swap(f->y[i+NGHY-Y0]);
output_vtk_merging.c:	fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:    fflush(ofile);
output_vtk_merging.c:    MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:  if (CPU_Master)
output_vtk_merging.c:    fprintf(ofile, "\n");
output_vtk_merging.c:#ifndef SPHERICAL
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "Y_COORDINATES %d FLOAT\n", NX);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "Y_COORDINATES %d DOUBLE\n", NX);
output_vtk_merging.c:#endif  
output_vtk_merging.c:      temp = Swap(f->x[i]);
output_vtk_merging.c:      fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:    fprintf(ofile, "\n");
output_vtk_merging.c:  fflush(ofile);
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:  if (CPU_Master)
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "Z_COORDINATES %d FLOAT\n", NZ);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "Z_COORDINATES %d DOUBLE\n", NZ);
output_vtk_merging.c:#endif  
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:	temp = Swap(f->z[i+NGHZ-Z0]);
output_vtk_merging.c:	fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:    fflush(ofile);
output_vtk_merging.c:    MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:  if (CPU_Master)
output_vtk_merging.c:    fprintf(ofile, "\n");
output_vtk_merging.c:#else
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "Y_COORDINATES %d FLOAT\n", NZ);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "Y_COORDINATES %d DOUBLE\n", NZ);
output_vtk_merging.c:#endif
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:	temp = Swap(f->z[i+NGHZ-Z0]);
output_vtk_merging.c:	fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:    fflush(ofile);
output_vtk_merging.c:    MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:  if (CPU_Master)
output_vtk_merging.c:    fprintf(ofile, "\n");
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "Z_COORDINATES %d FLOAT\n", NX);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "Z_COORDINATES %d DOUBLE\n", NX);
output_vtk_merging.c:#endif
output_vtk_merging.c:      temp = Swap(f->x[i]);
output_vtk_merging.c:      fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:    fprintf(ofile, "\n");
output_vtk_merging.c:  fflush(ofile);
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:#endif
output_vtk_merging.c:  if (CPU_Master) {
output_vtk_merging.c:    fprintf(ofile, "POINT_DATA %d\n", NX*NY*NZ);
output_vtk_merging.c:#ifdef FLOAT
output_vtk_merging.c:    fprintf(ofile, "SCALARS %s FLOAT\n", f->name);
output_vtk_merging.c:#else
output_vtk_merging.c:    fprintf(ofile, "SCALARS %s DOUBLE\n", f->name);
output_vtk_merging.c:#endif
output_vtk_merging.c:    fprintf(ofile, "LOOKUP_TABLE default\n");
output_vtk_merging.c:    if (strcmp(f->name,FIELD) == 0)
output_vtk_merging.c:      VtkPosition = ftell(ofile);
output_vtk_merging.c:  fflush(ofile);
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:#ifndef SPHERICAL
output_vtk_merging.c:	    temp = Swap(f->field_cpu[i+m*Nx+(k-Z0)*Stride+NGHZ*Stride]);
output_vtk_merging.c:	    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:	fflush(ofile);
output_vtk_merging.c:	MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:#else
output_vtk_merging.c:	    temp = Swap(f->field_cpu[i+m*Nx+(k-Z0)*Stride+NGHZ*Stride]);
output_vtk_merging.c:	    fwrite(&temp, sizeof(real), 1, ofile);
output_vtk_merging.c:	fflush(ofile);
output_vtk_merging.c:	MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:#endif
output_vtk_merging.c:  MPI_Barrier(MPI_COMM_WORLD);
output_vtk_merging.c:  fclose(ofile);
param.c:#include "fargo3d.h"
param.c:extern HashParam CommandLineParams[];
param.c:extern long nbparamCL;
param.c:Param Var_Set[MAXVARIABLES];
param.c:  char *home;
param.c:  char rcfile[MAXLINELENGTH];
param.c:  time_t tloc;
param.c:    home = getenv ("HOME");
param.c:    strcpy(rcfile, home);
param.c:    strcat(rcfile, "/.fargo3drc");
param.c:    mkdir (rcfile, 0755);
param.c:    strcat (rcfile, "/lastout");
param.c:    rc = fopen (rcfile, "a");
param.c:    if (rc) { 			/* Silent if cannot create file */
param.c:      time (&tloc);
param.c:      fprintf (rc, "%s", ctime(&tloc));
param.c:      } else {
param.c:	status = getcwd (outputdir, MAXLINELENGTH);
param.c:      fclose (rc);
param.c:    strcpy(rcfile, home);
param.c:    strcat(rcfile, "/.fargo3drc");
param.c:    mkdir (rcfile, 0755);
param.c:    strcat (rcfile, "/history");
param.c:    rc = fopen (rcfile, "a");
param.c:    time (&tloc);
param.c:    if (rc) fprintf (rc, "-----------\n%s", ctime(&tloc)); 
param.c:      if (rc) { 	 /* Silent if cannot create file */
param.c:    if (rc) { 			/* Silent if cannot create file */
param.c:      fprintf (rc, "(%d process%s in total) on host%s:\n", CPU_Number,
param.c:	       (CPU_Number > 1 ? "es" : ""),
param.c:	       (CPU_Number > 1 ? "s" : ""));
param.c:      for (i = 0; i < CPU_Number; i++)
param.c:      } else {
param.c:	status = getcwd (outputdir, MAXLINELENGTH);
param.c:      fclose (rc);
param.c:void init_var(char *name, char *variable, int type, int need, char *value) {
param.c:  real real_value;
param.c:  int  int_value;
param.c:  boolean bool_value;
param.c:  real temp;
param.c:#ifdef FLOAT
param.c:  sscanf(value, "%f", &temp);  // Save default value of variable
param.c:#else
param.c:  sscanf(value, "%lf", &temp);  // Save default value of variable
param.c:#endif
param.c:  if (type == REAL) real_value = (real)temp;
param.c:  if (type == INT ) int_value  = (int) temp;
param.c:  if (type == BOOL) bool_value = (boolean) temp;
param.c:  strcpy(Var_Set[Id_Var].name, name); // Save name into a struct Var_Set
param.c:  Var_Set[Id_Var].variable = variable;  // Point to memory address of variable
param.c:  Var_Set[Id_Var].type = type;
param.c:  Var_Set[Id_Var].need = need;
param.c:  Var_Set[Id_Var].read = NO;
param.c:  // Set to default values. These come from var.c
param.c:  if (type == INT)  *((int*) variable) = int_value; 
param.c:  if (type == REAL) *((real*)variable) = real_value;
param.c:  if (type == BOOL) *((boolean*)variable) = bool_value;
param.c:  if (type == STRING) strcpy(variable, value);
param.c:  // Move to the next variable
param.c:void ReadVarFile(char *filename) {
param.c:  real real_value;
param.c:  int  int_value, type;
param.c:  boolean bool_value = FALSE;
param.c:  real temp;
param.c:  char separator[20] = "\t :=>"; //Separators between a parameter name and its value
param.c:  char s[MAXLINELENGTH], name[MAXNAMELENGTH], strval[MAXNAMELENGTH];
param.c:  char testbool;
param.c:  real *real_var;
param.c:  boolean *bool_var;
param.c:  int i, success;
param.c:  input = fopen(filename, "r");
param.c:    mastererr("Unable to read '%s'. Program stopped.\n", filename);
param.c:    prs_exit(1);
param.c:  ReadRedefined ();
param.c:  mastererr("Reading parameters file %s\n", filename);
param.c:  while (fgets(s, MAXLINELENGTH-1, input) != NULL ) {
param.c:    success = sscanf(s, "%s", name); // read finish in a white-space.
param.c:    if(name[0]!='#' && success == 1) {
param.c:      s1 = s + (int)strlen(name); // pointer shift (Here is the data)
param.c:      // cast to int because type of strlen is size_t.
param.c:#ifdef FLOAT
param.c:      sscanf(s1 + strspn(s1, separator),"%f", &temp); //single precision floating point value
param.c:#else
param.c:      sscanf(s1 + strspn(s1, separator),"%lf", &temp); //double precision floating point value
param.c:#endif
param.c:      sscanf(s1 + strspn(s1, separator),"%s", strval); //string value
param.c:      real_value = (real)temp;
param.c:      int_value  = (int)temp;
param.c:      testbool   = toupper(strval[0]); // Convert to upper case
param.c:      if (testbool == 'Y')  bool_value = TRUE;  //Yes, or
param.c:      else bool_value = FALSE;
param.c:      // name to upper case
param.c:      for (i = 0; i<strlen(name); i++) name[i] = (char)toupper(name[i]);
param.c:      if (strcmp(name, "INCLUDE") == 0) {
param.c:	ReadVarFile(strval); // Recursive call. You can include a parameter file within another one.
param.c:      else {
param.c:	  if (strcmp(name, Var_Set[i].name) == 0) {
param.c:	    if (Var_Set[i].read == YES) {
param.c:	      mastererr("Warning : %s is defined more than once.\n", name);
param.c:	    if (Var_Set[i].read == REDEFINED) {
param.c:	      mastererr("Warning : %s is redefined on the command line.\n", name);
param.c:	    if (Var_Set[i].need == IRRELEVANT) {
param.c:	      mastererr("Warning : variable %s is irrelevant and nonetheless defined.\n", name);
param.c:	    if (Var_Set[i].read == NO) {
param.c:	      Var_Set[i].read = YES;
param.c:	      // Now we point to the correct variable
param.c:	      real_var = (real*)(Var_Set[i].variable);
param.c:	      int_var  = (int*) (Var_Set[i].variable);
param.c:	      bool_var = (boolean*)(Var_Set[i].variable);
param.c:	      // Now we reassign the value of the variable, if needed
param.c:	      if (Var_Set[i].type == REAL)   *real_var = real_value;
param.c:	      if (Var_Set[i].type == INT )   *int_var  = int_value;
param.c:	      if (Var_Set[i].type == BOOL)   *bool_var = bool_value;
param.c:	      if (Var_Set[i].type == STRING) strcpy(Var_Set[i].variable, strval);
param.c:      if ((found == NO) && strcmp(name, "INCLUDE")!=0 && strcmp(name, "END")!=0)
param.c:      mastererr("Warning: variable %s defined but does not exist in code.\n", name);
param.c:    if ((Var_Set[i].read == NO) && (Var_Set[i].need == YES)) {
param.c:	mastererr("Fatal error : undefined mandatory variable(s):\n");
param.c:      mastererr("%s\n", Var_Set[i].name);
param.c:      prs_exit(1);
param.c:  if(strcmp(name, "END")==0) {
param.c:      if (Var_Set[i].read == NO) {
param.c:	  mastererr("Secondary variables omitted:\n");
param.c:	if ((type = Var_Set[i].type) == REAL)
param.c:	  mastererr("%s;\t Default Value : %.5g\n", \
param.c:		    Var_Set[i].name, *((real *) Var_Set[i].variable));
param.c:	if (type == INT)
param.c:	  mastererr("%s;\t Default Value : %d\n", \
param.c:		    Var_Set[i].name, *((int *) Var_Set[i].variable));
param.c:	if (type == STRING)
param.c:	  mastererr("%s;\t Default Value : %s\n", \
param.c:		    Var_Set[i].name, Var_Set[i].variable);
param.c:  fclose(input);
param.c:  char SetUpName[MAXLINELENGTH];
param.c:  sprintf (SetUpName, xstr(SETUPNAME));
param.c:  if ((strcmp(SetUpName, "SETUPNAME") != 0) && (strcmp(SETUP, "Undefined") !=0)) {
param.c:    if (strcmp(SetUpName,SETUP) != 0) {
param.c:      mastererr ("\n\n******\n\nERROR\n\n");
param.c:      mastererr ("The parameter file is meant to run exclusively with\n");
param.c:      mastererr ("the '%s' setup, but the code has been build with\n", SETUP);
param.c:      mastererr ("the '%s' setup. I must exit.\n", SetUpName);
param.c:      mastererr ("You can fix that either by choosing another parameter file,\n");
param.c:      mastererr ("or, if you wish to use the one you have specified,\n");
param.c:      mastererr ("you should rebuild the code by issuing the command\n");
param.c:      mastererr ("'make SETUP=%s'\n", SETUP);
param.c:      prs_exit(1);
param.c:    GuidingCenter = YES;
param.c:#if defined(CARTESIAN)
param.c:  sprintf(COORDINATES,"%s","cartesian");
param.c:#elif defined(CYLINDRICAL)
param.c:#elif defined(SPHERICAL)
param.c:  sprintf(COORDINATES,"%s","spherical");
param.c:#endif
param.c:    mastererr ("You cannot use at the same time\n");
param.c:    mastererr ("`ThicknessSmoothing' and `RocheSmoothing'.\n");
param.c:    mastererr ("Edit the parameter file so as to remove\n");
param.c:    mastererr ("one of these variables and run again.\n");
param.c:    prs_exit (1);
param.c:#ifndef VISCOSITY
param.c:    mastererr ("ERROR - You have defined a non-vanishing value for\n");
param.c:    mastererr ("the kinematic viscosity NU, but the code is built\n");
param.c:    mastererr ("without the viscosity module. Edit your setup file\n");
param.c:    mastererr ("and add the line:\n");
param.c:    mastererr ("\nFARGO_OPT += -DVISCOSITY\n\n");
param.c:    mastererr ("and rebuild the code.\n");
param.c:    prs_exit (1);
param.c:#endif
param.c:#ifndef ALPHAVISCOSITY
param.c:    mastererr ("ERROR - You have defined a non-vanishing value for\n");
param.c:    mastererr ("the disk's alpha viscosity, but the code is built\n");
param.c:    mastererr ("without the viscosity module. Edit your setup file\n");
param.c:    mastererr ("and add the line:\n");
param.c:    mastererr ("\nFARGO_OPT += -DALPHAVISCOSITY\n\n");
param.c:    mastererr ("and rebuild the code.\n");
param.c:    prs_exit (1);
param.c:#endif
param.c:#if (defined(VISCOSITY) && defined(ALPHAVISCOSITY))
param.c:  mastererr ("ERROR - You cannot activate at the same time\n");
param.c:  mastererr ("VISCOSITY and ALPHAVISCOSITY. Fix, rebuild and rerun.\n");
param.c:  prs_exit (1);
param.c:#endif
param.c:#if (defined(COLLISIONPREDICTOR) && !defined(DRAGFORCE))
param.c:  mastererr ("ERROR - You cannot activate the COLLISIONPREDICTOR without the DRAGFORCE\n");
param.c:  prs_exit (1);
param.c:#endif
param.c:#if defined(DUSTDIFFUSION) && defined(ALPHAVISCOSITY) && !defined(Y)
param.c:  mastererr("ERROR - Direction Y (-DY in the .opt file) must be activated\n");
param.c:  mastererr("\tfor the dust diffusion module with Alpha Viscosity.\n");
param.c:  prs_exit (1);
param.c:#endif
param.c:    mastererr ("\n\n\nERROR\n\nThe buffer zones in X are wider than the active mesh\n");
param.c:    mastererr ("This is not permitted.\n");
param.c:    mastererr ("Either increase NX (it should be at least %d)\n", NGHX);
param.c:    mastererr ("or rebuild the code with the option GHOSTSX=0 (noghostsx)\n");
param.c:    prs_exit (1);
param.c:  /* Add a trailing slash to OUTPUTDIR if needed */
param.c:  if (*(OUTPUTDIR+strlen(OUTPUTDIR)-1) != '/')
param.c:#ifdef FLOAT
param.c:#else
param.c:#endif
param.c:#ifdef RESCALE
param.c:#if defined(CYLINDRICAL) || defined(CARTESIAN)
param.c:#endif
param.c:#ifdef CARTESIAN
param.c:#endif
param.c:  rescale();
param.c:#endif
param.c:void ListVariables (char *filename) {
param.c:  int i, type;
param.c:  FILE *stream;
param.c:  char fullname[MAXLINELENGTH];
param.c:  sprintf (fullname, "%s/%s", OUTPUTDIR, filename);
param.c:    stream = fopen_prs (fullname,"w");
param.c:      type = Var_Set[i].type;
param.c:      // Now, we print all variables in an adequate format.
param.c:      if (type == REAL)
param.c:	fprintf(stream, "%s\t%.15g\n", Var_Set[i].name, \
param.c:		*((real*)Var_Set[i].variable));
param.c:      if (type == INT)
param.c:      fprintf(stream, "%s\t%d\n", Var_Set[i].name, \
param.c:	      *((int*) Var_Set[i].variable));
param.c:      if (type == BOOL)
param.c:	fprintf(stream, "%s\t%d\n", Var_Set[i].name,	\
param.c:		*((boolean*) Var_Set[i].variable));
param.c:      if (type == STRING)
param.c:	fprintf(stream, "%s\t%s\n", Var_Set[i].name,	\
param.c:		Var_Set[i].variable);
param.c:    fclose(stream);
param.c:void ListVariablesIDL (char *filename)
param.c:  int i, type;
param.c:  FILE *stream;
param.c:  char fullname[MAXLINELENGTH];
param.c:  sprintf (fullname, "%s/%s", OUTPUTDIR, filename);
param.c:    stream = fopen_prs (fullname,"w");
param.c:    fprintf(stream, "input_par = { $\n");
param.c:      type = Var_Set[i].type;
param.c:      if (type == REAL)
param.c:	fprintf(stream, "%s:%.15g", Var_Set[i].name, *((real *) Var_Set[i].variable));
param.c:      if (type == INT)
param.c:	fprintf(stream, "%s:%d", Var_Set[i].name, *((int *) Var_Set[i].variable));
param.c:      if (type == BOOL)
param.c:	fprintf(stream, "%s:%d", Var_Set[i].name, *((boolean *) Var_Set[i].variable));
param.c:      if (type == STRING)
param.c:	fprintf(stream, "%s:'%s'", Var_Set[i].name, Var_Set[i].variable);
param.c:      if (i != Id_Var-1) fprintf(stream, ",$\n");
param.c:    fprintf(stream, "}\n");
param.c:    fclose (stream);
param.c:void ReadRedefined () {
param.c:  real           *ptrr;
param.c:  boolean        *ptrb;
param.c:      if (strcmp (Var_Set[i].name, CommandLineParams[j].name) == 0) {
param.c:	if (Var_Set[i].read == REDEFINED) {
param.c:	  mastererr ("Parameter %s on command line is specified twice\n", \
param.c:		    CommandLineParams[j].name);
param.c:	  exit (EXIT_FAILURE);
param.c:	Var_Set[i].read = REDEFINED;
param.c:	ptri = (int *) (Var_Set[i].variable);
param.c:	ptrr = (real *) (Var_Set[i].variable);
param.c:	ptrb = (boolean *) (Var_Set[i].variable);
param.c:	if (Var_Set[i].type == INT) {
param.c:	  *ptri = CommandLineParams[j].intvalue;
param.c:	} else if (Var_Set[i].type == REAL) {
param.c:	  *ptrr = CommandLineParams[j].floatvalue;
param.c:	    } else if (Var_Set[i].type == BOOL) {
param.c:	  *ptrb = CommandLineParams[j].boolvalue;
param.c:	} else if (Var_Set[i].type == STRING) {
param.c:	      strcpy (Var_Set[i].variable, CommandLineParams[j].stringvalue);
param.c:      mastererr ("Parameter %s on command line is unknown\n", CommandLineParams[j].name);
param.c:      exit (EXIT_FAILURE);
planets.c:#include "fargo3d.h"
planets.c:void ComputeIndirectTerm () {
planets.c:#ifndef NODEFAULTSTAR
planets.c:  IndirectTerm.x = -DiskOnPrimaryAcceleration.x;
planets.c:  IndirectTerm.y = -DiskOnPrimaryAcceleration.y;
planets.c:  IndirectTerm.z = -DiskOnPrimaryAcceleration.z;
planets.c:    IndirectTerm.x = 0.0;
planets.c:    IndirectTerm.y = 0.0;
planets.c:    IndirectTerm.z = 0.0;
planets.c:#else
planets.c:  IndirectTerm.x = 0.0;
planets.c:  IndirectTerm.y = 0.0;
planets.c:  IndirectTerm.z = 0.0;
planets.c:#endif
planets.c:Force ComputeForce(real x, real y, real z,
planets.c:		   real rsmoothing, real mass) {
planets.c:  Force Force;
planets.c:  /* The trick below, which uses VxMed as a 2D temporary array,
planets.c:     amounts to subtracting the azimuthally averaged density prior to
planets.c:     the torque evaluation. This has no impact on the torque, but has
planets.c:     on the angular speed of the planet and is required for a proper
planets.c:     location of resonances in a non self-gravitating disk. See
planets.c:     Baruteau & Masset 2008, ApJ, 678, 483 (arXiv:0801.4413) for
planets.c:     details. */
planets.c:#ifdef BM08
planets.c:  ComputeVmed (Total_Density);
planets.c:  ChangeFrame (-1, Total_Density, VxMed);
planets.c:#endif
planets.c:  /* The density is now the perturbed density */
planets.c:  FARGO_SAFE(_ComputeForce(x, y, z, rsmoothing, mass)); /* Function/Kernel Launcher. */
planets.c:  /* We restore the total density below by adding back the azimuthal
planets.c:     average */
planets.c:#ifdef BM08
planets.c:  ChangeFrame (+1, Total_Density, VxMed);
planets.c:#endif
planets.c:#ifdef FLOAT
planets.c:  MPI_Allreduce (&localforce, &globalforce, 12, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
planets.c:#else
planets.c:  MPI_Allreduce (&localforce, &globalforce, 12, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
planets.c:#endif
planets.c:  Force.fx_inner    = globalforce[0];
planets.c:  Force.fy_inner    = globalforce[1];
planets.c:  Force.fz_inner    = globalforce[2];
planets.c:  Force.fx_ex_inner = globalforce[3];
planets.c:  Force.fy_ex_inner = globalforce[4];
planets.c:  Force.fz_ex_inner = globalforce[5];
planets.c:  Force.fx_outer    = globalforce[6];
planets.c:  Force.fy_outer    = globalforce[7];
planets.c:  Force.fz_outer    = globalforce[8];
planets.c:  Force.fx_ex_outer = globalforce[9];
planets.c:  Force.fy_ex_outer = globalforce[10];
planets.c:  Force.fz_ex_outer = globalforce[11];
planets.c:  return Force;
planets.c:Point ComputeAccel(real x, real y, real z,
planets.c:		   real rsmoothing, real mass) {
planets.c:  Point acceleration;
planets.c:  Force force;
planets.c:  force = ComputeForce (x, y, z, rsmoothing, mass);
planets.c:    acceleration.x = force.fx_ex_inner+force.fx_ex_outer;
planets.c:    acceleration.y = force.fy_ex_inner+force.fy_ex_outer;
planets.c:    acceleration.z = force.fz_ex_inner+force.fz_ex_outer;
planets.c:  else {
planets.c:    acceleration.x = force.fx_inner+force.fx_outer;
planets.c:    acceleration.y = force.fy_inner+force.fy_outer;
planets.c:    acceleration.z = force.fz_inner+force.fz_outer;
planets.c:  return acceleration;
planets.c:void AdvanceSystemFromDisk(real dt) {
planets.c:  int NbPlanets, k;
planets.c:  real x, y, z;
planets.c:  real r, m, smoothing;
planets.c:  NbPlanets = Sys->nb;
planets.c:  for (k = 0; k < NbPlanets; k++) {
planets.c:    if (Sys->FeelDisk[k] == YES) {
planets.c:      else
planets.c:      gamma = ComputeAccel (x, y, z, smoothing, m);
planets.c:#ifdef GASINDIRECTTERM
planets.c:      Sys->vx[k] += dt * IndirectTerm.x;
planets.c:      Sys->vy[k] += dt * IndirectTerm.y;
planets.c:      Sys->vz[k] += dt * IndirectTerm.z;
planets.c:#endif
planets.c:OrbitalElements SV2OE (StateVector v, real m) {
planets.c:  real x,y,z,vx,vy,vz;
planets.c:  real Ax, Ay, Az, h, h2, inc, e;
planets.c:  real d, hx, hy, hz, a, E, M, V;
planets.c:  real hhor, per, an;//Ascending node
planets.c:  OrbitalElements o;
planets.c:  o.e = e = sqrt(Ax*Ax+Ay*Ay+Az*Az)/(G*m); //Laplace-Runge-Lenz vector
planets.c:  o.a = a = h*h/(G*m*(1.-e*e));
planets.c:  //Eccentric anomaly
planets.c:  if (e != 0.0) {
planets.c:    E = acos((1.0-d/a)/e); //E evaluated as such is between 0 and PI
planets.c:  } else {
planets.c:  if (x*vx+y*vy+z*vz < 0) E= -E; //Planet goes toward central object,
planets.c:  //hence on its way from aphelion to perihelion (E < 0)
planets.c:    else
planets.c:  o.M = M = E-e*sin(E);
planets.c:  //V: true anomaly
planets.c:  if (e > 1.e-14) {
planets.c:    V = acos ((a*(1.0-e*e)/d-1.0)/e);
planets.c:  } else {
planets.c:  if (fabs(o.i) > 1e-5) {
planets.c:    an = atan2(hy,hx)+M_PI*.5; //Independently of sign of (hz)
planets.c:  } else {
planets.c:    an = 0.0;//Line of nodes not determined ==> defaults to x axis
planets.c:  // Argument of periapsis
planets.c:  per = acos((Ax*cos(an)+Ay*sin(an))/sqrt(Ax*Ax+Ay*Ay+Az*Az));
planets.c:    per = 2.0*M_PI-per;
planets.c:  o.per = per;
planets.c:    o.Perihelion_Phi = atan2(Ay,Ax);
planets.c:  else
planets.c:    o.Perihelion_Phi = atan2(y,x);
planets.c:  return o;
planets.c:void FindOrbitalElements (StateVector v,real m,int n){
planets.c:  char name[256];
planets.c:  OrbitalElements o;
planets.c:  if (CPU_Rank) return;
planets.c:  sprintf (name, "%sorbit%d.dat", OUTPUTDIR, n);
planets.c:  output = fopen_prs (name, "a");
planets.c:	   PhysicalTime, o.e, o.a, o.M, o.ta, o.per, XAxisRotationAngle);
planets.c:  fprintf (output, "\t%.12g\t%.12g\t%.12g\n", o.i, o.an, o.Perihelion_Phi);
planets.c:  fclose (output);
planets.c:void SolveOrbits (PlanetarySystem *sys){
planets.c:  StateVector v;
planets.c:    FindOrbitalElements (v,MSTAR+sys->mass[i],i);
postrestarthook.c:#include "fargo3d.h"
postrestarthook.c:/* You can redefine this function in your startup */
postrestarthook.c:void PostRestartHook () {
potential.c://#define __GPU
potential.c://#define __NOPROTO
potential.c:#include "fargo3d.h"
potential.c:void compute_potential(real dt) {
potential.c:  real omeganew;
potential.c:  static int alreadycalculated = -1;
potential.c:  if (alreadycalculated != Timestepcount){ //For multifluid purposes...
potential.c:    if (Corotating) GetPsysInfo (MARK);
potential.c:#ifdef GPU
potential.c:    //Copy all the planetary data to device
potential.c:    DevMemcpyH2D(Sys->x_gpu, Sys->x_cpu, sizeof(real)*(Sys->nb+1));
potential.c:    DevMemcpyH2D(Sys->y_gpu, Sys->y_cpu, sizeof(real)*(Sys->nb+1));
potential.c:    DevMemcpyH2D(Sys->z_gpu, Sys->z_cpu, sizeof(real)*(Sys->nb+1));
potential.c:    DevMemcpyH2D(Sys->mass_gpu, Sys->mass_cpu, sizeof(real)*(Sys->nb+1));
potential.c:#endif
potential.c:    DiskOnPrimaryAcceleration = ComputeAccel(0.0, 0.0, 0.0, 0.0, 0.0);
potential.c:    FARGO_SAFE(ComputeIndirectTerm());
potential.c:    FARGO_SAFE(Potential()); // Gravitational potential from star and planet(s)
potential.c:    FARGO_SAFE(AdvanceSystemFromDisk(dt));
potential.c:  if (ThereIsACentralBinary)
potential.c:    subcycling = 30;		/* Arbitrary number of subcycles which
potential.c:				   should fit most needs */
potential.c:    FARGO_SAFE(AdvanceSystemRK5(1.0/((double)(subcycling))*dt));
potential.c:  alreadycalculated = Timestepcount;
potential.c:    omeganew = GetPsysInfo(GET)/dt;
potential.c:    Domega = omeganew-OMEGAFRAME;
potential.c:    OMEGAFRAME = omeganew;
potential.c:  RotatePsys(OMEGAFRAME*dt);
potential.c:void Potential_cpu() {
potential.c:  real planetmass_taper;
potential.c:    planetmass_taper = 1.0;
potential.c:  else
potential.c:    planetmass_taper = (PhysicalTime >= MASSTAPER ? 1.0 : .5*(1.0-cos(M_PI*PhysicalTime/MASSTAPER)));
potential.c:  real* pot  = Pot->field_cpu;
potential.c:  real* xplanet = Sys->x_cpu;
potential.c:  real* yplanet = Sys->y_cpu;
potential.c:  real* zplanet = Sys->z_cpu;
potential.c:  real* mplanet = Sys->mass_cpu;
potential.c:  int stride = Stride_cpu;
potential.c:  int size_x = Nx+2*NGHX;
potential.c:  int size_y = Ny+2*NGHY;
potential.c:  int size_z = Nz+2*NGHZ;
potential.c:  int indirect_term = INDIRECTTERM;
potential.c:  real indirectx = IndirectTerm.x;
potential.c:  real indirecty = IndirectTerm.y;
potential.c:  real indirectz = IndirectTerm.z;
potential.c:  real taper = planetmass_taper;
potential.c:  int binary_true = ThereIsACentralBinary;
potential.c:  real smoothing;
potential.c:  real dist;
potential.c:  real rroche;
potential.c:  real planetdistance;
potential.c:  real mp;
potential.c:  real invd3;
potential.c:// real xmin(Nx+1);
potential.c:// real ymin(Ny+2*NGHY+1);
potential.c:// real zmin(Nz+2*NGHZ+1);
potential.c:// real ASPECTRATIO(1);
potential.c:// real ROCHESMOOTHING(1);
potential.c:// real FLARINGINDEX(1);
potential.c:// real THICKNESSSMOOTHING(1);
potential.c:#ifdef Z
potential.c:  for (k=0; k<size_z; k++) {
potential.c:#endif
potential.c:#ifdef Y
potential.c:    for (j=0; j<size_y; j++) {
potential.c:#endif
potential.c:#ifdef X
potential.c:      for (i=0; i<size_x; i++) {
potential.c:#endif
potential.c:#ifndef NODEFAULTSTAR
potential.c:#ifdef SPHERICAL
potential.c:	pot[l] =  -G*MSTAR/ymed(j); //Potential from star
potential.c:#endif
potential.c:#ifdef CYLINDRICAL
potential.c:	pot[l] =  -G*MSTAR/sqrt(ymed(j)*ymed(j)+ZC*ZC); //Potential from star
potential.c:#endif
potential.c:#ifdef CARTESIAN
potential.c:#endif
potential.c:#else
potential.c:	pot[l] = 0.0; // No default star
potential.c:#endif
potential.c:#ifdef GASINDIRECTTERM
potential.c:	if (indirect_term == YES) {
potential.c:		pot[l] -= indirectx*XC + indirecty*YC + indirectz*ZC; /* Indirect term due to gas */
potential.c:#endif
potential.c:	  mp = mplanet[n]*taper;
potential.c:	  planetdistance = sqrt(xplanet[n]*xplanet[n]+
potential.c:				yplanet[n]*yplanet[n]+
potential.c:				zplanet[n]*zplanet[n]);
potential.c:	  rroche = planetdistance*pow((1.0/3.0*mp/MSTAR),1.0/3.0);
potential.c:	    smoothing = rroche*ROCHESMOOTHING;
potential.c:	  else
potential.c:	      pow(planetdistance/R0,FLARINGINDEX)*
potential.c:	      planetdistance*THICKNESSSMOOTHING;
potential.c:	  dist = ((XC-xplanet[n])*(XC-xplanet[n])+
potential.c:		  (YC-yplanet[n])*(YC-yplanet[n])+
potential.c:		  (ZC-zplanet[n])*(ZC-zplanet[n]));
potential.c:#ifndef NODEFAULTSTAR
potential.c:	  if (indirect_term == YES) {
potential.c:	    /* Indirect term due to planets */
potential.c:	    pot[l] += G*mp*(XC*xplanet[n]+YC*yplanet[n]+ZC*zplanet[n])/(planetdistance*
potential.c:										planetdistance*
potential.c:										planetdistance);
potential.c:#endif
potential.c:#ifdef NODEFAULTSTAR
potential.c:	  if (binary_true && (indirect_term == YES)) {
potential.c:	    if ((n != istar1) && (n != istar2)) { /* For all non-stellar objects */
potential.c:	      planetdistance = sqrt((xplanet[n]-xplanet[istar1])*(xplanet[n]-xplanet[istar1])+
potential.c:				    (yplanet[n]-yplanet[istar1])*(yplanet[n]-yplanet[istar1])+
potential.c:				    (zplanet[n]-zplanet[istar1])*(zplanet[n]-zplanet[istar1]));
potential.c:	      invd3 = 1.0/(planetdistance*planetdistance*planetdistance);
potential.c:	      pot[l] += G*mp*invd3*mplanet[1]*((xplanet[n]-xplanet[istar1])*XC+	\
potential.c:					       (yplanet[n]-yplanet[istar1])*YC+	\
potential.c:					       (zplanet[n]-zplanet[istar1])*ZC)/\
potential.c:		(mplanet[1]+mplanet[2]);
potential.c:	      planetdistance = sqrt((xplanet[n]-xplanet[istar2])*(xplanet[n]-xplanet[istar2])+
potential.c:				    (yplanet[n]-yplanet[istar2])*(yplanet[n]-yplanet[istar2])+
potential.c:				    (zplanet[n]-zplanet[istar2])*(zplanet[n]-zplanet[istar2]));
potential.c:	      invd3 = 1.0/(planetdistance*planetdistance*planetdistance);
potential.c:	      pot[l] += G*mp*invd3*mplanet[2]*((xplanet[n]-xplanet[istar2])*XC+	\
potential.c:					       (yplanet[n]-yplanet[istar2])*YC+	\
potential.c:					       (zplanet[n]-zplanet[istar2])*ZC)/\
potential.c:		(mplanet[1]+mplanet[2]);
potential.c:#endif
potential.c:	  pot[l] += -G*mp/sqrt(dist+smoothing); //Potential from planets
potential.c:#ifdef X
potential.c:#endif
potential.c:#ifdef Y
potential.c:#endif
potential.c:#ifdef Z
potential.c:#endif
psys.c:#include "fargo3d.h"
psys.c:int FindNumberOfPlanets(char *filename) {
psys.c:  int counter=0;
psys.c:  input = fopen(filename, "r");
psys.c:    fprintf(stderr, "%s cannot be opened\n", filename);
psys.c:    prs_exit(1);
psys.c:  while(fgets(s, 510, input)!=NULL) {
psys.c:    if(isalpha(s[0])) counter++;
psys.c:  fclose(input);
psys.c:  return counter;
psys.c:PlanetarySystem *AllocPlanetSystem(int nb) {
psys.c:  real *mass, *x, *y, *z, *vx, *vy, *vz, *acc;
psys.c:  boolean *feeldisk, *feelothers;
psys.c:  PlanetarySystem *sys;
psys.c:  int temp;
psys.c:  sys  = (PlanetarySystem *)malloc (sizeof(PlanetarySystem));
psys.c:    fprintf (stderr, "Not enough memory to alloc PlanetarySystem.\n");
psys.c:    prs_exit (1);
psys.c:  x    = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  y    = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  z    = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  vx   = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  vy   = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  vz   = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  mass = (real*)malloc(sizeof(real)*(nb+1));
psys.c:  acc  = (real*)malloc(sizeof(real)*(nb+1));
psys.c:    fprintf (stderr, "Not enough memory to alloc components of planetary system.\n");
psys.c:    prs_exit (1);
psys.c:  feeldisk   = (boolean*)malloc(sizeof(char)*(nb+1));
psys.c:  feelothers = (boolean*)malloc(sizeof(char)*(nb+1));
psys.c:  if ((feeldisk == NULL) || (feelothers == NULL)) {
psys.c:    fprintf (stderr, "Not enough memory for boolean allocation in PlanetarySystem.\n");
psys.c:    prs_exit (1);
psys.c:  sys->FeelDisk = feeldisk;
psys.c:  sys->FeelOthers = feelothers;
psys.c:    feeldisk[i] = feelothers[i] = YES;
psys.c:    /* Creates orbit[i].dat if it does not exist */
psys.c:    temp = system (command);
psys.c:  sys->FeelDisk = feeldisk;
psys.c:  sys->FeelOthers = feelothers;
psys.c:#ifdef GPU
psys.c:  status = DevMalloc(&(sys->x_gpu),(sizeof(real)*(nb+1)));
psys.c:  status = DevMalloc(&(sys->y_gpu),(sizeof(real)*(nb+1)));
psys.c:  status = DevMalloc(&(sys->z_gpu),(sizeof(real)*(nb+1)));
psys.c:  status = DevMalloc(&(sys->mass_gpu),(sizeof(real)*(nb+1)));
psys.c://  status = DevMemcpyH2D(sys->x_gpu, sys->x_cpu, sizeof(real)*(nb+1));
psys.c://  status = DevMemcpyH2D(sys->y_gpu, sys->y_cpu, sizeof(real)*(nb+1));
psys.c://  status = DevMemcpyH2D(sys->z_gpu, sys->z_cpu, sizeof(real)*(nb+1));
psys.c://  status = DevMemcpyH2D(sys->mass_gpu, sys->mass_cpu, sizeof(real)*(nb+1));
psys.c:#endif
psys.c:  return sys;
psys.c:void FreePlanetary () {
psys.c:  free (Sys->x);
psys.c:  free (Sys->vx);
psys.c:  free (Sys->y);
psys.c:  free (Sys->vy);
psys.c:  free (Sys->mass);
psys.c:  free (Sys->acc);
psys.c:  free (Sys->FeelOthers);
psys.c:  free (Sys->FeelDisk);
psys.c:  free (Sys);
psys.c:real ComputeInnerMass(real r) {
psys.c:  real mass=0.0;
psys.c:  real *rho;
psys.c:  real innermass;
psys.c:  rho = Density->field_cpu;
psys.c:	if(Ymed(j)<r) {
psys.c:#ifdef FLOAT
psys.c:  MPI_Allreduce (&mass, &innermass, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
psys.c:#else
psys.c:  MPI_Allreduce (&mass, &innermass, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
psys.c:#endif
psys.c:  // printf("InnerMass=%lf\n", innermass);
psys.c:  return innermass;
psys.c:PlanetarySystem *InitPlanetarySystem (char *filename) {
psys.c:  char s[512], nm[512], test1[512], test2[512], *s1;
psys.c:  PlanetarySystem *sys;
psys.c:  real xp,yp,zp,vxp,vyp,vzp,mp,M1,M2,r1,r2,v1,v2;
psys.c:  real mass, dist, accret;
psys.c:  boolean feeldis, feelothers;
psys.c:  real newmass;
psys.c:  real summass=0.0;
psys.c:  real e_bin, a_bin, period_bin;
psys.c:  if (ThereArePlanets == NO) {
psys.c:    sys = AllocPlanetSystem (1);
psys.c:    return sys;
psys.c:  nb = FindNumberOfPlanets (filename);
psys.c:  if (CPU_Master) {
psys.c:    if(nb > 1) printf  ("%d planets found.\n", nb);
psys.c:    else printf  ("%d planet found.\n", nb);
psys.c:  sys = AllocPlanetSystem (nb);
psys.c:  input = fopen (filename, "r"); // Its existence has been checked already
psys.c:  while (fgets(s, 510, input) != NULL) {
psys.c:      s1 = s + strlen(nm);
psys.c:#ifdef FLOAT
psys.c:      sscanf(s1 + strspn(s1, "\t :=>_"), "%f %f %f %s %s", &dist, &mass, &accret, test1, test2);
psys.c:#else
psys.c:      sscanf(s1 + strspn(s1, "\t :=>_"), "%lf %lf %lf %s %s", &dist, &mass, &accret, test1, test2);
psys.c:#endif
psys.c:      if ((SEMIMAJORAXIS > 0.0) && (i == 0)) // SemiMajorAxis can be
psys.c:					     // used to overwrite the
psys.c:					     // first planet's initial
psys.c:      if (ORBITALRADIUS > 1e-30)
psys.c:#ifdef RESCALE
psys.c:      accret *= sqrt(G*MSTAR/(R0*R0*R0));
psys.c:#endif
psys.c:      if (PLANETMASS > 1e-18)
psys.c:      feeldis = feelothers = YES;
psys.c:      if (tolower(*test1) == 'n') feeldis = NO;
psys.c:      if (tolower(*test2) == 'n') feelothers = NO;
psys.c:      sys->x[i] = (real)dist*(1.0+ECCENTRICITY); // Planets are initialized at apoastron
psys.c:      sys->vy[i] = (real)sqrt(G*(MSTAR+sys->mass[i])/dist)*	\
psys.c:      sys->acc[i] = accret;
psys.c:      sys->FeelDisk[i] = feeldis;
psys.c:      sys->FeelOthers[i] = feelothers;
psys.c:    if (CPU_Master)
psys.c:      printf ("%d appear to be stellar mass objects.\n", nbstars);
psys.c:  /* We check whether some "planets" are actually stars */
psys.c:    if (sys->mass[i] > THRESHOLD_STELLAR_MASS) {/* Our arbitrary threshold for a star */
psys.c:    mastererr ("WARNING --- It seems that some 'planet(s)' in file %s\n", PLANETCONFIG);
psys.c:    mastererr ("WARNING --- is (are) actually star(s). In that case, it is a good idea that\n");
psys.c:    mastererr ("WARNING --- the preprocessor variable MSTAR be the sum of their mass.\n");
psys.c:    mastererr ("WARNING --- Currently this is not the case.\n");
psys.c:    mastererr ("WARNING --- You can edit the value of MSTAR in the file src/fondam.h.\n");
psys.c:    mastererr ("WARNING --- In this file, you want to edit the flavor of MSTAR which\n");
psys.c:    mastererr ("WARNING --- corresponds to the unit system you are presently working with.\n");
psys.c:    mastererr ("WARNING --- The current unit system is: ");
psys.c:#if !(defined(MKS) || defined (CGS))
psys.c:    mastererr ("scale free (code units).\n");
psys.c:#endif
psys.c:#ifdef CGS
psys.c:    mastererr ("cgs\n");
psys.c:#endif
psys.c:#ifdef MKS
psys.c:    mastererr ("MKS\n");
psys.c:#endif
psys.c:    mastererr ("WARNING --- So we suggest you edit src/fondam.h to have:\n");
psys.c:    mastererr ("\n    #define MSTAR_");
psys.c:#if !(defined(MKS) || defined (CGS))
psys.c:    mastererr ("SF");
psys.c:#endif
psys.c:#ifdef CGS
psys.c:    mastererr ("CGS");
psys.c:#endif
psys.c:#ifdef MKS
psys.c:    mastererr ("MKS");
psys.c:#endif
psys.c:    mastererr (" %g\n\n", summass);
psys.c:    mastererr ("WARNING --- This will ensure that:\n");
psys.c:    mastererr ("WARNING ---   * The planets are initialized on nearly circular orbits.\n");
psys.c:    mastererr ("WARNING ---   * Roche radii, wherever needed, are correctly estimated.\n");
psys.c:    mastererr ("WARNING ---   * Wave-killing BCs have the correct strength.\n\n");
psys.c:#ifndef NODEFAULTSTAR
psys.c:    mastererr("WARNING --- Some of your planets appear to be stars.\n");
psys.c:    mastererr("WARNING --- Their total mass is %g.\n", summass);
psys.c:    mastererr("WARNING --- Yet you have also by default a star at the mesh center.\n");
psys.c:    mastererr("WARNING --- Its mass is %g, ie %5.2f %% of the other stars mass.\n",MSTAR, MSTAR/summass*100);
psys.c:    mastererr("WARNING --- If this is what you intended, you can safely ignore this message.\n");
psys.c:    mastererr("WARNING --- Otherwise, you must recompile the code with the flag NODEFAULTSTAR\n");
psys.c:    mastererr("WARNING --- turned on. To do so, find your .opt file (in the setups folder),\n");
psys.c:    mastererr("WARNING --- and add to it the following line:\n");
psys.c:    mastererr("\nFARGO_OPT += -DNODEFAULTSTAR\n\n");
psys.c:#endif
psys.c:#ifdef NODEFAULTSTAR
psys.c:  /* We now properly re-initialize the stars */
psys.c:    mastererr ("ERROR --- at the present time you cannot have more than two stars in your .cfg file.\n");
psys.c:    prs_exit (1);
psys.c:    } else
psys.c:      else
psys.c:  if (nbstars == 1) {		/* We impose that the mesh be centered
psys.c:				   on the center of mass of the
psys.c:				   system */
psys.c:    ThereIsACentralBinary = YES;
psys.c:    e_bin = sys->x[i_star2];
psys.c:    period_bin = sys->x[i_star1];
psys.c:    a_bin = pow((period_bin*sqrt(G*(M1+M2)))/2.0/M_PI,2./3.);
psys.c:    r1 = a_bin*M2/(M1+M2)*(1.+e_bin);
psys.c:    v1 = 2.0*M_PI*a_bin*M2/(M1+M2)/period_bin*sqrt((1.0-e_bin)/(1.0+e_bin));
psys.c:    /* We impose below that the mesh be centered on the center of mass
psys.c:       of the binary */
psys.c:#endif
psys.c:  return sys;
psys.c:void ListPlanets () {
psys.c:  if (!CPU_Master) return;
psys.c:    printf ("Planet number %d\n", i);
psys.c:      printf ("Non-accreting.\n");
psys.c:    else
psys.c:      printf ("accretion time = %.10f\n", 1.0/(Sys->acc[i]));
psys.c:    if (Sys->FeelDisk[i] == YES) {
psys.c:      printf ("Feels the disk potential\n");
psys.c:    } else {
psys.c:      printf ("Doesn't feel the disk potential\n");
psys.c:    if (Sys->FeelOthers[i] == YES) {
psys.c:      printf ("Feels the other planets potential\n");
psys.c:    } else {
psys.c:      printf ("Doesn't feel the other planets potential\n");
psys.c:real GetPsysInfo (boolean action) {
psys.c:  real d1, d2, cross;
psys.c:  real x, y, z;
psys.c:  real vx, vy, vz;
psys.c:  real m;
psys.c:  real xc, yc;
psys.c:  real omega;
psys.c:  OrbitalElements o;
psys.c:  StateVector v;
psys.c:  static real X_planet, Y_planet;
psys.c:  if (GuidingCenter == YES) {
psys.c:    xc = o.a*cos(o.M+o.Perihelion_Phi)*cos(o.i);
psys.c:    yc = o.a*sin(o.M+o.Perihelion_Phi)*cos(o.i);
psys.c:  if (o.e < 1e-8) {
psys.c:  case MARK: 
psys.c:    X_planet = xc;
psys.c:    Y_planet = yc;
psys.c:    return 0.;
psys.c:  case GET:
psys.c:    d1 = sqrt(X_planet*X_planet+Y_planet*Y_planet);
psys.c:    cross = X_planet*y-x*Y_planet;
psys.c:    X_planet = x;
psys.c:    Y_planet = y;
psys.c:    return asin(cross/(d1*d2)); // azimuth change
psys.c:  case FREQUENCY:
psys.c:    if (GuidingCenter == YES)
psys.c:      return sqrt(G*m/pow(o.a,3.0));
psys.c:    else
psys.c:      return (x*vy-y*vx)/(x*x+y*y); // True in 3D as well: frame rotates about z axis
psys.c:  return 0.0;
psys.c:void RotatePsys (real angle) {
psys.c:  //rotate -angle
psys.c:  real sint, cost, xt, yt;
psys.c:  sint = sin(angle);
psys.c:  cost = cos(angle);
psys.c:  XAxisRotationAngle += angle;
psys.c:  if (XAxisRotationAngle >= 2.0*M_PI)
psys.c:    XAxisRotationAngle -= 2.0*M_PI;
psys.c:  if (XAxisRotationAngle < 0.0)
psys.c:    XAxisRotationAngle += 2.0*M_PI;
ram_advect.c://#define __GPU
ram_advect.c:#include "fargo3d.h"
ram_advect.c:void AdvectRAM_cpu(real dt, Field *F) {
ram_advect.c:  INPUT(Slope);
ram_advect.c:  DRAFT(Pressure);
ram_advect.c:  real* f        = F->field_cpu;
ram_advect.c:  real* slopes   = Slope->field_cpu;
ram_advect.c:  real* ustarmin = UStarmin->field_cpu;
ram_advect.c:  real* phistarmin = PhiStarmin->field_cpu;
ram_advect.c:  real* aux   = Pressure->field_cpu;
ram_advect.c:  int stride = Stride_cpu;
ram_advect.c:  int size_x = Nx+2*NGHX;
ram_advect.c:  int size_y = Ny+2*NGHY;
ram_advect.c:  int size_z = Nz+2*NGHZ;
ram_advect.c:  real phistarmin_last;
ram_advect.c:  real deltax;
ram_advect.c:  real deltax0;
ram_advect.c:  real deltax1;
ram_advect.c:  real deltax2;
ram_advect.c:  real deltax3;
ram_advect.c:  real deltax4;
ram_advect.c://  real xmin(Nx+2*NGHX+1);
ram_advect.c:#ifdef Z
ram_advect.c:  for (k=0; k<size_z; k++) {
ram_advect.c:#endif
ram_advect.c:#ifdef Y
ram_advect.c:    for (j=0; j<size_y; j++) {
ram_advect.c:#endif
ram_advect.c:#ifdef X
ram_advect.c:      for (i=0; i<size_x; i++ ) {
ram_advect.c:#endif
ram_advect.c:      id_star  = (int) (ustarmin[ll]*size_x);   //p(i)
ram_advect.c:      id_starp = (int) (ustarmin[llxp]*size_x); //p(i+1)
ram_advect.c:      l_star   = id_star  + j*pitch + k*stride;
ram_advect.c:      l_starp  = id_starp + j*pitch + k*stride;
ram_advect.c:      while(umin_total < 0) umin_total += size_x;
ram_advect.c:      //idm = (int) ( umin_total/(umin_total+1e-17) );
ram_advect.c:	      deltax0  = ( phistarmin[lxp]-phistarmin[ll]);
ram_advect.c:	      deltax1  = ( phistarmin[lxp]-xmed(id_star) );
ram_advect.c:	      deltax2 = 0.0;
ram_advect.c:	      deltax3 = 0.0;
ram_advect.c:	      deltax4 = 0.0;
ram_advect.c:      else{
ram_advect.c:        deltax0 = ( xmin(id_star+1)-phistarmin[ll] );
ram_advect.c:	      deltax1 = ( xmin(id_star+1)-xmed(id_star)  );
ram_advect.c:	      deltax2 = ( phistarmin[lxp]-xmin(id_starp) );
ram_advect.c:	      deltax3 = ( phistarmin[lxp]-xmed(id_starp) );
ram_advect.c:	      deltax4 = ( xmin(id_starp) -xmed(id_starp) );
ram_advect.c:      deltax  = phistarmin[ll]-xmed(id_star);
ram_advect.c:      aux[ll]  = f[l_star]*deltax0; 
ram_advect.c:      aux[ll] += 0.5*slopes[l_star]*(deltax1*deltax1-deltax*deltax);
ram_advect.c:      aux[ll] += f[l_starp]*deltax2; 
ram_advect.c:      aux[ll] += 0.5*slopes[l_starp]*(deltax3*deltax3-deltax4*deltax4);
ram_advect.c:      for(m=id_star+1; m<id_starp; m++) aux[ll] += f[m+j*pitch+k*stride]*(xmin(m+1)-xmin(m));
ram_advect.c:#ifdef X
ram_advect.c:#endif
ram_advect.c:#ifdef Y
ram_advect.c:#endif
ram_advect.c:#ifdef Z
ram_advect.c:#endif
ram_advect.c:#ifdef __GPU
ram_advect.c:  Dev2Dev3D(F,Pressure);
ram_advect.c:#else
ram_advect.c:  memcpy(f, aux, sizeof(real)*size_x*size_y*size_z);
ram_advect.c:#endif
ram_advect_lin.c://#define __GPU
ram_advect_lin.c:#include "fargo3d.h"
ram_advect_lin.c:void AdvectRAMlin_cpu(real dt, Field *F) {
ram_advect_lin.c:  INPUT(Slope);
ram_advect_lin.c:  DRAFT(Pressure);
ram_advect_lin.c:  real* f        = F->field_cpu;
ram_advect_lin.c:  real* slopes   = Slope->field_cpu;
ram_advect_lin.c:  real* phistarmin = PhiStarmin->field_cpu;
ram_advect_lin.c:  real* aux   = Pressure->field_cpu;
ram_advect_lin.c:  int stride = Stride_cpu;
ram_advect_lin.c:  int size_x = Nx+2*NGHX;
ram_advect_lin.c:  int size_y = Ny+2*NGHY;
ram_advect_lin.c:  int size_z = Nz+2*NGHZ;
ram_advect_lin.c:  real _xmax = XMAX;
ram_advect_lin.c:  real _xmin = XMIN;
ram_advect_lin.c:  real phistarmin_last;
ram_advect_lin.c:  real deltax;
ram_advect_lin.c:  real deltax0;
ram_advect_lin.c:  real deltax1;
ram_advect_lin.c:  real deltax2;
ram_advect_lin.c:  real deltax3;
ram_advect_lin.c:  real deltax4;
ram_advect_lin.c://  real xmin(Nx+2*NGHX+1);
ram_advect_lin.c:#ifdef Z
ram_advect_lin.c:  for (k=0; k<size_z; k++) {
ram_advect_lin.c:#endif
ram_advect_lin.c:#ifdef Y
ram_advect_lin.c:    for (j=0; j<size_y; j++) {
ram_advect_lin.c:#endif
ram_advect_lin.c:#ifdef X
ram_advect_lin.c:      for (i=0; i<size_x; i++ ) {
ram_advect_lin.c:#endif
ram_advect_lin.c:      id_star  = (int) ( (phistarmin[ll]-_xmin)/(_xmax-_xmin)*size_x);   //p(i)
ram_advect_lin.c:      id_starp = (int) ( (phistarmin[llxp]-_xmin)/(_xmax-_xmin)*size_x); //p(i+1)
ram_advect_lin.c:      l_star   = id_star  + j*pitch + k*stride;
ram_advect_lin.c:      l_starp  = id_starp + j*pitch + k*stride;
ram_advect_lin.c:      while(umin_total < 0) umin_total += size_x;
ram_advect_lin.c:	      deltax0  = ( phistarmin[lxp]-phistarmin[ll]);
ram_advect_lin.c:	      deltax1  = ( phistarmin[lxp]-xmed(id_star) );
ram_advect_lin.c:	      deltax2 = 0.0;
ram_advect_lin.c:	      deltax3 = 0.0;
ram_advect_lin.c:	      deltax4 = 0.0;
ram_advect_lin.c:      else{
ram_advect_lin.c:        deltax0 = ( xmin(id_star+1)-phistarmin[ll] );
ram_advect_lin.c:	      deltax1 = ( xmin(id_star+1)-xmed(id_star)  );
ram_advect_lin.c:	      deltax2 = ( phistarmin[lxp]-xmin(id_starp) );
ram_advect_lin.c:	      deltax3 = ( phistarmin[lxp]-xmed(id_starp) );
ram_advect_lin.c:	      deltax4 = ( xmin(id_starp) -xmed(id_starp) );
ram_advect_lin.c:      deltax  = phistarmin[ll]-xmed(id_star);
ram_advect_lin.c:      aux[ll]  = f[l_star]*deltax0; 
ram_advect_lin.c:      aux[ll] += 0.5*slopes[l_star]*(deltax1*deltax1-deltax*deltax);
ram_advect_lin.c:      aux[ll] += f[l_starp]*deltax2; 
ram_advect_lin.c:      aux[ll] += 0.5*slopes[l_starp]*(deltax3*deltax3-deltax4*deltax4);
ram_advect_lin.c:      for(m=id_star+1; m<id_starp; m++) aux[ll] += f[m+j*pitch+k*stride]*(xmin(m+1)-xmin(m));
ram_advect_lin.c:#ifdef X
ram_advect_lin.c:#endif
ram_advect_lin.c:#ifdef Y
ram_advect_lin.c:#endif
ram_advect_lin.c:#ifdef Z
ram_advect_lin.c:#endif
ram_advect_lin.c:#ifdef __GPU
ram_advect_lin.c:  Dev2Dev3D(F,Pressure);
ram_advect_lin.c:#else
ram_advect_lin.c:  memcpy(f, aux, sizeof(real)*size_x*size_y*size_z);
ram_advect_lin.c:#endif
ram_compute_ustar.c://#define __GPU
ram_compute_ustar.c://#define __NOPROTO
ram_compute_ustar.c:#include "fargo3d.h"
ram_compute_ustar.c:void RamComputeUstar_cpu(real dt) {
ram_compute_ustar.c:  INPUT2D(VxMed);
ram_compute_ustar.c:  real* vxmed      = VxMed->field_cpu;
ram_compute_ustar.c:  real* ustarmin   = UStarmin->field_cpu;
ram_compute_ustar.c:  real* phistarmin = PhiStarmin->field_cpu;
ram_compute_ustar.c:  int stride  = Stride_cpu;
ram_compute_ustar.c:  int size_x  = Nx+2*NGHX;
ram_compute_ustar.c:  int size_y  = Ny+2*NGHY;
ram_compute_ustar.c:  int size_z  = Nz+2*NGHZ;
ram_compute_ustar.c:  real xmc0   = Xmc0;
ram_compute_ustar.c:  real xmc1   = Xmc1;
ram_compute_ustar.c:  real xmc2   = Xmc2;
ram_compute_ustar.c:  real xmc3   = Xmc3;
ram_compute_ustar.c:  real xmc4   = Xmc4;
ram_compute_ustar.c:  real xma    = XMA;
ram_compute_ustar.c:  real xmb    = XMB;
ram_compute_ustar.c:  real xmc    = XMC;
ram_compute_ustar.c:  real x_mesh_I = X_mesh_I;
ram_compute_ustar.c:  real _xmin = XMIN;
ram_compute_ustar.c:  real _xmax = XMAX;
ram_compute_ustar.c:// real xmin(Nx+2*NGHX+1);
ram_compute_ustar.c:// real ymin(Ny+2*NGHY+1);
ram_compute_ustar.c:#ifdef Z
ram_compute_ustar.c:  for (k = 0; k < size_z; k++) {
ram_compute_ustar.c:#endif 
ram_compute_ustar.c:#ifdef Y
ram_compute_ustar.c:    for (j = 0; j < size_y; j++) {
ram_compute_ustar.c:#endif
ram_compute_ustar.c:#ifdef X
ram_compute_ustar.c:      for (i = 0; i < size_x; i++) {
ram_compute_ustar.c:#endif
ram_compute_ustar.c:#ifdef CARTESIAN
ram_compute_ustar.c:	phistarmin[ll] = xmin(i) - vxmed[ll2D]*dt;
ram_compute_ustar.c:#else
ram_compute_ustar.c:	phistarmin[ll] = xmin(i) - vxmed[ll2D]*dt/ymed(j);                
ram_compute_ustar.c:#endif
ram_compute_ustar.c:	// Periodicity
ram_compute_ustar.c:	while(phistarmin[ll] < _xmin) {
ram_compute_ustar.c:	while(phistarmin[ll] > _xmax) {
ram_compute_ustar.c:#ifdef X
ram_compute_ustar.c:#endif
ram_compute_ustar.c:#ifdef Y
ram_compute_ustar.c:#endif
ram_compute_ustar.c:#ifdef Z
ram_compute_ustar.c:#endif
ram_plm.c://#define __GPU
ram_plm.c://#define __NOPROTO
ram_plm.c:#include "fargo3d.h"
ram_plm.c:void RamSlopes_cpu(Field *Q){
ram_plm.c:  OUTPUT(Slope);
ram_plm.c:  real* slope = Slope->field_cpu;
ram_plm.c:  real* q = Q->field_cpu;
ram_plm.c:  int stride = Stride_cpu;
ram_plm.c:  int size_x = XIP; 
ram_plm.c:  int size_y = Ny+2*NGHY;
ram_plm.c:  int size_z = Nz+2*NGHZ;
ram_plm.c:  real dqm;
ram_plm.c:  real dqp;
ram_plm.c:  real dxmed;
ram_plm.c:  real dxmedp;
ram_plm.c:  // real Sxi(Nx+2*NGHX);
ram_plm.c:  // real xmin(Nx+2*NGHX+1);
ram_plm.c:#ifdef Z
ram_plm.c:  for (k=0; k<size_z; k++) {
ram_plm.c:#endif
ram_plm.c:#ifdef Y
ram_plm.c:    for (j=0; j<size_y; j++) {
ram_plm.c:#endif
ram_plm.c:#ifdef X
ram_plm.c:      for (i=XIM; i<size_x; i++) {	
ram_plm.c:#endif
ram_plm.c:	dxmed  = 0.5*( Sxi(i) + Sxi(ixm) );
ram_plm.c:	dxmedp = 0.5*( Sxi(ixp) + Sxi(i) );
ram_plm.c:	dqm = (q[ll]-q[llxm])/dxmed;
ram_plm.c:	dqp = (q[llxp]-q[ll])/dxmedp;
ram_plm.c:	if(dqp*dqm<=0.0)  slope[ll] = 0.0;
ram_plm.c:#ifndef DONOR
ram_plm.c:	else  slope[ll] = (2.*dqp*dqm)/(dqm+dqp);
ram_plm.c:#else
ram_plm.c:	else  slope[ll] = 0.0;
ram_plm.c:#endif
ram_plm.c:#ifdef X
ram_plm.c:#endif
ram_plm.c:#ifdef Y
ram_plm.c:#endif
ram_plm.c:#ifdef Z
ram_plm.c:#endif
redefoptions.c:#include "fargo3d.h"
redefoptions.c:HashParam CommandLineParams[100]; /* should be enough... */
redefoptions.c:  prs_error ("Incorrect parameter redefinition on command line\n");
redefoptions.c:void ParseRedefinedOptions (char *CommandLineRedefinedOptions) 
redefoptions.c:  char buffer[MAXLINELENGTH];
redefoptions.c:  char *current, *s1, *s2;
redefoptions.c:  long length;
redefoptions.c:  current = CommandLineRedefinedOptions;
redefoptions.c:  length = (long)strlen(CommandLineRedefinedOptions);
redefoptions.c:  if (length > MAXLINELENGTH-1) 
redefoptions.c:    prs_error ("Very long command line. Please rebuild code after increasing MAXLINELENGTH");
redefoptions.c:  if (length < 3)
redefoptions.c:  while (current-CommandLineRedefinedOptions < length-1) {
redefoptions.c:    strcpy (buffer, current);
redefoptions.c:    s1 = buffer + strspn(buffer, "\t :=>,;"); /* Skip initial separators */
redefoptions.c:    s2 = s1 + strcspn(s1, "\t :=>,;");	      /* Read until a separator is found  */
redefoptions.c:    *s2 = 0;				      /* We end the string here */
redefoptions.c:    current += (s2-buffer); 	/* We move the current position on option line accordingly */
redefoptions.c:      for (i = 0; i < strlen(s1); i++)
redefoptions.c:	s1[i] = (char) toupper(s1[i]);
redefoptions.c:      strcpy (CommandLineParams[nbparamCL].name, s1);
redefoptions.c:    else {
redefoptions.c:      strcpy (CommandLineParams[nbparamCL].stringvalue, s1);
redefoptions.c:      CommandLineParams[nbparamCL].floatvalue = strtod (s1, NULL);
redefoptions.c:      CommandLineParams[nbparamCL].intvalue = strtol (s1, NULL, 10);
redefoptions.c:      CommandLineParams[nbparamCL].boolvalue = FALSE;
redefoptions.c:	  (*s1 == 'y') || (*s1 == 'e') || (*s1 == 't'))
redefoptions.c:	CommandLineParams[nbparamCL].boolvalue = TRUE;
reduction_full_generic.c:real name_full_reduction (macro) (Field *F, int ymin, int ymax, int zmin, int zmax) {
reduction_full_generic.c:  real *reduc2d;
reduction_full_generic.c:  real result;
reduction_full_generic.c:  reduc2d = Reduction2D->field_cpu;
reduction_full_generic.c:  name_reduction(macro) (F, ymin, ymax, zmin, zmax);
reduction_full_generic.c:  INPUT2D (Reduction2D);
reduction_full_generic.c:  result = INIT_REDUCTION(macro);
reduction_full_generic.c:      result = macro(reduc2d[l2D], result);
reduction_full_generic.c:  return result;
reduction_generic.c:// This is the CPU version of the reduction of an n-dim array into an (n-1)-dim array
reduction_generic.c:// The final reduction of this intermediate array is always performed on the CPU
reduction_generic.c:// by the function in  "reduction_full_generic.c"
reduction_generic.c:void name_reduction_cpu(macro) (Field *F, int ymin, int ymax, int zmin, int zmax) {
reduction_generic.c:  real *reduc2d;
reduction_generic.c:  real *f;
reduction_generic.c:  reduc2d = Reduction2D->field_cpu;
reduction_generic.c:  f = F->field_cpu;
reduction_generic.c:  OUTPUT2D (Reduction2D);
reduction_generic.c:      reduc2d[l2D] = INIT_REDUCTION (macro);
reduction_generic.c:	reduc2d[l2D] = macro(reduc2d[l2D], f[l]);
reduction_min.c:#include "fargo3d.h"
reduction_min.c:#define macro MIN
reduction_min.c:#include "reduction_generic.c"
reduction_min.c:#include "reduction_full_generic.c"
reduction_sum.c:#include "fargo3d.h"
reduction_sum.c:#define macro SUM
reduction_sum.c:#include "reduction_generic.c"
reduction_sum.c:#include "reduction_full_generic.c"
rescale.c:#include "fargo3d.h"
rescale.c:void rescale () {
resetfield.c://#define __GPU
resetfield.c://#define __NOPROTO
resetfield.c:#include "fargo3d.h"
resetfield.c:void Reset_field_cpu (Field *f) {
resetfield.c:  real* faux = f->field_cpu;
resetfield.c:  int stride = Stride_cpu;
resetfield.c:  int size_x = Nx;
resetfield.c:  int size_y = Ny+2*NGHY;
resetfield.c:  int size_z = Nz+2*NGHZ;
resetfield.c:#ifdef Z
resetfield.c:  for (k=0; k<size_z; k++) {
resetfield.c:#endif
resetfield.c:#ifdef Y
resetfield.c:    for (j=0; j<size_y; j++) {
resetfield.c:#endif
resetfield.c:#ifdef X
resetfield.c:      for (i=0; i<size_x; i++ ) {
resetfield.c:#endif
resetfield.c:#ifdef X
resetfield.c:#endif
resetfield.c:#ifdef Y
resetfield.c:#endif
resetfield.c:#ifdef Z
resetfield.c:#endif
runge_kutta.c:/** \file RungeKunta.c
runge_kutta.c:A fifth-order Runge-Kunta integrator for the N-body problem. This
runge_kutta.c:N-body problem consists of the central star and N-1 planets.
runge_kutta.c:#include "fargo3d.h"
runge_kutta.c:static real k1[MAX1D], k2[MAX1D], k3[MAX1D], k4[MAX1D], k5[MAX1D], k6[MAX1D];
runge_kutta.c:static real Dist[MAX1D];
runge_kutta.c:static real q0[MAX1D], q1[MAX1D], PlanetMasses[MAX1D];
runge_kutta.c:void DerivMotionRK5(real *q_init, real *masses, \
runge_kutta.c:		    real *deriv, int n, real dt, \
runge_kutta.c:		    boolean *feelothers) {
runge_kutta.c:  real *x,*y,*z, *vx, *vy, *vz, dist;
runge_kutta.c:  real *derivx, *derivy, *derivz, *derivvx, *derivvy, *derivvz;
runge_kutta.c:  real coef;
runge_kutta.c:  derivx = deriv;
runge_kutta.c:  derivy = deriv+n;
runge_kutta.c:  derivz = deriv+2*n;
runge_kutta.c:  derivvx = deriv+3*n;
runge_kutta.c:  derivvy = deriv+4*n;
runge_kutta.c:  derivvz = deriv+5*n;
runge_kutta.c:    derivx[i] = vx[i];
runge_kutta.c:    derivy[i] = vy[i];
runge_kutta.c:    derivz[i] = vz[i];
runge_kutta.c:#ifdef NODEFAULTSTAR
runge_kutta.c:    coef = 0.0;
runge_kutta.c:#else
runge_kutta.c:    coef = -G*MSTAR/Dist[i]/Dist[i]/Dist[i];
runge_kutta.c:#endif
runge_kutta.c:    derivvx[i] = coef*x[i];
runge_kutta.c:    derivvy[i] = coef*y[i];
runge_kutta.c:    derivvz[i] = coef*z[i];
runge_kutta.c:#ifndef NODEFAULTSTAR
runge_kutta.c:	coef = G*masses[j]/Dist[j]/Dist[j]/Dist[j];
runge_kutta.c:	derivvx[i] -= coef*x[j];
runge_kutta.c:	derivvy[i] -= coef*y[j];
runge_kutta.c:	derivvz[i] -= coef*z[j];
runge_kutta.c:#endif
runge_kutta.c:      if ((j != i) && (feelothers[i] == YES)) {
runge_kutta.c:	coef = G*masses[j]/dist/dist/dist;
runge_kutta.c:	if (ThereIsACentralBinary &&\
runge_kutta.c:	  /* Binary stars do not feel the planet(s) */
runge_kutta.c:	  coef = 0.0;
runge_kutta.c:	derivvx[i] += coef*(x[j]-x[i]);
runge_kutta.c:	derivvy[i] += coef*(y[j]-y[i]);
runge_kutta.c:	derivvz[i] += coef*(z[j]-z[i]);
runge_kutta.c:    deriv[i] *= dt;  
runge_kutta.c:void TranslatePlanetRK5(real *qold, real c1, real c2, real c3,
runge_kutta.c:			real c4, real c5, real *qnew, int n) {
runge_kutta.c:    qnew[i] = qold[i]+c1*k1[i]+c2*k2[i]+c3*k3[i]+c4*k4[i]+c5*k5[i];
runge_kutta.c:void RungeKutta(real *q0, real dt, real *masses, real *q1,
runge_kutta.c:		int n, boolean *feelothers) {
runge_kutta.c:  real timestep;
runge_kutta.c:  timestep = dt;
runge_kutta.c:  DerivMotionRK5 (q0, masses, k1, n, timestep, feelothers);
runge_kutta.c:  TranslatePlanetRK5 (q0, 0.2, 0.0, 0.0, 0.0, 0.0, q1, n);
runge_kutta.c:  DerivMotionRK5 (q1, masses, k2, n, timestep, feelothers);
runge_kutta.c:  TranslatePlanetRK5 (q0, 0.075, 0.225, 0.0, 0.0, 0.0, q1, n);
runge_kutta.c:  DerivMotionRK5 (q1, masses, k3, n, timestep, feelothers);
runge_kutta.c:  TranslatePlanetRK5 (q0, 0.3, -0.9, 1.2, 0.0, 0.0, q1, n);
runge_kutta.c:  DerivMotionRK5 (q1, masses, k4, n, timestep, feelothers);
runge_kutta.c:  TranslatePlanetRK5 (q0, -11.0/54.0, 2.5, -70.0/27.0, 35.0/27.0, 0.0, q1, n);
runge_kutta.c:  DerivMotionRK5 (q1, masses, k5, n, timestep, feelothers);
runge_kutta.c:  TranslatePlanetRK5 (q0, 1631.0/55296.0, 175.0/512.0, 575.0/13824.0, 44275.0/110592.0, 253.0/4096.0, q1, n);
runge_kutta.c:  DerivMotionRK5 (q1, masses, k6, n, timestep, feelothers);
runge_kutta.c:void AdvanceSystemRK5 (real dt) {
runge_kutta.c:  boolean *feelothers;
runge_kutta.c:  real theta, rdot, r, new_r, omega, x, y;
runge_kutta.c:  real dtheta, vx, vy, denom;
runge_kutta.c:  real xc, yc, zc;
runge_kutta.c:    PlanetMasses[i] = Sys->mass[i];
runge_kutta.c:  feelothers = Sys->FeelOthers;
runge_kutta.c:  RungeKutta (q0, dt, PlanetMasses, q1, n, feelothers);
runge_kutta.c:  for (i = 1-(PhysicalTime >= RELEASEDATE); i < Sys->nb; i++) {
runge_kutta.c:  if (PhysicalTime < RELEASEDATE) { //We hereafter assume the planet to be in the plane.
runge_kutta.c:    theta = atan2(y,x);
runge_kutta.c:    rdot = (RELEASERADIUS-r)/(RELEASEDATE-PhysicalTime);
runge_kutta.c:    omega = sqrt((1.+Sys->mass[0])/r/r/r);
runge_kutta.c:    new_r = r + rdot*dt;
runge_kutta.c:    denom = r-new_r;
runge_kutta.c:    if (denom != 0.0) {
runge_kutta.c:      dtheta = 2.*dt*r*omega/denom*(sqrt(r/new_r)-1.);
runge_kutta.c:    } else {
runge_kutta.c:      dtheta = omega*dt;
runge_kutta.c:    vy = new_r*sqrt((1.+Sys->mass[0])/new_r/new_r/new_r);
runge_kutta.c:    Sys->x[0] = new_r*cos(dtheta+theta);
runge_kutta.c:    Sys->y[0] = new_r*sin(dtheta+theta);
runge_kutta.c:    Sys->vx[0]= vx*cos(dtheta+theta)-vy*sin(dtheta+theta); 
runge_kutta.c:    Sys->vy[0]= vx*sin(dtheta+theta)+vy*cos(dtheta+theta); 
runge_kutta.c:  /* Final residual correction for the binary barycenter (in order
runge_kutta.c:     to avoid a long term spurious drift) */
runge_kutta.c:  if (ThereIsACentralBinary) {
runge_kutta.c:    xc = (PlanetMasses[BinaryStar1]*(Sys->x[BinaryStar1]) + PlanetMasses[BinaryStar2]*(Sys->x[BinaryStar2]))/	\
runge_kutta.c:      (PlanetMasses[BinaryStar1]+PlanetMasses[BinaryStar2]);
runge_kutta.c:    yc = (PlanetMasses[BinaryStar1]*(Sys->y[BinaryStar1]) + PlanetMasses[BinaryStar2]*(Sys->y[BinaryStar2]))/	\
runge_kutta.c:      (PlanetMasses[BinaryStar1]+PlanetMasses[BinaryStar2]);
runge_kutta.c:    zc = (PlanetMasses[BinaryStar1]*(Sys->z[BinaryStar1]) + PlanetMasses[BinaryStar2]*(Sys->z[BinaryStar2]))/	\
runge_kutta.c:      (PlanetMasses[BinaryStar1]+PlanetMasses[BinaryStar2]);
select_device.c:#include "fargo3d.h"
select_device.c:void SelectDevice(int myrank){
select_device.c:#ifdef GPU
select_device.c:  char hostname[1024];
select_device.c:  int device, i;
select_device.c:  boolean ChooseDeviceForMe = YES;
select_device.c:  struct cudaDeviceProp prop;
select_device.c:  gethostname(hostname,1023);
select_device.c:  /* You may choose below a device selection for a specific
select_device.c:     platform. The fall back is that the best device with compute
select_device.c:     capabilities at least 2.x is chosen automatically for you. When
select_device.c:     you run a MPI/GPU configuration, you should avoid to use this
select_device.c:     default, as there is a risk that two distinct processes access
select_device.c:     the same device. You should rather define a device selection rule
select_device.c:     below. */
select_device.c:  Check_CUDA_Blocks_Consistency ();
select_device.c:  /* Custom device selection rules depending on host name */
select_device.c:  /* The user may edit or had his own rules  */
select_device.c:  if (strcmp(hostname, "tesla") == 0) {
select_device.c:    device = 1-(myrank % 2);
select_device.c:    ChooseDeviceForMe = NO;
select_device.c:  if (strncmp(hostname, "com", 3) == 0) {
select_device.c:    device = myrank % 4;
select_device.c:    ChooseDeviceForMe = NO;
select_device.c:  if (DeviceManualSelection >= 0) {
select_device.c:    ChooseDeviceForMe = NO;
select_device.c:    device = DeviceManualSelection;
select_device.c:    if (myrank == 1) fprintf (stderr, "WARNING ! You have selected the device manually but your run is MPI\n");
select_device.c:  if (ChooseDeviceForMe) {
select_device.c:    memset(&prop, 0, sizeof(struct cudaDeviceProp));
select_device.c:    cudaChooseDevice(&device,&prop);
select_device.c:  cudaGetDeviceProperties(&prop,device);
select_device.c:  cudaSetDevice(device);
select_device.c:  cudaDeviceReset();
select_device.c:  for (i = 0; i<strlen(prop.name); i++){ //Name to upper case
select_device.c:    prop.name[i] = (char)toupper(prop.name[i]);
select_device.c:  masterprint("\n%s\n","=========================");
select_device.c:  masterprint("%s%d\n","PROCESS NUMBER       ",myrank);
select_device.c:  masterprint("%s%d\n","RUNNING ON DEVICE N ",device);
select_device.c:  masterprint("%s\n",prop.name);
select_device.c:  masterprint("%s%d%s%d\n", "COMPUTE CAPABILITY: ", prop.major,".",prop.minor);
select_device.c:  masterprint("%s%ld%s\n","VIDEO RAM MEMORY: ", prop.totalGlobalMem/1000000000 ," GB");
select_device.c:  masterprint("%s\n\n","=========================");
select_device.c:    masterprint("Error!!! Verify your device, something is wrong. Try to use manual device selection (-D switch)\n\n");
select_device.c:    exit(EXIT_FAILURE);
select_device.c:#endif
select_device.c:void EarlyDeviceSelection () {
select_device.c:#ifdef GPU
select_device.c:  char hostname[1024];
select_device.c:  int local_rank, device, mydevice=-1;
select_device.c:  char MpiEnvVariable[MAXLINELENGTH];
select_device.c:  char PeNbString[MAXLINELENGTH];
select_device.c:  FILE *devfile;
select_device.c:  gethostname(hostname,1022);
select_device.c:  sprintf (MpiEnvVariable, xstr(ENVRANK));
select_device.c:  if ((strcmp(MpiEnvVariable, "ENVRANK") == 0) || (strcmp(MpiEnvVariable, "") == 0)) {
select_device.c:    masterprint ("ERROR ====\n");
select_device.c:    masterprint ("You have built the code for a CUDA aware MPI implementation\n");
select_device.c:    masterprint ("in order to have efficient GPU-GPU communications.\n");
select_device.c:    masterprint ("But you have not provided the name of the environment variable\n");
select_device.c:    masterprint ("that is required to start the code. This variable depends on your\n");
select_device.c:    masterprint ("MPI implementation. For instance, for OpenMPI, it is called\n");
select_device.c:    masterprint ("OMPI_COMM_WORLD_LOCAL_RANK. For Mvapich2, it is NV2_COMM_WORLD_LOCAL_RANK, etc.\n");
select_device.c:    masterprint ("You must define the name of this variable in src/makefile\n");
select_device.c:    masterprint ("with the variable ENVRANK, for your specific platform. Have a look\n");
select_device.c:    masterprint ("at the examples provided in the makefile to adapt them to your situation.\n");
select_device.c:    exit(EXIT_FAILURE);
select_device.c:  if (getenv(MpiEnvVariable) == NULL) {
select_device.c:    masterprint ("I cannot find a valid (local) rank for the process.\n");
select_device.c:    masterprint ("Did you launch the run with 'mpirun' or equivalent ?\n");
select_device.c:    masterprint ("CUDA-aware MPI jobs MUST be launched through 'mpirun'\n");
select_device.c:    masterprint ("even if only one process is launched.\n");
select_device.c:    masterprint ("It is also possible that the executable was built for a\n");
select_device.c:    masterprint ("given architecture (e.g. OpenMPI), then run with\n");
select_device.c:    masterprint ("another one (e.g. MVAPICH2)\n");
select_device.c:    masterprint ("I must exit\n");
select_device.c:    exit(1);
select_device.c:  local_rank = atoi(getenv(MpiEnvVariable));
select_device.c:  device = local_rank;
select_device.c:  if (DeviceFileSpecified == YES) {
select_device.c:    devfile = fopen(DeviceFile, "r");
select_device.c:    if (devfile == NULL) {
select_device.c:      fprintf (stderr, "ERROR: cannot open device file %s\n", DeviceFile);
select_device.c:      exit (1);
select_device.c:    while (fgets(s, MAXLINELENGTH-1, devfile) != NULL ) {
select_device.c:      if (strncmp (s, hostname, strlen(hostname)) == 0) {
select_device.c:	  mydevice = atoi(s+strcspn(s,"=:/")+1);
select_device.c:	  masterprint ("Process on host %s w/ local rank %d runs on device %d\n",\
select_device.c:		  hostname, local_rank, mydevice);
select_device.c:    fclose(devfile);
select_device.c:    if (mydevice < 0) {
select_device.c:      fprintf(stderr, "Process on %s w/ local rank %d did not find its matching device in %s. Aborted.\n", hostname, local_rank, DeviceFile);
select_device.c:      exit(EXIT_FAILURE);
select_device.c:    device = mydevice;
select_device.c:  if (DeviceManualSelection >= 0) {
select_device.c:    device = DeviceManualSelection;
select_device.c:    if (local_rank == 1) fprintf (stderr, "WARNING ! You have selected the device manually but your run is MPI\n");
select_device.c:  cudaSetDevice (device);
select_device.c:  printf ("Process with local rank %d on host %s\n", local_rank, hostname);
select_device.c:#endif
setuphook1.c://#define __GPU
setuphook1.c://#define __NOPROTO
setuphook1.c:#include "fargo3d.h"
setuphook1.c:void SetupHook1_cpu() {  // Empty function. May be used as a template for custom function in setup directory.
setuphook1.c:  int stride = Stride_cpu;
setuphook1.c:  int size_x = Nx+2*NGHX;
setuphook1.c:  int size_y = Ny+2*NGHY;
setuphook1.c:  int size_z = Nz+2*NGHZ;
setuphook1.c:  int __attribute__((unused))i; //Variables reserved
setuphook1.c:  int __attribute__((unused))j; //for the topology
setuphook1.c:  int __attribute__((unused))k; //of the kernels
setuphook1.c:#ifdef Z
setuphook1.c:  for(k=1; k<size_z; k++) {
setuphook1.c:#endif
setuphook1.c:#ifdef Y
setuphook1.c:    for(j=1; j<size_y; j++) {
setuphook1.c:#endif
setuphook1.c:#ifdef X
setuphook1.c:      for(i=0; i<size_x; i++) {
setuphook1.c:#endif
setuphook1.c:#ifdef X
setuphook1.c:#endif
setuphook1.c:#ifdef Y
setuphook1.c:#endif
setuphook1.c:#ifdef Z
setuphook1.c:#endif
split.c:#include "fargo3d.h"
split.c:void buildprime(int *prime) {
split.c:  boolean isprime[MAXPRIME];
split.c:    isprime[i] = TRUE;
split.c:    prime[i] = 0;
split.c:    if (isprime[i]) {
split.c:	if (!(j%i)) isprime[j] = FALSE;
split.c:  isprime[0] = isprime[1] = j = 0;
split.c:    if (isprime[i]) prime[j++] = i;
split.c:void primefactors (int n, int *factors, int *nfact) {
split.c:  int prime[MAXPRIME];
split.c:  buildprime(prime);
split.c:  while (n > 1) {
split.c:    if (n % prime[j]) { // Remainder of n/prime[j] True if n%prime[j]>0
split.c:    else {
split.c:      n /= prime[j];
split.c:      factors[k++] = prime[j];
split.c:void repartition (int *nx, int ncpu, int *MX) {
split.c:  real best = 1e30;
split.c:  primefactors (ncpu, factors, &nfact); // Decompose ncpu into prime factors
split.c:    pow2[i] = (int)(pow(2.0,(real)i)+.01); //Storing powers of 2
split.c:  ncomb = pow2[nfact]; // Number of possibilities 2^(#fact)
split.c:    if (idx < best) {
split.c:      best = idx;
split.c:#ifdef DEBUG
split.c:#endif
split.c:  int ixceldas, iyceldas;
split.c:  int resto, cociente;
split.c:#ifdef DEBUG
split.c:  char filename[200];
split.c:  FILE *grid_file;
split.c:  sprintf(filename, "%sgrid%03d.inf", OUTPUTDIR, CPU_Rank);
split.c:  grid_file = fopen_prs (filename, "w");
split.c:#endif
split.c:  repartition (nx, CPU_Number, MX);
split.c:  ix = CPU_Rank % MX[0]; //Coordinates of the grid of CPUs
split.c:  resto = nx[0] % MX[0];
split.c:  cociente = nx[0] / MX[0];
split.c:  //Round robin size distribution
split.c:  if (ix < resto) {
split.c:    tamanyox = cociente + 1;
split.c:    ixceldas = ix*(cociente+1);
split.c:  } else {
split.c:    tamanyox = cociente;
split.c:    ixceldas = ix*cociente+resto;
split.c:  resto = nx[1] % MX[1];
split.c:  cociente = nx[1] / MX[1];
split.c:  if (iy < resto) {
split.c:    tamanyoy = cociente + 1;
split.c:    iyceldas = iy*(cociente+1);
split.c:  } else {
split.c:    tamanyoy = cociente;
split.c:    iyceldas = iy*cociente+resto;
split.c:  Gridd.stride = (Gridd.nx+2*NGHX)*(Gridd.ny+2*NGHY);
split.c:  Stride = Gridd.stride;
split.c:  y0cell = ixceldas;
split.c:  z0cell = iyceldas;
split.c:  Y0 = y0cell;
split.c:  Z0 = z0cell;
split.c:#ifdef DEBUG
split.c:  fprintf(grid_file, "CPU_Rank\tY0\tYN\tZ0\tZN\tIndexY\tIndexZ\n");
split.c:  fprintf(grid_file, "%d\t%d\t%d\t%d\t%d\t%d\t%d\n",CPU_Rank, \
split.c:  	  y0cell, y0cell+tamanyox-1, z0cell ,z0cell+tamanyoy-1, J, K);
split.c:  fclose(grid_file);
split.c:#endif
split.c:  Xmin = (real *)malloc(sizeof(real)*(Nx+2*NGHX+1));
split.c:  Ymin = (real *)malloc(sizeof(real)*(Ny+2*NGHY+1));
split.c:  Zmin = (real *)malloc(sizeof(real)*(Nz+2*NGHZ+1));
split.c:  Xmed = (real *)malloc(sizeof(real)*(Nx+2*NGHX));
split.c:  Ymed = (real *)malloc(sizeof(real)*(Ny+2*NGHY));
split.c:  Zmed = (real *)malloc(sizeof(real)*(Nz+2*NGHZ));
split.c:  InvDiffXmed = (real *)malloc(sizeof(real)*(Nx+2*NGHX));
split.c:  Sxi  = (real *)malloc(sizeof(real)*(Nx+2*NGHX));
split.c:  Sxj  = (real *)malloc(sizeof(real)*(Ny+2*NGHY));
split.c:  Syj  = (real *)malloc(sizeof(real)*(Ny+2*NGHY));
split.c:  Szj  = (real *)malloc(sizeof(real)*(Ny+2*NGHY));
split.c:  Sxk  = (real *)malloc(sizeof(real)*(Nz+2*NGHZ));
split.c:  Syk  = (real *)malloc(sizeof(real)*(Nz+2*NGHZ));
split.c:  Szk  = (real *)malloc(sizeof(real)*(Nz+2*NGHZ));
split.c:  InvVj = (real *)malloc(sizeof(real)*(Ny+2*NGHY));
split.c:  ycells = ixceldas;
split.c:  zcells = iyceldas;
split.c:  Gridd.bc_left  = ((J == 0)         ? 1 : 0);
split.c:#ifdef GPU
split.c:  DevMalloc(&Xmin_d,sizeof(real)*(Nx+2*NGHX+1));
split.c:  DevMalloc(&Ymin_d,sizeof(real)*(Ny+2*NGHY+1));
split.c:  DevMalloc(&Zmin_d,sizeof(real)*(Nz+2*NGHZ+1));
split.c:  DevMalloc(&Sxi_d,sizeof(real)*(Nx+2*NGHX));
split.c:  DevMalloc(&InvDiffXmed_d,sizeof(real)*(Nx+2*NGHX));
split.c:  DevMalloc(&Sxj_d,sizeof(real)*(Ny+2*NGHY));
split.c:  DevMalloc(&Syj_d,sizeof(real)*(Ny+2*NGHY));
split.c:  DevMalloc(&Szj_d,sizeof(real)*(Ny+2*NGHY));
split.c:  DevMalloc(&Sxk_d,sizeof(real)*(Nz+2*NGHZ));
split.c:  DevMalloc(&Syk_d,sizeof(real)*(Nz+2*NGHZ));
split.c:  DevMalloc(&Szk_d,sizeof(real)*(Nz+2*NGHZ));
split.c:  DevMalloc(&InvVj_d,sizeof(real)*(Ny+2*NGHY));
split.c:  DevMalloc(&Alpha_d,sizeof(real)*NFLUIDS*NFLUIDS);
split.c:#endif
split.c:  //We allocate and initialize the memory of the collision matrix
split.c:  Alpha = (real*) calloc(NFLUIDS*NFLUIDS,sizeof(real));
stockholm.c://#define __GPU
stockholm.c://#define __NOPROTO
stockholm.c:#include "fargo3d.h"
stockholm.c:void StockholmBoundary_cpu(real dt) {
stockholm.c:  INPUT(Density);
stockholm.c:  INPUT2D(Density0);
stockholm.c:  OUTPUT(Density);
stockholm.c:#ifdef ADIABATIC
stockholm.c:  INPUT(Energy);
stockholm.c:  INPUT2D(Energy0);
stockholm.c:  OUTPUT(Energy);
stockholm.c:#endif
stockholm.c:#ifdef X
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:#endif
stockholm.c:#ifdef Z
stockholm.c:#endif
stockholm.c:  real* rho  = Density->field_cpu;
stockholm.c:  real* rho0 = Density0->field_cpu;
stockholm.c:#ifdef X
stockholm.c:  real* vx  = Vx->field_cpu;
stockholm.c:  real* vx0 = Vx0->field_cpu;
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:  real* vy  = Vy->field_cpu;
stockholm.c:  real* vy0 = Vy0->field_cpu;
stockholm.c:#endif
stockholm.c:#ifdef Z
stockholm.c:  real* vz  = Vz->field_cpu;
stockholm.c:  real* vz0 = Vz0->field_cpu;
stockholm.c:#endif
stockholm.c:#ifdef ADIABATIC
stockholm.c:  real* e    = Energy->field_cpu;
stockholm.c:  real* e0   = Energy0->field_cpu;
stockholm.c:#endif
stockholm.c:  int stride  = Stride_cpu;
stockholm.c:  int size_x  = Nx+2*NGHX;
stockholm.c:  int size_y  = Ny+2*NGHY;
stockholm.c:  int size_z  = Nz+2*NGHZ;
stockholm.c:  real y_min = YMIN;
stockholm.c:  real y_max = YMAX;
stockholm.c:  real z_min = ZMIN;
stockholm.c:  real z_max = ZMAX;
stockholm.c:  real dampingzone = DAMPINGZONE;
stockholm.c:  real kbcol = KILLINGBCCOLATITUDE;
stockholm.c:  real of    = OMEGAFRAME;
stockholm.c:  real of0   = OMEGAFRAME0;
stockholm.c:  real r0 = R0;
stockholm.c:  real ds = TAUDAMP;
stockholm.c:  int periodic_z = PERIODICZ;
stockholm.c:  //  Similar to Benitez-Llambay et al. (2016), Eq. 7.
stockholm.c:  real Y_inf = y_min*pow(dampingzone, 2.0/3.0);
stockholm.c:  real Y_sup = y_max*pow(dampingzone,-2.0/3.0);
stockholm.c:  real Z_inf = z_min - (z_max-z_min); // Here we push Z_inf & Z_sup
stockholm.c:  real Z_sup = z_max + (z_max-z_min); // out of the mesh
stockholm.c:#ifdef CYLINDRICAL
stockholm.c:  if (periodic_z) { // Push Z_inf & Z_sup out of mesh if periodic in Z
stockholm.c:#endif
stockholm.c:#ifdef SPHERICAL
stockholm.c:  Z_sup = M_PI/2.0+(M_PI/2.0-z_min)*(1.0-kbcol); // Avoid damping in ghost zones
stockholm.c:  // if only half upper disk is covered by the mesh
stockholm.c:#endif
stockholm.c:  real radius;
stockholm.c:  real vx0_target;
stockholm.c:  real rampy;
stockholm.c:  real rampz;
stockholm.c:  real rampzz;
stockholm.c:  real rampi;
stockholm.c:  real ramp;
stockholm.c:  real tau;
stockholm.c:  real taud;
stockholm.c:// real xmin(Nx+1);
stockholm.c:// real ymin(Ny+2*NGHY+1);
stockholm.c:// real zmin(Nz+2*NGHZ+1);
stockholm.c:#ifdef Z
stockholm.c:  for (k=0; k<size_z; k++) {
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:    for (j=0; j<size_y; j++) {
stockholm.c:#endif
stockholm.c:#ifdef X
stockholm.c:      for (i=0; i<size_x; i++) {
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:	if(ymed(j) > Y_sup) {
stockholm.c:	  rampy   = (ymed(j)-Y_sup)/(y_max-Y_sup);
stockholm.c:	if(ymed(j) < Y_inf) {
stockholm.c:	  rampy   = (Y_inf-ymed(j))/(Y_inf-y_min);
stockholm.c:	rampy *= rampy;		/* Parabolic ramp as in De Val Borro et al (2006) */
stockholm.c:#endif
stockholm.c:#ifdef Z
stockholm.c:	if(zmed(k) > Z_sup) {
stockholm.c:	  rampz   = (zmed(k)-Z_sup)/(z_max-Z_sup);
stockholm.c:	if(zmed(k) < Z_inf) {
stockholm.c:	  rampz   = (Z_inf-zmed(k))/(Z_inf-z_min);
stockholm.c:	rampz = rampz * rampz;		/* vertical ramp in X^2 */
stockholm.c:	rampzz= rampzz * rampzz;		/* vertical ramp in X^2 */
stockholm.c:#endif
stockholm.c:	if (periodic_z) {
stockholm.c:	tau = ds*sqrt(ymed(j)*ymed(j)*ymed(j)/G/MSTAR);
stockholm.c:#ifdef X
stockholm.c:	  vx0_target = vx0[l2D];
stockholm.c:	  radius = ymed(j);
stockholm.c:#ifdef SPHERICAL
stockholm.c:	  radius *= sin(zmed(k));
stockholm.c:#endif
stockholm.c:	  vx0_target -= (of-of0)*radius;
stockholm.c:	  vx[l] = (vx[l]*taud+vx0_target*dt)/(dt+taud);
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:#endif
stockholm.c:#ifdef Z
stockholm.c:#endif
stockholm.c:#ifdef X
stockholm.c:#endif
stockholm.c:#ifdef Y
stockholm.c:#endif
stockholm.c:#ifdef Z
stockholm.c:#endif
stretch.c:#include "fargo3d.h"
stretch.c:void RestartStretch (Field *field, int n) {
stretch.c:  real *f;
stretch.c:  char *name;
stretch.c:  char filename[200];
stretch.c:  size_t sz, exp_sz, size_ratio;
stretch.c:  int temp, Nxp;
stretch.c:  OUTPUT(field);
stretch.c:  f = field->field_cpu;
stretch.c:  name = field->name;
stretch.c:  sprintf(filename, "%s%s%d.dat", OUTPUTDIR, name, n);
stretch.c:  fi = fopen(filename, "r");
stretch.c:    masterprint("Error reading %s\n", filename);
stretch.c:    exit(1);
stretch.c:  fseek (fi, 0L, SEEK_END);
stretch.c:  sz = ftell(fi);  // File size
stretch.c:  fseek (fi, 0L, SEEK_SET);
stretch.c:  exp_sz = NX*NY*NZ*sizeof(real); // Expected file size
stretch.c:  if (exp_sz % sz != 0) {
stretch.c:    fprintf (stderr,"Mesh size is not a multiple of size of mesh to strech. Aborting.\n");
stretch.c:    MPI_Finalize ();
stretch.c:    exit (EXIT_FAILURE);
stretch.c:  size_ratio = exp_sz / sz;
stretch.c:  Nxp = Nx / size_ratio;
stretch.c:  masterprint("Expanding %s a factor %dx in X\n", filename, (int)size_ratio);
stretch.c:  origin = (z0cell)*Nxp*NY + (y0cell)*Nxp; //z0cell and y0cell are global variables.
stretch.c:      fseek(fi, (origin+(k-NGHZ)*Nxp*NY+(j-NGHY)*Nxp)*sizeof(real), SEEK_SET); 
stretch.c:      temp = fread(f+j*(Nx+2*NGHX)+k*Stride+NGHX, sizeof(real), Nxp, fi);
stretch.c:      for (i = NX+NGHX-1; i>=0; i--) //backward sweep as we overwrite data
stretch.c:	f[l] = f[(i-NGHX)/size_ratio + j*(Nx+2*NGHX) + k*Stride+NGHX];
stretch.c:  masterprint("%s OK\n", filename);
stretch.c:  fclose(fi);
stretch.c:void StretchOutput (int n) {
stretch.c:  RestartStretch(Density, n);
stretch.c:#ifdef X	
stretch.c:  RestartStretch(Vx, n);
stretch.c:#endif
stretch.c:#ifdef Y	
stretch.c:  RestartStretch(Vy, n);
stretch.c:#endif
stretch.c:#ifdef Z	
stretch.c:  RestartStretch(Vz, n);
stretch.c:#endif
stretch.c:  if(Fluidtype != DUST) RestartStretch(Energy, n);
stretch.c:#ifdef MHD
stretch.c:  RestartStretch(Bx, n);
stretch.c:  RestartStretch(By, n);
stretch.c:  RestartStretch(Bz, n);
stretch.c:#endif
substep1_x.c://#define __GPU
substep1_x.c://#define __NOPROTO
substep1_x.c:#include "fargo3d.h"
substep1_x.c:void SubStep1_x_cpu (real dt) {
substep1_x.c:  INPUT(Pressure);
substep1_x.c:  INPUT(Density);
substep1_x.c:#ifdef MHD
substep1_x.c:#if defined (CYLINDRICAL) || defined (SPHERICAL)
substep1_x.c:#endif
substep1_x.c:#endif  
substep1_x.c:  OUTPUT(Vx_temp);
substep1_x.c:  real* p   = Pressure->field_cpu;
substep1_x.c:  real* pot = Pot->field_cpu;
substep1_x.c:  real* rho = Density->field_cpu;
substep1_x.c:#ifdef X
substep1_x.c:  real* vx      = Vx->field_cpu;
substep1_x.c:  real* vx_temp = Vx_temp->field_cpu;
substep1_x.c:#endif
substep1_x.c:#ifdef MHD
substep1_x.c:  real* bx = Bx->field_cpu;
substep1_x.c:  real* by = By->field_cpu;
substep1_x.c:  real* bz = Bz->field_cpu;
substep1_x.c:#endif
substep1_x.c:  int stride = Stride_cpu;
substep1_x.c:  int size_x = XIP; 
substep1_x.c:  int size_y = Ny+2*NGHY-1;
substep1_x.c:  int size_z = Nz+2*NGHZ-1;
substep1_x.c:  int fluidtype = Fluidtype;
substep1_x.c:  int i; //Variables reserved
substep1_x.c:  int j; //for the topology
substep1_x.c:  int k; //of the kernels
substep1_x.c:  real dtOVERrhom;
substep1_x.c:  real dxmed;
substep1_x.c:#ifdef X
substep1_x.c:#endif
substep1_x.c:#ifdef Y
substep1_x.c:#endif
substep1_x.c:#ifdef Z
substep1_x.c:#endif
substep1_x.c:#ifdef MHD
substep1_x.c:  real db1;
substep1_x.c:  real db2;
substep1_x.c:  real bmeanm;
substep1_x.c:  real bmean;
substep1_x.c:#if defined (CYLINDRICAL)|| defined (SPHERICAL)
substep1_x.c:  real brmean;
substep1_x.c:#endif
substep1_x.c:#ifdef SPHERICAL
substep1_x.c:  real btmean;
substep1_x.c:#endif
substep1_x.c:#endif
substep1_x.c:// real xmin(Nx+2*NGHX+1);
substep1_x.c:// real ymin(Ny+2*NGHY+1);
substep1_x.c:// real zmin(Nz+2*NGHZ+1);
substep1_x.c:// real InvDiffXmed(Nx+2*NGHX);
substep1_x.c:// real Sxi(Nx+2*NGHX);
substep1_x.c:#ifdef Z
substep1_x.c:  for(k=1; k<size_z; k++) {
substep1_x.c:#endif
substep1_x.c:#ifdef Y
substep1_x.c:    for(j=1; j<size_y; j++) {
substep1_x.c:#endif
substep1_x.c:#ifdef X
substep1_x.c:      for(i=XIM; i<size_x; i++) {
substep1_x.c:#endif
substep1_x.c:#ifdef X
substep1_x.c:#ifdef Y
substep1_x.c:#endif
substep1_x.c:#ifdef Z
substep1_x.c:#endif
substep1_x.c:	dxmed = 0.5*( Sxi(i) + Sxi(ixm) );
substep1_x.c:	dtOVERrhom = 2.*dt/( rho[ll]*Sxi(i) + rho[llxm]*Sxi(ixm) )*dxmed;
substep1_x.c:	vx_temp[ll] = vx[ll];
substep1_x.c:	if(fluidtype != DUST) vx_temp[ll] -=  dtOVERrhom*(p[ll]-p[llxm])*Inv_zone_size_xmed(i,j,k);
substep1_x.c:#ifdef POTENTIAL
substep1_x.c:	vx_temp[ll] -= (pot[ll]-pot[llxm])*dt*Inv_zone_size_xmed(i,j,k);
substep1_x.c:#endif
substep1_x.c:#ifdef MHD
substep1_x.c:	if(fluidtype == GAS) {
substep1_x.c:#ifndef PASSIVEMHD
substep1_x.c:	  bmean  = 0.5*(by[ll] + by[llyp]);
substep1_x.c:	  bmeanm = 0.5*(by[llxm] + by[llxm+pitch]);
substep1_x.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_x.c:#if defined(CYLINDRICAL) || defined(SPHERICAL)
substep1_x.c:	  brmean = .5*(bmean+bmeanm);
substep1_x.c:	  vx_temp[ll] += dtOVERrhom*brmean*bx[ll]/(MU0*ymed(j));
substep1_x.c:#endif
substep1_x.c:	  bmean  = 0.5*(bz[ll] + bz[llzp]);
substep1_x.c:	  bmeanm = 0.5*(bz[llxm] + bz[llxm+stride]);
substep1_x.c:	  db2 = (bmean*bmean-bmeanm*bmeanm);
substep1_x.c:	  vx_temp[ll] -= .5*dtOVERrhom*(db1 + db2)*Inv_zone_size_xmed(i,j,k)/MU0;
substep1_x.c:#ifdef SPHERICAL
substep1_x.c:	btmean = .5*(bmean+bmeanm);
substep1_x.c:	vx_temp[ll] += dtOVERrhom*btmean*cos(zmed(k))*bx[ll]/(MU0*ymed(j)*sin(zmed(k)));
substep1_x.c:#endif
substep1_x.c:#endif
substep1_x.c:#endif
substep1_x.c:#endif
substep1_x.c:#ifdef X
substep1_x.c:#endif
substep1_x.c:#ifdef Y
substep1_x.c:#endif
substep1_x.c:#ifdef Z
substep1_x.c:#endif
substep1_y.c://#define __GPU
substep1_y.c://#define __NOPROTO
substep1_y.c:#include "fargo3d.h"
substep1_y.c:void SubStep1_y_cpu (real dt) {
substep1_y.c:  INPUT(Pressure);
substep1_y.c:  INPUT(Density);
substep1_y.c:#ifdef X
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:#endif
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:#endif
substep1_y.c:  OUTPUT(Vy_temp);
substep1_y.c:#endif
substep1_y.c:#ifdef Z
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:#endif
substep1_y.c:#endif
substep1_y.c:#ifdef MHD
substep1_y.c:#endif
substep1_y.c:  real* p   = Pressure->field_cpu;
substep1_y.c:  real* pot = Pot->field_cpu;
substep1_y.c:  real* rho = Density->field_cpu;
substep1_y.c:#ifdef X
substep1_y.c:  real* vx      = Vx->field_cpu;
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:  real* vx_half = Vx_half->field_cpu;
substep1_y.c:#else
substep1_y.c:  real* vx_half = Vx->field_cpu;
substep1_y.c:#endif
substep1_y.c:  real* vx_temp = Vx_temp->field_cpu;
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:  real* vy      = Vy->field_cpu;
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:  real* vy_half = Vy_half->field_cpu;
substep1_y.c:#else
substep1_y.c:  real* vy_half = Vy->field_cpu;
substep1_y.c:#endif
substep1_y.c:  real* vy_temp = Vy_temp->field_cpu;
substep1_y.c:#endif
substep1_y.c:#ifdef Z
substep1_y.c:  real* vz      = Vz->field_cpu;
substep1_y.c:#ifdef COLLISIONPREDICTOR
substep1_y.c:  real* vz_half = Vz_half->field_cpu;
substep1_y.c:#else
substep1_y.c:  real* vz_half = Vz->field_cpu;
substep1_y.c:#endif
substep1_y.c:  real* vz_temp = Vz_temp->field_cpu;
substep1_y.c:#endif
substep1_y.c:#ifdef MHD
substep1_y.c:  real* bx = Bx->field_cpu;
substep1_y.c:  real* bz = Bz->field_cpu;
substep1_y.c:#endif
substep1_y.c:  int stride = Stride_cpu;
substep1_y.c:  int size_x = XIP; 
substep1_y.c:  int size_y = Ny+2*NGHY-1;
substep1_y.c:  int size_z = Nz+2*NGHZ-1;
substep1_y.c:  int fluidtype = Fluidtype;
substep1_y.c:  int i; //Variables reserved
substep1_y.c:  int j; //for the topology
substep1_y.c:  int k; //of the kernels
substep1_y.c:  real dtOVERrhom;
substep1_y.c:#ifdef X
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:#endif
substep1_y.c:#ifdef Z
substep1_y.c:#endif
substep1_y.c:#ifdef MHD
substep1_y.c:  real db1;
substep1_y.c:  real db2;
substep1_y.c:  real bmeanm;
substep1_y.c:  real bmean;
substep1_y.c:#endif
substep1_y.c:#ifndef CARTESIAN
substep1_y.c:  real vphi;
substep1_y.c:#endif
substep1_y.c:#ifdef SHEARINGBOX
substep1_y.c:  real vm;
substep1_y.c:#endif
substep1_y.c:#ifdef SPHERICAL
substep1_y.c:  real vzz;
substep1_y.c:#endif
substep1_y.c:// real xmin(Nx+2*NGHX+1);
substep1_y.c:// real ymin(Ny+2*NGHY+1);
substep1_y.c:// real zmin(Nz+2*NGHZ+1);
substep1_y.c:// real OMEGAFRAME(1);
substep1_y.c:// real OORTA(1);
substep1_y.c:#ifdef Z
substep1_y.c:  for(k=1; k<size_z; k++) {
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:    for(j=1; j<size_y; j++) {
substep1_y.c:#endif
substep1_y.c:#ifdef X
substep1_y.c:      for(i=XIM; i<size_x; i++) {
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:#ifdef X
substep1_y.c:#endif //ENDIF X
substep1_y.c:#ifdef Z
substep1_y.c:#endif //ENDIF Z
substep1_y.c:	dtOVERrhom = 2.0*dt/(rho[ll]*(ymin(j+1)-ymin(j))+rho[llym]*(ymin(j)-ymin(j-1)))*(ymed(j)-ymed(j-1));
substep1_y.c:	vy_temp[ll] = vy[ll];
substep1_y.c:	if(fluidtype != DUST) vy_temp[ll]-=  dtOVERrhom*(p[ll]-p[llym])/(ymed(j)-ymed(j-1));
substep1_y.c:#ifdef CARTESIAN
substep1_y.c:#ifdef SHEARINGBOX
substep1_y.c:	vy_temp[l] += dt*(2.0*OMEGAFRAME*vm + 2.0*SHEARPARAM*OMEGAFRAME*OMEGAFRAME*ymin(j));
substep1_y.c:#ifdef DRAGFORCE
substep1_y.c:	if (Fluidtype == GAS) {
substep1_y.c:	  vy_temp[ll] += 2*ASPECTRATIO*ASPECTRATIO*OMEGAFRAME*R0*dt;
substep1_y.c:#endif
substep1_y.c:#endif //ENDIF SHEARINGBOX
substep1_y.c:#ifdef MHD
substep1_y.c:	if(fluidtype==GAS) {
substep1_y.c:#ifndef PASSIVEMHD
substep1_y.c:	  bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_y.c:	  bmeanm = 0.5*(bx[llym] + bx[llxp-pitch]);
substep1_y.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_y.c:	  bmean  = 0.5*(bz[ll] + bz[llzp]);
substep1_y.c:	  bmeanm = 0.5*(bz[llym] + bz[llym+stride]);
substep1_y.c:	  db2 = (bmean*bmean-bmeanm*bmeanm); //grad(b^2/2)
substep1_y.c:	  vy_temp[ll] -= .5*dtOVERrhom*(db1 + db2)/((ymed(j)-ymed(j-1))*MU0);
substep1_y.c:#endif //ENDIF !PASSIVEMHD
substep1_y.c:#endif //ENDIF MHD
substep1_y.c:#endif //ENDIF CARTESIAN
substep1_y.c:#ifdef CYLINDRICAL
substep1_y.c:	vy_temp[ll] += vphi*vphi/ymin(j)*dt;
substep1_y.c:#ifdef MHD
substep1_y.c:	if(fluidtype==GAS) {
substep1_y.c:#ifndef PASSIVEMHD
substep1_y.c:	bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_y.c:	bmeanm = 0.5*(bx[llym] + bx[llxp-pitch]);
substep1_y.c:	vy_temp[ll] -= dtOVERrhom*.25*(bmean+bmeanm)*(bmean+bmeanm)/(MU0*ymin(j));
substep1_y.c:	db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_y.c:	bmean  = 0.5*(bz[ll] + bz[llzp]);
substep1_y.c:	bmeanm = 0.5*(bz[llym] + bz[llym+stride]);
substep1_y.c:	db2 = (bmean*bmean-bmeanm*bmeanm); //-grad((bphi^2+bz^2)/2)
substep1_y.c:	vy_temp[ll] -= .5*dtOVERrhom*(db1 + db2)/((ymed(j)-ymed(j-1))*MU0);
substep1_y.c:#endif //END !PASSIVEMHD
substep1_y.c:#endif //END MHD
substep1_y.c:#endif //END CYLINDRICAL
substep1_y.c:#ifdef SPHERICAL
substep1_y.c:	vphi += ymin(j)*sin(zmed(k))*OMEGAFRAME;
substep1_y.c:	vy_temp[ll] += (vphi*vphi + vzz*vzz)/ymin(j)*dt;
substep1_y.c:#ifdef MHD
substep1_y.c:	if(fluidtype==GAS) {
substep1_y.c:#ifndef PASSIVEMHD
substep1_y.c:	  bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_y.c:	  bmeanm = 0.5*(bx[llym] + bx[llxp-pitch]);
substep1_y.c:	  vy_temp[ll] -= dtOVERrhom*.25*(bmean+bmeanm)*(bmean+bmeanm)/(MU0*ymin(j));//Source term -B_phi^2/(mu_0\rho r)
substep1_y.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_y.c:	  bmean  = 0.5*(bz[ll] + bz[llzp]);
substep1_y.c:	  bmeanm = 0.5*(bz[llym] + bz[llym+stride]);
substep1_y.c:	  vy_temp[ll] -= dtOVERrhom*.25*(bmean+bmeanm)*(bmean+bmeanm)/(MU0*ymin(j));//Source term -B_\theta^2/(mu_0\rho r)
substep1_y.c:	  db2 = (bmean*bmean-bmeanm*bmeanm); //-grad((bphi^2+btheta^2)/2)
substep1_y.c:	  vy_temp[ll] -= .5*dtOVERrhom*(db1 + db2)/((ymed(j)-ymed(j-1))*MU0);
substep1_y.c:#endif //END !PASSIVEMHD
substep1_y.c:#endif //END MHD
substep1_y.c:#endif //END SPHERICAL
substep1_y.c:#ifdef POTENTIAL
substep1_y.c:	  vy_temp[ll] -= (pot[ll]-pot[llym])*dt/(ymed(j)-ymed(j-1));
substep1_y.c:#endif //ENDIF POTENTIAL
substep1_y.c:#endif //ENDIF Y
substep1_y.c:#ifdef X
substep1_y.c:#endif
substep1_y.c:#ifdef Y
substep1_y.c:#endif
substep1_y.c:#ifdef Z
substep1_y.c:#endif
substep1_z.c://#define __GPU
substep1_z.c://#define __NOPROTO
substep1_z.c:#include "fargo3d.h"
substep1_z.c:void SubStep1_z_cpu (real dt) {
substep1_z.c:  INPUT(Pressure);
substep1_z.c:  INPUT(Density);
substep1_z.c:#ifdef X
substep1_z.c:#ifdef COLLISIONPREDICTOR
substep1_z.c:#endif
substep1_z.c:#endif
substep1_z.c:#ifdef Z
substep1_z.c:#endif
substep1_z.c:#ifdef MHD
substep1_z.c:#ifdef SPHERICAL
substep1_z.c:#endif
substep1_z.c:#endif  
substep1_z.c:  OUTPUT(Vz_temp);
substep1_z.c:  real* p   = Pressure->field_cpu;
substep1_z.c:  real* pot = Pot->field_cpu;
substep1_z.c:  real* rho = Density->field_cpu;
substep1_z.c:#ifdef X
substep1_z.c:  real* vx      = Vx->field_cpu;
substep1_z.c:#ifdef COLLISIONPREDICTOR
substep1_z.c:  real* vx_half = Vx_half->field_cpu;
substep1_z.c:#else
substep1_z.c:  real* vx_half = Vx->field_cpu;
substep1_z.c:#endif
substep1_z.c:  real* vx_temp = Vx_temp->field_cpu;
substep1_z.c:#endif
substep1_z.c:#ifdef Z
substep1_z.c:  real* vz      = Vz->field_cpu;
substep1_z.c:  real* vz_temp = Vz_temp->field_cpu;
substep1_z.c:#endif
substep1_z.c:#ifdef MHD
substep1_z.c:  real* bx = Bx->field_cpu;
substep1_z.c:  real* by = By->field_cpu;
substep1_z.c:#ifdef SPHERICAL
substep1_z.c:  real* bz = Bz->field_cpu;
substep1_z.c:#endif
substep1_z.c:#endif
substep1_z.c:  int stride = Stride_cpu;
substep1_z.c:  int size_x = XIP; 
substep1_z.c:  int size_y = Ny+2*NGHY-1;
substep1_z.c:  int size_z = Nz+2*NGHZ-1;
substep1_z.c:  int fluidtype = Fluidtype;
substep1_z.c:  int i; //Variables reserved
substep1_z.c:  int j; //for the topology
substep1_z.c:  int k; //of the kernels
substep1_z.c:  real dtOVERrhom;
substep1_z.c:#ifdef X
substep1_z.c:#endif
substep1_z.c:#ifdef Y
substep1_z.c:#endif
substep1_z.c:#ifdef Z
substep1_z.c:#endif
substep1_z.c:#ifdef MHD
substep1_z.c:  real db1;
substep1_z.c:  real db2;
substep1_z.c:  real bmeanm;
substep1_z.c:  real bmean;
substep1_z.c:#endif
substep1_z.c:  real vphi;
substep1_z.c:// real xmin(Nx+2*NGHX+1);
substep1_z.c:// real ymin(Ny+2*NGHY+1);
substep1_z.c:// real zmin(Nz+2*NGHZ+1);
substep1_z.c:// real OMEGAFRAME(1);
substep1_z.c:#ifdef Z
substep1_z.c:  for(k=1; k<size_z; k++) {
substep1_z.c:#endif
substep1_z.c:#ifdef Y
substep1_z.c:    for(j=1; j<size_y; j++) {
substep1_z.c:#endif
substep1_z.c:#ifdef X
substep1_z.c:      for(i=XIM; i<size_x; i++) {
substep1_z.c:#endif
substep1_z.c:#ifdef Z
substep1_z.c:#ifdef X
substep1_z.c:#endif //END X
substep1_z.c:#ifdef Y
substep1_z.c:#endif //END Y
substep1_z.c:	dtOVERrhom = 2.0*dt/(rho[ll]*(zmin(k+1)-zmin(k))+rho[llzm]*(zmin(k)-zmin(k-1)))*(zmed(k)-zmed(k-1));
substep1_z.c:#ifdef CARTESIAN
substep1_z.c:	vz_temp[ll] = vz[ll];
substep1_z.c:	if(fluidtype != DUST) vz_temp[ll] -= dtOVERrhom*(p[ll]-p[llzm])/(zmed(k)-zmed(k-1));
substep1_z.c:#ifdef POTENTIAL
substep1_z.c:	vz_temp[ll] -= (pot[ll]-pot[llzm]) * dt / (zmed(k)-zmed(k-1));
substep1_z.c:#endif //END POTENTIAL
substep1_z.c:#ifdef MHD
substep1_z.c:	if(fluidtype==GAS) {
substep1_z.c:	  bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_z.c:	  bmeanm = 0.5*(bx[llzm] + bx[llxp-stride]);
substep1_z.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  bmean = 0.5*(by[ll] + by[llyp]);
substep1_z.c:	  bmeanm  = 0.5*(by[llzm] + by[llzm+pitch]);
substep1_z.c:	  db2 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  vz_temp[ll] -= .5*dtOVERrhom*(db1 + db2)/(MU0*(zmed(k)-zmed(k-1)));
substep1_z.c:#endif //END MHD
substep1_z.c:#endif //END CARTESIAN
substep1_z.c:#ifdef CYLINDRICAL
substep1_z.c:	vz_temp[ll] = vz[ll];
substep1_z.c:	if(fluidtype != DUST) vz_temp[ll] -= dtOVERrhom*(p[ll]-p[llzm])/(zmed(k)-zmed(k-1));
substep1_z.c:#ifdef POTENTIAL
substep1_z.c:	vz_temp[ll] -= (pot[ll]-pot[llzm]) * dt / (zmed(k)-zmed(k-1));
substep1_z.c:#endif //END POTENTIAL
substep1_z.c:#ifdef MHD
substep1_z.c:	if(fluidtype==GAS) {
substep1_z.c:#ifndef PASSIVEMHD
substep1_z.c:	  bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_z.c:	  bmeanm = 0.5*(bx[llzm] + bx[llxp-stride]);
substep1_z.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  bmean = 0.5*(by[ll] + by[llyp]);
substep1_z.c:	  bmeanm  = 0.5*(by[llzm] + by[llzm+pitch]);
substep1_z.c:	  db2 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  vz_temp[l] -= (db1 + db2)/(rho[l]+rho[lzm])*dt/((zmed(k)-zmed(k-1))*MU0);
substep1_z.c:#endif //END PASSIVEMHD
substep1_z.c:#endif //END MHD
substep1_z.c:#endif //END CYLINDRICAL
substep1_z.c:#ifdef SPHERICAL
substep1_z.c:	vphi = .25*(vx_half[ll] + vx_half[llxp] + vx_half[llzm] + vx_half[llxp-stride]);
substep1_z.c:	vphi += ymed(j)*sin(zmin(k))*OMEGAFRAME;
substep1_z.c:	vz_temp[ll] = vz[ll];
substep1_z.c:	if(fluidtype != DUST) vz_temp[ll] -= dtOVERrhom*(p[ll]-p[llzm])/(ymed(j)*(zmed(k)-zmed(k-1)));
substep1_z.c:	vz_temp[ll] += vphi*vphi*cos(zmin(k))/(sin(zmin(k))*ymed(j))*dt;
substep1_z.c:#ifdef POTENTIAL
substep1_z.c:	vz_temp[ll] -= (pot[ll]-pot[llzm]) * dt / (ymed(j)*(zmed(k)-zmed(k-1)));
substep1_z.c:#endif //END POTENTIAL
substep1_z.c:#ifdef MHD
substep1_z.c:	if(fluidtype==GAS) {
substep1_z.c:#ifndef PASSIVEMHD
substep1_z.c:	  bmean  = 0.5*(bx[ll] + bx[llxp]);
substep1_z.c:	  bmeanm = 0.5*(bx[llzm] + bx[llxp-stride]);
substep1_z.c:	  db1 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  vz_temp[ll] -= (dtOVERrhom*.25*(bmean+bmeanm)*(bmean+bmeanm)	\
substep1_z.c:			  *cos(zmin(k))/sin(zmin(k))/(MU0*ymed(j)));
substep1_z.c:	  /* Above: geometric source term -B_\phi^2*cot(theta)/(mu0*rho*r) */
substep1_z.c:	  bmean = 0.5*(by[ll] + by[llyp]);
substep1_z.c:	  bmeanm  = 0.5*(by[llzm] + by[llzm+pitch]);
substep1_z.c:	  db2 = (bmean*bmean-bmeanm*bmeanm);
substep1_z.c:	  vz_temp[ll] += dtOVERrhom*bz[ll]*.5*(bmean+bmeanm)/(MU0*ymed(j));
substep1_z.c:	  /* Above: geometric source term +B_r * B_\theta/(MU0*rho*r) */
substep1_z.c:	  vz_temp[ll] -= .5*dtOVERrhom*(db1 + db2)/(ymed(j)*(zmed(k)-zmed(k-1))*MU0);
substep1_z.c:#endif //END !PASSIVEMHD
substep1_z.c:#endif //END MHD
substep1_z.c:#endif //END SPHERICAL
substep1_z.c:#endif //END Z
substep1_z.c:#ifdef X
substep1_z.c:#endif
substep1_z.c:#ifdef Y
substep1_z.c:#endif
substep1_z.c:#ifdef Z
substep1_z.c:#endif
substep2_a.c://#define __GPU
substep2_a.c://#define __NOPROTO
substep2_a.c:#include "fargo3d.h"
substep2_a.c:void SubStep2_a_cpu (real dt) {
substep2_a.c:  INPUT(Density);
substep2_a.c:  INPUT(Pressure);
substep2_a.c:#ifdef X
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:#else 
substep2_a.c:#endif
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:#else 
substep2_a.c:#endif
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:#else 
substep2_a.c:#endif
substep2_a.c:#endif
substep2_a.c:  real* rho    = Density->field_cpu;
substep2_a.c:  real* p      = Pressure->field_cpu;
substep2_a.c:#ifdef X
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:  real* vx     = Vx_half->field_cpu;
substep2_a.c:#else
substep2_a.c:  real* vx     = Vx->field_cpu;
substep2_a.c:#endif 
substep2_a.c:  real* pres_x = Mpx->field_cpu;
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:  real* vy     = Vy_half->field_cpu;
substep2_a.c:#else
substep2_a.c:  real* vy     = Vy->field_cpu;
substep2_a.c:#endif 
substep2_a.c:  real* pres_y = Mpy->field_cpu;
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:#ifdef COLLISIONPREDICTOR
substep2_a.c:  real* vz     = Vz_half->field_cpu;
substep2_a.c:#else
substep2_a.c:  real* vz     = Vz->field_cpu;
substep2_a.c:#endif 
substep2_a.c:  real* pres_z = Mpz->field_cpu;
substep2_a.c:#endif
substep2_a.c:  int stride   = Stride_cpu;
substep2_a.c:  int size_x   = XIP; 
substep2_a.c:  int size_y   = Ny+2*NGHY-1;
substep2_a.c:  int size_z   = Nz+2*NGHZ-1;
substep2_a.c:#ifdef X
substep2_a.c:  real dvx;
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:  real dvy;
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:  real dvz;
substep2_a.c:#endif
substep2_a.c://real GAMMA(1);
substep2_a.c:#ifdef Z
substep2_a.c:  for(k=0; k<size_z; k++) {
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:    for(j=0; j<size_y; j++) {
substep2_a.c:#endif
substep2_a.c:#ifdef X
substep2_a.c:      for(i=0; i<size_x; i++) {
substep2_a.c:#endif
substep2_a.c:#ifdef X
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:#endif
substep2_a.c:#ifdef X
substep2_a.c:	  pres_x[ll] = CVNR*CVNR*rho[ll]*dvx*dvx;
substep2_a.c:#ifdef STRONG_SHOCK
substep2_a.c:	  pres_x[ll] -= CVNL*rho[ll]*sqrt(GAMMA*fabs(p[ll]/rho[ll]))*dvx;
substep2_a.c:#endif
substep2_a.c:	else {
substep2_a.c:	  pres_x[ll] = 0.0;
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:	  pres_y[ll] = CVNR*CVNR*rho[ll]*dvy*dvy;
substep2_a.c:#ifdef STRONG_SHOCK
substep2_a.c:	  pres_y[ll] -= CVNL*rho[ll]*sqrt(GAMMA*fabs(p[ll]/rho[ll]))*dvy;
substep2_a.c:#endif
substep2_a.c:	else {
substep2_a.c:	  pres_y[ll] = 0.0;
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:	  pres_z[ll] = CVNR*CVNR*rho[ll]*dvz*dvz;
substep2_a.c:#ifdef STRONG_SHOCK
substep2_a.c:	  pres_z[ll] -= CVNL*rho[ll]*sqrt(GAMMA*fabs(p[ll]/rho[ll]))*dvz;
substep2_a.c:#endif
substep2_a.c:	else {
substep2_a.c:	  pres_z[ll] = 0.0;
substep2_a.c:#endif
substep2_a.c:#ifdef X
substep2_a.c:#endif
substep2_a.c:#ifdef Y
substep2_a.c:#endif
substep2_a.c:#ifdef Z
substep2_a.c:#endif
substep2_b.c://#define __GPU
substep2_b.c://#define __NOPROTO
substep2_b.c:#include "fargo3d.h"
substep2_b.c:void SubStep2_b_cpu (real dt) {
substep2_b.c:  INPUT(Density);
substep2_b.c:#ifdef X
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:#else
substep2_b.c:#endif
substep2_b.c:  INPUT(Vx_temp);
substep2_b.c:  OUTPUT(Vx_temp);
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:#else
substep2_b.c:#endif
substep2_b.c:  INPUT(Vy_temp);
substep2_b.c:  OUTPUT(Vy_temp);
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:#else
substep2_b.c:#endif
substep2_b.c:  INPUT(Vz_temp);
substep2_b.c:  OUTPUT(Vz_temp);
substep2_b.c:#endif
substep2_b.c:#ifdef ADIABATIC
substep2_b.c:  INPUT(Energy);
substep2_b.c:  OUTPUT(Energy);
substep2_b.c:#endif
substep2_b.c:  real* rho = Density->field_cpu;
substep2_b.c:#ifdef X
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:  real* vx = Vx_half->field_cpu;
substep2_b.c:#else
substep2_b.c:  real* vx = Vx->field_cpu;
substep2_b.c:#endif
substep2_b.c:  real* vx_temp = Vx_temp->field_cpu;
substep2_b.c:  real* pres_x = Mpx->field_cpu;
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:  real* vy = Vy_half->field_cpu;
substep2_b.c:#else
substep2_b.c:  real* vy = Vy->field_cpu;
substep2_b.c:#endif
substep2_b.c:  real* vy_temp = Vy_temp->field_cpu;
substep2_b.c:  real* pres_y = Mpy->field_cpu;
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:#ifdef COLLISIONPREDICTOR
substep2_b.c:  real* vz = Vz_half->field_cpu;
substep2_b.c:#else
substep2_b.c:  real* vz = Vz->field_cpu;
substep2_b.c:#endif
substep2_b.c:  real* vz_temp = Vz_temp->field_cpu;
substep2_b.c:  real* pres_z = Mpz->field_cpu;
substep2_b.c:#endif
substep2_b.c:#ifdef ADIABATIC
substep2_b.c:  real* e = Energy->field_cpu;
substep2_b.c:#endif  
substep2_b.c:  int stride = Stride_cpu;
substep2_b.c:  int size_x = XIP; 
substep2_b.c:  int size_y = Ny+2*NGHY-1;
substep2_b.c:  int size_z = Nz+2*NGHZ-1;
substep2_b.c:  int fluidtype = Fluidtype;
substep2_b.c:#ifdef X
substep2_b.c:  real dxmed;
substep2_b.c:  real dxrho1;
substep2_b.c:  real dxrho2;
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:  real dyrho1;
substep2_b.c:  real dyrho2;
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:  real dzmed;
substep2_b.c:  real dzrho1;
substep2_b.c:  real dzrho2;
substep2_b.c:#endif
substep2_b.c:// real xmin(Nx+1);
substep2_b.c:// real ymin(Ny+2*NGHY+1);
substep2_b.c:// real zmin(Nz+2*NGHZ+1);
substep2_b.c:// real Sxi(Nx);
substep2_b.c:// real InvDiffXmed(Nx);
substep2_b.c:#ifdef Z
substep2_b.c:  for(k=1; k<size_z; k++) {
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:    for(j=1; j<size_y; j++) {
substep2_b.c:#endif
substep2_b.c:#ifdef X
substep2_b.c:      for(i=XIM; i<size_x; i++) {
substep2_b.c:#endif	
substep2_b.c:#ifdef X
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:#endif
substep2_b.c:#ifdef X
substep2_b.c:	dxmed  = 0.5*( Sxi(i) + Sxi(ixm) );
substep2_b.c:	vx_temp[ll] += - 2.0*dt*dxmed*(pres_x[ll]-pres_x[llxm])/(rho[ll]*dxrho1+rho[llxm]*dxrho2)*Inv_zone_size_xmed(i,j,k);
substep2_b.c:#ifdef ADIABATIC
substep2_b.c:	e[ll] += -dt*(pres_x[ll]*(vx[llxp]-vx[ll])/zone_size_x(i,j,k));
substep2_b.c:#endif
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:	//ymed(j)-ymed(j-1) cancels out (see substep1_y.c)
substep2_b.c:	vy_temp[ll] += - 2.0*(pres_y[ll]-pres_y[llym])/(rho[ll]*dyrho1+rho[llym]*dyrho2)*dt;
substep2_b.c:#ifdef ADIABATIC
substep2_b.c:	e[ll] += -dt*(pres_y[ll]*(vy[llyp]-vy[ll])/zone_size_y(j,k));
substep2_b.c:#endif
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:	dzmed  = zmed(k)-zmed(k-1);
substep2_b.c:#ifdef SPHERICAL
substep2_b.c:	vz_temp[ll] += -2.0*dzmed*(pres_z[ll]-pres_z[llzm])/(rho[ll]*dzrho1+rho[llzm]*dzrho2)*dt/( ymed(j)*(zmed(k)-zmed(k-1)));
substep2_b.c:#else
substep2_b.c:	vz_temp[ll] += -2.0*(pres_z[ll]-pres_z[llzm])/(rho[ll]*dzrho1+rho[llzm]*dzrho2)*dt;
substep2_b.c:#endif
substep2_b.c:#ifdef ADIABATIC
substep2_b.c:	e[ll] += -dt*(pres_z[ll]*(vz[llzp]-vz[ll])/zone_size_z(j,k));
substep2_b.c:#endif
substep2_b.c:#endif
substep2_b.c:#ifdef X
substep2_b.c:#endif
substep2_b.c:#ifdef Y
substep2_b.c:#endif
substep2_b.c:#ifdef Z
substep2_b.c:#endif
substep3.c://#define __GPU
substep3.c://#define __NOPROTO
substep3.c:#include "fargo3d.h"
substep3.c:void SubStep3_cpu (real dt) {
substep3.c:  INPUT(Energy);
substep3.c:#ifdef X
substep3.c:  INPUT(Vx_temp);
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:  INPUT(Vy_temp);
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:  INPUT(Vz_temp);
substep3.c:#endif
substep3.c:  OUTPUT(Energy);
substep3.c:  real* e   = Energy->field_cpu;
substep3.c:#ifdef X
substep3.c:  real* vx  = Vx_temp->field_cpu;
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:  real* vy  = Vy_temp->field_cpu;
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:  real* vz  = Vz_temp->field_cpu;
substep3.c:#endif
substep3.c:  int stride = Stride_cpu;
substep3.c:  int size_x = XIP; 
substep3.c:  int size_y = Ny+2*NGHY-1;
substep3.c:  int size_z = Nz+2*NGHZ-1;
substep3.c:  int i; //Variables reserved
substep3.c:  int j; //for the topology
substep3.c:  int k; //of the kernels
substep3.c:#ifdef X
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:#endif
substep3.c:  real term;
substep3.c:  real div_v;
substep3.c:// real GAMMA(1);
substep3.c:// real Sxi(Nx);
substep3.c:// real Sxj(Ny+2*NGHY);
substep3.c:// real Syj(Ny+2*NGHY);
substep3.c:// real Szj(Ny+2*NGHY);
substep3.c:// real Sxk(Nz+2*NGHZ);
substep3.c:// real Syk(Nz+2*NGHZ);
substep3.c:// real Szk(Nz+2*NGHZ);
substep3.c:// real InvVj(Ny+2*NGHY);
substep3.c:#ifdef Z
substep3.c:  for(k=0; k<size_z; k++) {
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:    for(j=0; j<size_y; j++) {
substep3.c:#endif
substep3.c:#ifdef X
substep3.c:      for(i=0; i<size_x; i++) {
substep3.c:#endif
substep3.c:#ifdef X
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:#endif
substep3.c:#ifdef X
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:#endif
substep3.c:	term = 0.5 * dt * (GAMMA - 1.) * div_v * InvVol(i,j,k);
substep3.c:	e[ll] *= (1.0-term)/(1.0+term);
substep3.c:#ifdef X
substep3.c:#endif
substep3.c:#ifdef Y
substep3.c:#endif
substep3.c:#ifdef Z
substep3.c:#endif
summary.c:#include <fargo3d.h>
summary.c:extern Param Var_Set[];
summary.c:extern int Id_Var;
summary.c:char dummy_end='\0';
summary.c:void SelectArchFileName () {
summary.c:  char Fullname[1024];
summary.c:  if (!CPU_Master)
summary.c:    return;
summary.c:  sprintf (Fullname, "%s/sources%d.tar.bz2", OUTPUTDIR, i);
summary.c:  sprintf (ArchFile, "sources%d.tar.bz2", i);
summary.c:  while ( access(Fullname, F_OK ) != -1 ) {
summary.c:    sprintf (Fullname, "%s/sources%d.tar.bz2", OUTPUTDIR, i);
summary.c:    sprintf (ArchFile, "sources%d.tar.bz2", i);
summary.c:void StoreFileToChar (char **string, char *filename) {
summary.c:  long size;
summary.c:  if (CPU_Master) {
summary.c:    input = fopen (filename, "r");
summary.c:      mastererr ("Cannot open %s in StoreFileToChar.\n", filename);
summary.c:      prs_exit (1);
summary.c:    fseek (input, 0, SEEK_END);
summary.c:    size = ftell(input);
summary.c:    fseek (input, 0, SEEK_SET);
summary.c:    *string = (char *)malloc(size+1);
summary.c:    if (fread (*string, 1, size, input) != size) {
summary.c:      mastererr ("Could not read correctly %s\n", filename);
summary.c:      prs_exit (1);
summary.c:    fclose (input);
summary.c:    (*string)[size]=0;
summary.c:char *ExtractFromExecutable (boolean tostring, char *filename, int position) {
summary.c:  char execname[1024];
summary.c:  int length, count=0, foo;
summary.c:  /* We search the full path of the executable */
summary.c:  /* We assume it is not in the PATH variable (there is no simple,
summary.c:     portable way to find the full path in this case) */
summary.c:    return &dummy_end;
summary.c:  lfoo = (long)getcwd(CurrentWorkingDirectory, 1023);
summary.c:  sprintf (execname, "%s/%s", CurrentWorkingDirectory, FirstCommand);
summary.c:  input = fopen (execname, "r");
summary.c:    mastererr ("Cannot open executable file to retrieve information appended.\n");
summary.c:    //We test without CurrentWorking directory because SLURM put as
summary.c:    //first command the full path to the executable.
summary.c:    sprintf (execname, "%s",FirstCommand);
summary.c:    input = fopen (execname, "r");
summary.c:      mastererr ("Cannot open executable file to retrieve information appended.\n");
summary.c:      prs_exit (1);
summary.c:  fseek (input, 0, SEEK_END);
summary.c:    if (fseek (input, -12, SEEK_CUR) < 0) {
summary.c:      mastererr ("Fseek problem in 'ExtractFromExecutable' (1)\n");
summary.c:      prs_exit (1);
summary.c:    length = atoi(string);
summary.c:    if (fseek (input, -12-length, SEEK_CUR) < 0) {
summary.c:      mastererr ("Fseek problem in 'ExtractFromExecutable (2)'\n");
summary.c:      prs_exit (1);
summary.c:  } while (count < position);
summary.c:  longstring = (char *)malloc(length+1);
summary.c:    mastererr ("Not enough memory in 'ExtractFromExecutable'\n");
summary.c:    prs_exit (1);
summary.c:  foo = fread (longstring, length, 1, input);
summary.c:  fclose(input);
summary.c:  longstring[length]=0;
summary.c:    return longstring;
summary.c:  else {
summary.c:    sprintf (cwd, "%s/%s", OUTPUTDIR, filename);
summary.c:    output = fopen (cwd, "w");
summary.c:      mastererr ("Could not open file %s in 'ExtractFromExecutable'\n", cwd);
summary.c:      prs_exit (1);
summary.c:    fwrite (longstring, 1, length, output);
summary.c:    free (longstring);
summary.c:    fclose (output);
summary.c:  return NULL;
summary.c:void GetHostsList () {
summary.c:  char strdevice[1024];
summary.c:  char hostname[1024];
summary.c:  static boolean SpaceReservedForHostnames=NO;
summary.c:  int device;
summary.c:  gethostname(hostname,1023);
summary.c:#ifdef GPU
summary.c:  strcat (hostname, " (device ");
summary.c:  cudaGetDevice (&device);
summary.c:  sprintf (strdevice, "%d", device);
summary.c:  strcat (hostname, strdevice);
summary.c:  strcat (hostname, ")");
summary.c:#endif
summary.c:  if (SpaceReservedForHostnames == NO) {
summary.c:    if (CPU_Master) {
summary.c:      HostsList = (char *)malloc(1024*CPU_Number);
summary.c:	mastererr ("Out of memory in 'summary.c::GetHostsList()'\n");
summary.c:	prs_exit (1);
summary.c:    SpaceReservedForHostnames = YES;
summary.c:  MPI_Gather (hostname, 1024, MPI_CHAR, HostsList, 1024, MPI_CHAR, 0, MPI_COMM_WORLD);
summary.c:  static boolean FirstTime = YES;
summary.c:  char filename[1024];
summary.c:  char hostname[1024];
summary.c:  char sep[]="==============================\n";
summary.c:  time_t t;
summary.c:  int i, type, n;
summary.c:  if (FirstTime == YES) {
summary.c:    StoreFileToChar (&InputFile, ParameterFile);
summary.c:    if (ThereArePlanets)
summary.c:      StoreFileToChar (&PlanetaryFile, PLANETCONFIG);
summary.c:    FirstTime = NO;
summary.c:  if (CPU_Master) {
summary.c:    sprintf (filename, "%s/summary%d.dat", OUTPUTDIR, nout);
summary.c:    sum = fopen_prs (filename, "w");
summary.c:    fprintf (sum, "%sSUMMARY:\n%s",sep,sep);
summary.c:    fprintf (sum, "SETUP '%s' of %s\n", xstr(SETUPNAME), VersionString);
summary.c:#ifdef CARTESIAN
summary.c:    fprintf (sum, "Cartesian ");
summary.c:#endif
summary.c:#ifdef CYLINDRICAL
summary.c:#endif
summary.c:#ifdef SPHERICAL
summary.c:    fprintf (sum, "Spherical ");
summary.c:#endif
summary.c:    fprintf (sum, "mesh of size %d x %d x %d (%d cells in total)\n", NX, NY, NZ, NX*NY*NZ);
summary.c:    fprintf (sum, "%d outputs scheduled\n", NTOT/NINTERM);
summary.c:#ifdef LONGSUMMARY
summary.c:    fprintf (sum, "Source file archive: %s\n", ArchFile);
summary.c:#else
summary.c:    fprintf (sum, "LONGSUMMARY sticky flag not activated: no source file archive\n");
summary.c:#endif
summary.c:    if (ThereArePlanets)
summary.c:      fprintf (sum, "%d planet%s\n", Sys->nb, (Sys->nb > 1 ? "s" : "")); 
summary.c:    fprintf (sum, "\n%sCOMPILATION OPTION SECTION:\n%s",sep,sep);
summary.c:    fprintf (sum, "Ghost layer sizes: NGHX=%d\tNGHY=%d\tNGHZ=%d\n",\
summary.c:#ifdef LONGSUMMARY
summary.c:    fprintf (sum, "\n%sSTICKY FLAGS SECTION:\n%s",sep,sep);
summary.c:#endif
summary.c:    fprintf (sum, "\n%sRUNTIME GENERAL SECTION:\n%s",sep,sep);
summary.c:    fprintf (sum, "Current Working Directory is %s\n", CurrentWorkingDirectory);
summary.c:    fprintf (sum, "Command line: %s\n", CommandLine);
summary.c:    fprintf (sum, "Parameter file: %s\n", ParameterFile);
summary.c:    fprintf (sum, "Run on %d process%s\nHosts:\n", CPU_Number,\
summary.c:	     (CPU_Number > 1 ? "es" : ""));
summary.c:    for (i = 0; i < CPU_Number; i++) {
summary.c:    fprintf (sum, "\n%sOUTPUT SPECIFIC SECTION:\n%s",sep,sep);
summary.c:    fprintf (sum, "OUTPUT %d at simulation time %g ", nout, PhysicalTime);
summary.c:    t = time(NULL);
summary.c:    tm = *localtime(&t);
summary.c:    fprintf(sum, "(%d-%d-%d %02d:%02d:%02d)\n", tm.tm_year + 1900,\
summary.c:	    tm.tm_min, tm.tm_sec);
summary.c:    fprintf (sum, "\n%sPREPROCESSOR MACROS SECTION:\n%s",sep,sep);
summary.c:    fprintf (sum, "\n%sPARAMETERS SECTION:\n%s",sep,sep);
summary.c:      type = Var_Set[i].type;
summary.c:      // Now, we print all variables in an adequate format.
summary.c:      if (type == REAL)
summary.c:	fprintf(sum, "   %s\t%.15g\n", Var_Set[i].name, \
summary.c:		*((real*)Var_Set[i].variable));
summary.c:      if (type == INT)
summary.c:	fprintf(sum, "   %s\t%d\n", Var_Set[i].name,	\
summary.c:		*((int*) Var_Set[i].variable));
summary.c:      if (type == BOOL)
summary.c:	fprintf(sum, "   %s\t%d\n", Var_Set[i].name,	\
summary.c:		*((boolean*) Var_Set[i].variable));
summary.c:      if (type == STRING)
summary.c:	fprintf(sum, "   %s\t%s\n", Var_Set[i].name,	\
summary.c:		Var_Set[i].variable);
summary.c:    fprintf (sum, "*** Input file: %s\n#-----------\n%s\n#-----------\n",
summary.c:	     ParameterFile, InputFile);
summary.c:#ifdef LONGSUMMARY
summary.c:    fprintf (sum, "\n%sBOUNDARY CONDITIONS SECTION:\n%s",sep,sep);
summary.c:    fprintf (sum, "%s", BoundaryFile);
summary.c:#endif
summary.c:    if (ThereArePlanets) {
summary.c:      fprintf (sum, "\n%sPLANETARY SYSTEM SECTION:\n%s",sep,sep);
summary.c:	fprintf (sum, "#### Planet %d out of %d\n", i, n);
summary.c:      fprintf (sum, "*** Planetary system config file: %s\n#-----------\n%s\n#-----------\n",
summary.c:	       PLANETCONFIG, PlanetaryFile);
summary.c:    fclose (sum);
timeinfo.c:#include "fargo3d.h"
timeinfo.c:#define WALLCLOCK 1
timeinfo.c:#ifdef WALLCLOCK
timeinfo.c:#define TIMETICKS wcticks
timeinfo.c:#else
timeinfo.c:#define TIMETICKS buffer.tms_utime
timeinfo.c:#endif
timeinfo.c:static clock_t  First, Preceeding, Current, FirstUser, CurrentUser, PreceedingUser;
timeinfo.c:extern int begin_i;
timeinfo.c:void InitSpecificTime (TimeProcess *process_name, char *title){
timeinfo.c:#ifdef PROFILING
timeinfo.c:  struct tms buffer;
timeinfo.c:  wcticks = times (&buffer);
timeinfo.c:  process_name->clicks = TIMETICKS;
timeinfo.c:  strcpy (process_name->name, title);
timeinfo.c:  MPI_Barrier (MPI_COMM_WORLD);
timeinfo.c:#endif
timeinfo.c:real GiveSpecificTime (TimeProcess process_name){
timeinfo.c:  real t=0.0;
timeinfo.c:#ifdef PROFILING
timeinfo.c:  struct tms buffer;
timeinfo.c:  MPI_Barrier (MPI_COMM_WORLD);
timeinfo.c:  wcticks = times (&buffer);
timeinfo.c:  ticks = TIMETICKS - process_name.clicks;
timeinfo.c:  t = (real)ticks / (real)Ticks;
timeinfo.c:  if (process_name.name[0] != 0) {
timeinfo.c:#ifdef WALLCLOCK
timeinfo.c:    masterprint ("Wall clock time elapsed during %s : %.3f s\n", process_name.name, t);
timeinfo.c:#else
timeinfo.c:    fprintf (stderr, "Time spent in %s : %.3f s\n", process_name.name, t);
timeinfo.c:#endif
timeinfo.c:#endif
timeinfo.c:  return t;
timeinfo.c:void GiveTimeInfo (int number){
timeinfo.c:  struct tms buffer;
timeinfo.c:  real total, last, mean, totalu;
timeinfo.c:  static boolean FirstStep = YES;
timeinfo.c:  Current = times (&buffer);
timeinfo.c:  CurrentUser = buffer.tms_utime;
timeinfo.c:  if (FirstStep == YES) {
timeinfo.c:    First = Current;
timeinfo.c:    FirstUser = CurrentUser;
timeinfo.c:    fprintf (stderr, "Time counters initialized\n");
timeinfo.c:    FirstStep = NO;
timeinfo.c:  else {
timeinfo.c:    total = (real)(Current - First)/Ticks;
timeinfo.c:    totalu= (real)(CurrentUser-FirstUser)/Ticks;
timeinfo.c:    last  = (real)(CurrentUser - PreceedingUser)/Ticks;
timeinfo.c:    number -= begin_i/NINTERM;
timeinfo.c:    mean  = totalu / number;
timeinfo.c:    fprintf (stderr, "Total Real Time elapsed    : %.3f s\n", total);
timeinfo.c:    fprintf (stderr, "Total CPU Time of process  : %.3f s (%.1f %%)\n", totalu, 100.*totalu/total);
timeinfo.c:    fprintf (stderr, "CPU Time since last time step : %.3f s\n", last);
timeinfo.c:    fprintf (stderr, "Mean CPU Time between time steps : %.3f s\n", mean);
timeinfo.c:    fprintf (stderr, "CPU Load on last time step : %.1f %% \n", (real)(CurrentUser-PreceedingUser)/(real)(Current-Preceeding)*100.);
timeinfo.c:  PreceedingUser = CurrentUser;
timeinfo.c:  Preceeding = Current;
totaldens.c://#define __GPU
totaldens.c://#define __NOPROTO
totaldens.c:#include "fargo3d.h"
totaldens.c:void ComputeTotalDensity_cpu () {
totaldens.c:  INPUT(Density);
totaldens.c:  OUTPUT(Total_Density);
totaldens.c:  real* dens = Density->field_cpu;
totaldens.c:  real* totaldens = Total_Density->field_cpu;
totaldens.c:  int stride = Stride_cpu;
totaldens.c:  int size_x = Nx;
totaldens.c:  int size_y = Ny+2*NGHY;
totaldens.c:  int size_z = Nz+2*NGHZ;
totaldens.c:#ifdef Z
totaldens.c:  for (k=0; k<size_z; k++) {
totaldens.c:#endif
totaldens.c:#ifdef Y
totaldens.c:    for (j=0; j<size_y; j++) {
totaldens.c:#endif
totaldens.c:#ifdef X
totaldens.c:      for (i=0; i<size_x; i++ ) {
totaldens.c:#endif
totaldens.c:	totaldens[ll] += dens[ll];
totaldens.c:#ifdef X
totaldens.c:#endif
totaldens.c:#ifdef Y
totaldens.c:#endif
totaldens.c:#ifdef Z
totaldens.c:#endif
transport.c:#include "fargo3d.h"
transport.c:static void (*__VanLeerX) (Field *, Field *, Field *, real);
transport.c:void VanLeerX(Field *Density, Field *DensStar, Field *Vx_t, real dt) {
transport.c:  FARGO_SAFE(VanLeerX_a(Density));
transport.c:  FARGO_SAFE(VanLeerX_b(dt, Density, DensStar, Vx_t));
transport.c:void TransportX(Field *Q, Field *Qs, Field *Vx_t, real dt) { 
transport.c:  if (Q != Density){
transport.c:     FARGO_SAFE(DivideByRho(Q));
transport.c:     __VanLeerX(DivRho, Qs, Vx_t, dt);
transport.c:     FARGO_SAFE(UpdateX (dt, Q, Qs, Vx_t));
transport.c:  else{
transport.c:     FARGO_SAFE(UpdateDensityX (dt, Q, Vx_t));
transport.c:void TransportY(Field *Q, Field *Qs, real dt) {
transport.c:  if (Q != Density){
transport.c:    FARGO_SAFE(DivideByRho(Q));
transport.c:    FARGO_SAFE(VanLeerY_a(DivRho));
transport.c:    FARGO_SAFE(VanLeerY_b(dt, DivRho, Qs));
transport.c:    FARGO_SAFE(UpdateY (dt, Q, Qs));
transport.c:  else
transport.c:    FARGO_SAFE(UpdateDensityY (dt, Q));
transport.c:void TransportZ(Field *Q, Field *Qs, real dt) {
transport.c:   if (Q != Density){
transport.c:    FARGO_SAFE(DivideByRho(Q));
transport.c:    FARGO_SAFE(VanLeerZ_a(DivRho));
transport.c:    FARGO_SAFE(VanLeerZ_b(dt, DivRho, Qs));
transport.c:    FARGO_SAFE(UpdateZ (dt, Q, Qs));
transport.c:  else
transport.c:    FARGO_SAFE(UpdateDensityZ (dt, Q));
transport.c:void XadvectRAM(Field* F, real dt){
transport.c:  RamSlopes(F);
transport.c:  if (toupper(*SPACING) == 'L') AdvectRAMlin(dt,F);
transport.c:  else AdvectRAM(dt,F);
transport.c:void X_advection (Field *Vx_t, real dt) {
transport.c:#ifdef X
transport.c:  __VanLeerX(Density, DensStar, Vx_t, dt);
transport.c:#endif
transport.c:#ifdef Y
transport.c:#endif
transport.c:#ifdef Z
transport.c:#endif
transport.c:#ifdef ADIABATIC
transport.c:  TransportX(Energy, Qs, Vx_t, dt);
transport.c:#endif
transport.c:  TransportX(Density, Qs, Vx_t, dt);
transport.c:void transport(real dt){
transport.c:#ifdef X
transport.c:  FARGO_SAFE(momenta_x());
transport.c:#endif
transport.c:#ifdef Y
transport.c:  FARGO_SAFE(momenta_y());
transport.c:#endif
transport.c:#ifdef Z
transport.c:  FARGO_SAFE(momenta_z());
transport.c:#endif
transport.c:#ifdef Z
transport.c:    FARGO_SAFE(VanLeerZ_a(Density));
transport.c:    FARGO_SAFE(VanLeerZ_b(dt, Density, DensStar));
transport.c:#ifdef X
transport.c:#endif
transport.c:#ifdef Y
transport.c:#endif
transport.c:#ifdef Z
transport.c:#endif
transport.c:#ifdef ADIABATIC
transport.c:    TransportZ(Energy, Qs, dt);
transport.c:#endif
transport.c:    TransportZ(Density, Qs, dt);
transport.c:#endif
transport.c:#ifdef Y
transport.c:    FARGO_SAFE(VanLeerY_a(Density));
transport.c:    FARGO_SAFE(VanLeerY_b(dt, Density, DensStar));
transport.c:#ifdef X  
transport.c:#endif
transport.c:#ifdef Y
transport.c:#endif
transport.c:#ifdef Z
transport.c:#endif
transport.c:#ifdef ADIABATIC
transport.c:    TransportY(Energy, Qs, dt);
transport.c:#endif
transport.c:    TransportY(Density, Qs, dt);
transport.c:#endif
transport.c:#ifdef X
transport.c:#ifdef STANDARD
transport.c:    __VanLeerX = VanLeerX;
transport.c:    X_advection (Vx_temp, dt);
transport.c:#else // FARGO and RAM algorithm below
transport.c:    FARGO_SAFE(ComputeResidual(dt));
transport.c:    __VanLeerX = VanLeerX;
transport.c:    X_advection (Vx, dt); // Vx => variable residual
transport.c:#ifndef RAM 
transport.c:    //__VanLeerX= VanLeerX;
transport.c:    __VanLeerX= VanLeerX_PPA;
transport.c:    X_advection (Vx_temp, dt); // Vx_temp => fixed residual @ given r. This one only is done with PPA
transport.c:    __VanLeerX = VanLeerX;
transport.c:    AdvectSHIFT(Mpx, Nshift);
transport.c:    AdvectSHIFT(Mmx, Nshift);
transport.c:#ifdef Y
transport.c:    AdvectSHIFT(Mpy, Nshift);
transport.c:    AdvectSHIFT(Mmy, Nshift);
transport.c:#endif
transport.c:#ifdef Z
transport.c:    AdvectSHIFT(Mpz, Nshift);
transport.c:    AdvectSHIFT(Mmz, Nshift);
transport.c:#endif
transport.c:#ifdef ADIABATIC
transport.c:    AdvectSHIFT(Energy, Nshift);
transport.c:#endif
transport.c:    AdvectSHIFT(Density, Nshift);
transport.c:#else //RAM algorithm below
transport.c:    FARGO_SAFE(RamComputeUstar(dt));
transport.c:    XadvectRAM(Mpx,dt);
transport.c:    XadvectRAM(Mmx,dt);
transport.c:#ifdef Y
transport.c:    XadvectRAM(Mpy,dt);
transport.c:    XadvectRAM(Mmy,dt);
transport.c:#endif
transport.c:#ifdef Z
transport.c:    XadvectRAM(Mpz, dt);
transport.c:    XadvectRAM(Mmz, dt);
transport.c:#endif
transport.c:#ifdef ADIABATIC
transport.c:    XadvectRAM(Energy, dt);
transport.c:#endif
transport.c:    XadvectRAM(Density,dt);
transport.c:#endif //RAM
transport.c:#endif //no STD
transport.c:#endif //X 
transport.c:#ifdef X
transport.c:  FARGO_SAFE(NewVelocity_x());
transport.c:#endif
transport.c:#ifdef Y
transport.c:  FARGO_SAFE(NewVelocity_y());
transport.c:#endif
transport.c:#ifdef Z
transport.c:  FARGO_SAFE(NewVelocity_z());
transport.c:#endif
update_density_x.c://#define __GPU
update_density_x.c://#define __NOPROTO
update_density_x.c:#include "fargo3d.h"
update_density_x.c:void UpdateDensityX_cpu(real dt, Field *Q, Field *Vx_t) {
update_density_x.c:  INPUT(DensStar);
update_density_x.c:  real* qb = Q->field_cpu;
update_density_x.c:  real* vx = Vx_t->field_cpu;
update_density_x.c:  real* rho_s = DensStar->field_cpu;
update_density_x.c:  int stride = Stride_cpu;
update_density_x.c:  int size_x = XIP; 
update_density_x.c:  int size_y = Ny+2*NGHY;
update_density_x.c:  int size_z = Nz+2*NGHZ;
update_density_x.c:  int i; //Variables reserved
update_density_x.c:  int j; //for the topology
update_density_x.c:  int k; //of the kernels
update_density_x.c:// real Sxi(Nx);
update_density_x.c:// real Sxj(Ny+2*NGHY);
update_density_x.c:// real Syj(Ny+2*NGHY);
update_density_x.c:// real Szj(Ny+2*NGHY);
update_density_x.c:// real Sxk(Nz+2*NGHZ);
update_density_x.c:// real Syk(Nz+2*NGHZ);
update_density_x.c:// real Szk(Nz+2*NGHZ);
update_density_x.c:// real InvVj(Ny+2*NGHY);
update_density_x.c:#ifdef Z  
update_density_x.c:  for (k=0; k<size_z; k++) {
update_density_x.c:#endif
update_density_x.c:#ifdef Y
update_density_x.c:    for (j=0; j<size_y; j++) {
update_density_x.c:#endif
update_density_x.c:#ifdef X
update_density_x.c:      for (i=0; i<size_x; i++) {
update_density_x.c:#endif
update_density_x.c:#ifdef X
update_density_x.c:#endif
update_density_x.c:#ifdef Y
update_density_x.c:#endif
update_density_x.c:#ifdef Z
update_density_x.c:#endif
update_density_y.c://#define __GPU
update_density_y.c://#define __NOPROTO
update_density_y.c:#include "fargo3d.h"
update_density_y.c:void UpdateDensityY_cpu(real dt, Field *Q) {
update_density_y.c:  INPUT(Vy_temp);
update_density_y.c:  INPUT(DensStar);
update_density_y.c:  real* qb = Q->field_cpu;
update_density_y.c:  real* vy = Vy_temp->field_cpu;
update_density_y.c:  real* rho_s = DensStar->field_cpu;
update_density_y.c:  int stride = Stride_cpu;
update_density_y.c:  int size_x = Nx+2*NGHX;
update_density_y.c:  int size_y = Ny+2*NGHY-1;
update_density_y.c:  int size_z = Nz+2*NGHZ;
update_density_y.c:  int i; //Variables reserved
update_density_y.c:  int j; //for the topology
update_density_y.c:  int k; //of the kernels
update_density_y.c:// real Sxi(Nx);
update_density_y.c:// real Sxj(Ny+2*NGHY);
update_density_y.c:// real Syj(Ny+2*NGHY);
update_density_y.c:// real Szj(Ny+2*NGHY);
update_density_y.c:// real Sxk(Nz+2*NGHZ);
update_density_y.c:// real Syk(Nz+2*NGHZ);
update_density_y.c:// real Szk(Nz+2*NGHZ);
update_density_y.c:// real InvVj(Ny+2*NGHY);
update_density_y.c:#ifdef Z  
update_density_y.c:  for (k=0; k<size_z; k++) {
update_density_y.c:#endif
update_density_y.c:#ifdef Y
update_density_y.c:    for (j=0; j<size_y; j++) {
update_density_y.c:#endif
update_density_y.c:#ifdef X
update_density_y.c:      for (i=0; i<size_x; i++) {
update_density_y.c:#endif
update_density_y.c:#ifdef X
update_density_y.c:#endif
update_density_y.c:#ifdef Y
update_density_y.c:#endif
update_density_y.c:#ifdef Z
update_density_y.c:#endif
update_density_z.c://#define __GPU
update_density_z.c://#define __NOPROTO
update_density_z.c:#include "fargo3d.h"
update_density_z.c:void UpdateDensityZ_cpu(real dt, Field *Q) {
update_density_z.c:  INPUT(Vz_temp);
update_density_z.c:  INPUT(DensStar);
update_density_z.c:  real* qb = Q->field_cpu;
update_density_z.c:  real* vz = Vz_temp->field_cpu;
update_density_z.c:  real* rho_s = DensStar->field_cpu;
update_density_z.c:  int stride = Stride_cpu;
update_density_z.c:  int size_x = Nx+2*NGHX;
update_density_z.c:  int size_y = Ny+2*NGHY;
update_density_z.c:  int size_z = Nz+2*NGHZ-1;
update_density_z.c:  int i; //Reserved variables 
update_density_z.c:  int j; //for the topology
update_density_z.c:  int k; //of the kernels
update_density_z.c:// real Sxi(Nx);
update_density_z.c:// real Sxj(Ny+2*NGHY);
update_density_z.c:// real Syj(Ny+2*NGHY);
update_density_z.c:// real Szj(Ny+2*NGHY);
update_density_z.c:// real Sxk(Nz+2*NGHZ);
update_density_z.c:// real Syk(Nz+2*NGHZ);
update_density_z.c:// real Szk(Nz+2*NGHZ);
update_density_z.c:// real InvVj(Ny+2*NGHY);
update_density_z.c:#ifdef Z  
update_density_z.c:  for (k=0; k<size_z; k++) {
update_density_z.c:#endif
update_density_z.c:#ifdef Y
update_density_z.c:    for (j=0; j<size_y; j++) {
update_density_z.c:#endif
update_density_z.c:#ifdef X
update_density_z.c:      for (i=0; i<size_x; i++) {
update_density_z.c:#endif
update_density_z.c:#ifdef X
update_density_z.c:#endif
update_density_z.c:#ifdef Y
update_density_z.c:#endif
update_density_z.c:#ifdef Z
update_density_z.c:#endif
update_magnetic.c://#define __GPU
update_magnetic.c://#define __NOPROTO
update_magnetic.c:#include "fargo3d.h"
update_magnetic.c:void UpdateMagneticField(real dt,int idx, int idy, int idz) { 
update_magnetic.c:  Field* Emf1;
update_magnetic.c:  Field* Emf2;
update_magnetic.c:  Field* B;
update_magnetic.c:  FARGO_SAFE(_UpdateMagneticField(dt, idx, idy, idz,idx1,idy1,idz1,
update_magnetic.c:void _UpdateMagneticField_cpu(real dt,int idx,int idy,int idz,int idx1,int idy1,int idz1, int idx2,int idy2,int idz2, Field* B,Field* Emf1,Field* Emf2) {
update_magnetic.c:  real* b    = B->field_cpu; 
update_magnetic.c:  real* emf1 = Emf1->field_cpu; 
update_magnetic.c:  real* emf2 = Emf2->field_cpu;
update_magnetic.c:  int stride = Stride_cpu;
update_magnetic.c:  int size_x = XIP; 
update_magnetic.c:  int size_y = Ny+2*NGHY-1;
update_magnetic.c:  int size_z = Nz+2*NGHZ-1;
update_magnetic.c:  real dp1p,dp1m,dp2p,dp2m; 
update_magnetic.c:  real surf; 
update_magnetic.c:// real xmin(Nx+1);
update_magnetic.c:// real ymin(Ny+2*NGHY+1);
update_magnetic.c:// real zmin(Nz+2*NGHZ+1);
update_magnetic.c:// real Sxj(Ny+2*NGHY);
update_magnetic.c:// real Syj(Ny+2*NGHY);
update_magnetic.c:// real Szj(Ny+2*NGHY);
update_magnetic.c:// real Sxk(Nz+2*NGHZ);
update_magnetic.c:// real Syk(Nz+2*NGHZ);
update_magnetic.c:// real Szk(Nz+2*NGHZ);
update_magnetic.c:// real Sxi(Nx);
update_magnetic.c:  for (k=1; k<size_z; k++) { 
update_magnetic.c:    for (j=1; j<size_y; j++) { 
update_magnetic.c:      for (i=XIM; i<size_x; i++) {
update_magnetic.c:	dp1m = (edge_size_x(i,j,k)*idx2 +
update_magnetic.c: 		edge_size_y(j,k)*idy2 +
update_magnetic.c:		edge_size_z(j,k)*idz2); 
update_magnetic.c:	dp1p = (edge_size_x(i,j+idy1,k+idz1)*idx2 + 
update_magnetic.c:		edge_size_y(j+idy1,k+idz1)*idy2 + 
update_magnetic.c:		edge_size_z(j+idy1,k+idz1)*idz2); 
update_magnetic.c:	dp2m = (edge_size_x(i,j,k)*idx1 + 
update_magnetic.c:		edge_size_y(j,k)*idy1 + 
update_magnetic.c:		edge_size_z(j,k)*idz1); 
update_magnetic.c:	dp2p = (edge_size_x(i,j+idy2,k+idz2)*idx1 + 
update_magnetic.c:		edge_size_y(j+idy2,k+idz2)*idy1 + 
update_magnetic.c:		edge_size_z(j+idy2,k+idz2)*idz1); 
update_magnetic.c:	b[l] += dt/surf * (emf1[lp2]*dp2p - emf1[l]*dp2m
update_magnetic.c:			   - emf2[lp1]*dp1p + emf2[l]*dp1m); 	
update_x.c://#define __GPU
update_x.c://#define __NOPROTO
update_x.c:#include "fargo3d.h"
update_x.c:void UpdateX_cpu(real dt, Field *Q, Field *Qs, Field *Vx_t) {
update_x.c:  INPUT(DensStar);
update_x.c:  real* qb = Q->field_cpu;
update_x.c:  real* qs = Qs->field_cpu;
update_x.c:  real* vx = Vx_t->field_cpu;
update_x.c:  real* rho_s = DensStar->field_cpu;
update_x.c:  int stride = Stride_cpu;
update_x.c:  int size_x = XIP; 
update_x.c:  int size_y = Ny+2*NGHY;
update_x.c:  int size_z = Nz+2*NGHZ;
update_x.c:  int i; //Variables reserved
update_x.c:  int j; //for the topology
update_x.c:  int k; //of the kernels
update_x.c:// real Sxi(Nx);
update_x.c:// real Sxj(Ny+2*NGHY);
update_x.c:// real Syj(Ny+2*NGHY);
update_x.c:// real Szj(Ny+2*NGHY);
update_x.c:// real Sxk(Nz+2*NGHZ);
update_x.c:// real Syk(Nz+2*NGHZ);
update_x.c:// real Szk(Nz+2*NGHZ);
update_x.c:// real InvVj(Ny+2*NGHY);
update_x.c:#ifdef Z  
update_x.c:  for (k=0; k<size_z; k++) {
update_x.c:#endif
update_x.c:#ifdef Y
update_x.c:    for (j=0; j<size_y; j++) {
update_x.c:#endif
update_x.c:#ifdef X
update_x.c:      for (i=0; i<size_x; i++) {
update_x.c:#endif
update_x.c:#ifdef X
update_x.c:#endif
update_x.c:#ifdef Y
update_x.c:#endif
update_x.c:#ifdef Z
update_x.c:#endif
update_y.c://#define __GPU
update_y.c://#define __NOPROTO
update_y.c:#include "fargo3d.h"
update_y.c:void UpdateY_cpu(real dt, Field *Q, Field *Qs) {
update_y.c:  INPUT(Vy_temp);
update_y.c:  INPUT(DensStar);
update_y.c:  real* qb = Q->field_cpu;
update_y.c:  real* qs = Qs->field_cpu;
update_y.c:  real* vy = Vy_temp->field_cpu;
update_y.c:  real* rho_s = DensStar->field_cpu;
update_y.c:  int stride = Stride_cpu;
update_y.c:  int size_x = Nx+2*NGHX;
update_y.c:  int size_y = Ny+2*NGHY-1;
update_y.c:  int size_z = Nz+2*NGHZ;
update_y.c:  int i; //Variables reserved
update_y.c:  int j; //for the topology
update_y.c:  int k; //of the kernels
update_y.c:// real Sxi(Nx);
update_y.c:// real Sxj(Ny+2*NGHY);
update_y.c:// real Syj(Ny+2*NGHY);
update_y.c:// real Szj(Ny+2*NGHY);
update_y.c:// real Sxk(Nz+2*NGHZ);
update_y.c:// real Syk(Nz+2*NGHZ);
update_y.c:// real Szk(Nz+2*NGHZ);
update_y.c:// real InvVj(Ny+2*NGHY);
update_y.c:#ifdef Z  
update_y.c:  for (k=0; k<size_z; k++) {
update_y.c:#endif
update_y.c:#ifdef Y
update_y.c:    for (j=0; j<size_y; j++) {
update_y.c:#endif
update_y.c:#ifdef X
update_y.c:      for (i=0; i<size_x; i++) {
update_y.c:#endif
update_y.c:#ifdef X
update_y.c:#endif
update_y.c:#ifdef Y
update_y.c:#endif
update_y.c:#ifdef Z
update_y.c:#endif
update_z.c://#define __GPU
update_z.c://#define __NOPROTO
update_z.c:#include "fargo3d.h"
update_z.c:void UpdateZ_cpu(real dt, Field *Q, Field *Qs) {
update_z.c:  INPUT(Vz_temp);
update_z.c:  INPUT(DensStar);
update_z.c:  real* qb = Q->field_cpu;
update_z.c:  real* qs = Qs->field_cpu;
update_z.c:  real* vz = Vz_temp->field_cpu;
update_z.c:  real* rho_s = DensStar->field_cpu;
update_z.c:  int stride = Stride_cpu;
update_z.c:  int size_x = Nx+2*NGHX;
update_z.c:  int size_y = Ny+2*NGHY;
update_z.c:  int size_z = Nz+2*NGHZ-1;
update_z.c:  int i; //Reserved variables 
update_z.c:  int j; //for the topology
update_z.c:  int k; //of the kernels
update_z.c:// real Sxi(Nx);
update_z.c:// real Sxj(Ny+2*NGHY);
update_z.c:// real Syj(Ny+2*NGHY);
update_z.c:// real Szj(Ny+2*NGHY);
update_z.c:// real Sxk(Nz+2*NGHZ);
update_z.c:// real Syk(Nz+2*NGHZ);
update_z.c:// real Szk(Nz+2*NGHZ);
update_z.c:// real InvVj(Ny+2*NGHY);
update_z.c:#ifdef Z  
update_z.c:  for (k=0; k<size_z; k++) {
update_z.c:#endif
update_z.c:#ifdef Y
update_z.c:    for (j=0; j<size_y; j++) {
update_z.c:#endif
update_z.c:#ifdef X
update_z.c:      for (i=0; i<size_x; i++) {
update_z.c:#endif
update_z.c:#ifdef X
update_z.c:#endif
update_z.c:#ifdef Y
update_z.c:#endif
update_z.c:#ifdef Z
update_z.c:#endif
usage.c:#include "fargo3d.h"
usage.c:void PrintUsage (char *execname)
usage.c:  fprintf (stderr, "Usage : %s [-tfCmkpVB0] [-D number] [-s number] [-S number] [+S number] [+/-# arraynb] [+D device_file] parameter_file\n", execname);
usage.c:  fprintf (stderr, "-C : Force execution of all functions on CPU for a GPU built\n");
usage.c:  fprintf (stderr, "-D : Manually select the GPU device on which you want to run\n");
usage.c:  fprintf (stderr, "-m : Merge output files from different processes\n");
usage.c:  fprintf (stderr, "-k : Do NOT merge output files from different processes\n");
usage.c:  fprintf (stderr, "-o : redefine parameters on the command line\n");
usage.c:  fprintf (stderr, "-s : Restart simulation, from output #number (split output)\n");
usage.c:  fprintf (stderr, "-S : Restart simulation, from output #number (merged output)\n");
usage.c:  fprintf (stderr, "+S : Overwrite initial conditions with stretched data from output #number\n");
usage.c:  fprintf (stderr, "-V : Convert DAT output to VTK output\n");
usage.c:  fprintf (stderr, "-B : Convert VTK output to DAT output\n");
usage.c:  fprintf (stderr, "-t : Monitor CPU time usage at each time step\n");
usage.c:  fprintf (stderr, "-# : Give (positive) array number to the code, which can be used as random seed and/or output suffix\n");
usage.c:  fprintf (stderr, "+# : Give (positive) array number to the code, which can be used as random seed and/or output suffix (early rename)\n");
usage.c:  fprintf (stderr, "+D : specify a node file in which each line specifies a hostname and a device number\n");
usage.c:  fprintf (stderr, "-0 : only write initial (or restart) output, and exits,\n");
usage.c:  fprintf (stderr, "-f : executes only one elementary timestep and exits.\n");
usage.c:  prs_exit (1);
vanleer_x_a.c://#define __GPU
vanleer_x_a.c://#define __NOPROTO
vanleer_x_a.c:#include "fargo3d.h"
vanleer_x_a.c:void VanLeerX_a_cpu(Field *Q){
vanleer_x_a.c:  OUTPUT(Slope);
vanleer_x_a.c:  real* slope = Slope->field_cpu;
vanleer_x_a.c:  real* q = Q->field_cpu;
vanleer_x_a.c:  int stride = Stride_cpu;
vanleer_x_a.c:  int size_x = XIP; 
vanleer_x_a.c:  int size_y = Ny+2*NGHY;
vanleer_x_a.c:  int size_z = Nz+2*NGHZ;
vanleer_x_a.c:  real dqm;
vanleer_x_a.c:  real dqp;
vanleer_x_a.c:// real xmin(Nx+1);
vanleer_x_a.c:// real ymin(Ny+2*NGHY+1);
vanleer_x_a.c:// real zmin(Nz+2*NGHZ+1);
vanleer_x_a.c:#ifdef Z
vanleer_x_a.c:  for (k=0; k<size_z; k++) {
vanleer_x_a.c:#endif
vanleer_x_a.c:#ifdef Y
vanleer_x_a.c:    for (j=0; j<size_y; j++) {
vanleer_x_a.c:#endif
vanleer_x_a.c:#ifdef X
vanleer_x_a.c:      for (i=XIM; i<size_x; i++) {	
vanleer_x_a.c:#endif
vanleer_x_a.c:	dqm = (q[ll]-q[llxm])/zone_size_x(i,j,k);
vanleer_x_a.c:	dqp = (q[llxp]-q[ll])/zone_size_x(ixp,j,k);
vanleer_x_a.c:	if(dqp*dqm<=0.0)  slope[ll] = 0.0;
vanleer_x_a.c:#ifndef DONOR
vanleer_x_a.c:	else  slope[ll] = (2.*dqp*dqm) /(dqm+dqp);
vanleer_x_a.c:#else
vanleer_x_a.c:	else  slope[ll] = 0.0;
vanleer_x_a.c:#endif
vanleer_x_a.c:#ifdef X
vanleer_x_a.c:#endif
vanleer_x_a.c:#ifdef Y
vanleer_x_a.c:#endif
vanleer_x_a.c:#ifdef Z
vanleer_x_a.c:#endif
vanleer_x_b.c://#define __GPU
vanleer_x_b.c://#define __NOPROTO
vanleer_x_b.c:#include "fargo3d.h"
vanleer_x_b.c:void VanLeerX_b_cpu(real dt, Field *Q, Field *Qs, Field *Vx_t){
vanleer_x_b.c:  INPUT(Slope);
vanleer_x_b.c:  real* q = Q->field_cpu;
vanleer_x_b.c:  real* qs = Qs->field_cpu;
vanleer_x_b.c:  real* vx = Vx_t->field_cpu;
vanleer_x_b.c:  real* slope = Slope->field_cpu;
vanleer_x_b.c:  int stride = Stride_cpu;
vanleer_x_b.c:  int size_x = Nx+2*NGHX;
vanleer_x_b.c:  int size_y = Ny+2*NGHY;
vanleer_x_b.c:  int size_z = Nz+2*NGHZ;
vanleer_x_b.c:// real xmin(Nx+1);
vanleer_x_b.c:// real ymin(Ny+2*NGHY+1);
vanleer_x_b.c:// real zmin(Nz+2*NGHZ+1);
vanleer_x_b.c:#ifdef Z
vanleer_x_b.c:  for (k=0; k<size_z; k++) {
vanleer_x_b.c:#endif
vanleer_x_b.c:#ifdef Y
vanleer_x_b.c:    for (j=0; j<size_y; j++) {
vanleer_x_b.c:#endif
vanleer_x_b.c:#ifdef X
vanleer_x_b.c:      for (i=XIM; i<size_x; i++) {
vanleer_x_b.c:#endif
vanleer_x_b.c:	  qs[ll] = q[llxm] + 0.5*(zone_size_x(ixm,j,k)-vx[ll]*dt)*slope[llxm];
vanleer_x_b.c:	else
vanleer_x_b.c:	  qs[ll] = q[ll] - 0.5*(zone_size_x(i,j,k)+vx[ll]*dt)*slope[ll];
vanleer_x_b.c:#ifdef X
vanleer_x_b.c:#endif
vanleer_x_b.c:#ifdef Y
vanleer_x_b.c:#endif
vanleer_x_b.c:#ifdef Z
vanleer_x_b.c:#endif
vanleer_y_a.c://#define __GPU
vanleer_y_a.c://#define __NOPROTO
vanleer_y_a.c:#include "fargo3d.h"
vanleer_y_a.c:void VanLeerY_a_cpu(Field *Q){
vanleer_y_a.c:  OUTPUT(Slope);
vanleer_y_a.c:  real* q = Q->field_cpu;
vanleer_y_a.c:  real* slope = Slope->field_cpu;
vanleer_y_a.c:  int stride = Stride_cpu;
vanleer_y_a.c:  int size_x = Nx+2*NGHX;
vanleer_y_a.c:  int size_y = Ny+2*NGHY-1;
vanleer_y_a.c:  int size_z = Nz+2*NGHZ;
vanleer_y_a.c:  real dqm;
vanleer_y_a.c:  real dqp;
vanleer_y_a.c:// real ymin(Ny+2*NGHY+1);
vanleer_y_a.c:#ifdef Z
vanleer_y_a.c:  for (k=0; k<size_z; k++) {
vanleer_y_a.c:#endif
vanleer_y_a.c:#ifdef Y
vanleer_y_a.c:    for (j=1; j<size_y; j++) {
vanleer_y_a.c:#endif
vanleer_y_a.c:#ifdef X
vanleer_y_a.c:      for (i=0; i<size_x; i++) {
vanleer_y_a.c:#endif
vanleer_y_a.c:	dqm = (q[ll]-q[llym])/zone_size_y(j,k);
vanleer_y_a.c:	dqp = (q[llyp]-q[ll])/zone_size_y(j+1,k);
vanleer_y_a.c:	if(dqp*dqm<=0) slope[ll] = 0;
vanleer_y_a.c:#ifndef DONOR
vanleer_y_a.c:	else  slope[ll] = 2.*dqp*dqm/(dqm+dqp);
vanleer_y_a.c:#else
vanleer_y_a.c:	else  slope[ll] = 0.0;
vanleer_y_a.c:#endif
vanleer_y_a.c:#ifdef X
vanleer_y_a.c:#endif
vanleer_y_a.c:#ifdef Y
vanleer_y_a.c:#endif
vanleer_y_a.c:#ifdef Z
vanleer_y_a.c:#endif
vanleer_y_b.c://#define __GPU
vanleer_y_b.c://#define __NOPROTO
vanleer_y_b.c:#include "fargo3d.h"
vanleer_y_b.c:void VanLeerY_b_cpu(real dt, Field *Q, Field *Qs){
vanleer_y_b.c:  INPUT(Slope);
vanleer_y_b.c:  INPUT(Vy_temp);
vanleer_y_b.c:  real* q = Q->field_cpu;
vanleer_y_b.c:  real* qs = Qs->field_cpu;
vanleer_y_b.c:  real* slope = Slope->field_cpu;
vanleer_y_b.c:  real* vy = Vy_temp -> field_cpu;
vanleer_y_b.c:  int stride = Stride_cpu;
vanleer_y_b.c:  int size_x = Nx+2*NGHX;
vanleer_y_b.c:  int size_y = Ny+2*NGHY-1;
vanleer_y_b.c:  int size_z = Nz+2*NGHZ;
vanleer_y_b.c:// real ymin(Ny+2*NGHY+1);
vanleer_y_b.c:#ifdef Z
vanleer_y_b.c:  for (k=0; k<size_z; k++) {
vanleer_y_b.c:#endif
vanleer_y_b.c:#ifdef Y
vanleer_y_b.c:    for (j=1; j<size_y; j++) {
vanleer_y_b.c:#endif
vanleer_y_b.c:#ifdef X
vanleer_y_b.c:      for (i=0; i<size_x; i++) {
vanleer_y_b.c:#endif
vanleer_y_b.c:	  qs[ll] = q[llym] + 0.5 * (zone_size_y(j-1,k)
vanleer_y_b.c:				  -vy[ll]*dt)*slope[llym];
vanleer_y_b.c:	else
vanleer_y_b.c:	  qs[ll] = q[ll] - 0.5 * (zone_size_y(j,k)
vanleer_y_b.c:	  			  +vy[ll]*dt)*slope[ll];
vanleer_y_b.c:#ifdef X
vanleer_y_b.c:#endif
vanleer_y_b.c:#ifdef Y
vanleer_y_b.c:#endif
vanleer_y_b.c:#ifdef Z
vanleer_y_b.c:#endif
vanleer_z_a.c://#define __GPU
vanleer_z_a.c://#define __NOPROTO
vanleer_z_a.c:#include "fargo3d.h"
vanleer_z_a.c:void VanLeerZ_a_cpu(Field *Q){
vanleer_z_a.c:  OUTPUT(Slope);
vanleer_z_a.c:  real* q = Q->field_cpu;
vanleer_z_a.c:  real* slope = Slope->field_cpu;
vanleer_z_a.c:  int stride = Stride_cpu;
vanleer_z_a.c:  int size_x = Nx+2*NGHX;
vanleer_z_a.c:  int size_y = Ny+2*NGHY;
vanleer_z_a.c:  int size_z = Nz+2*NGHZ-1;
vanleer_z_a.c:  real dqm;
vanleer_z_a.c:  real dqp;
vanleer_z_a.c:// real ymin(Ny+2*NGHY+1);
vanleer_z_a.c:// real zmin(Nz+2*NGHZ+1);
vanleer_z_a.c:#ifdef Z
vanleer_z_a.c:  for (k=1; k<size_z; k++) {
vanleer_z_a.c:#endif
vanleer_z_a.c:#ifdef Y
vanleer_z_a.c:    for (j=0; j<size_y; j++) {
vanleer_z_a.c:#endif
vanleer_z_a.c:#ifdef X
vanleer_z_a.c:      for (i=0; i<size_x; i++) {
vanleer_z_a.c:#endif
vanleer_z_a.c:	dqm = (q[ll]-q[llzm])/zone_size_z(j,k);
vanleer_z_a.c:	dqp = (q[llzp]-q[ll])/zone_size_z(j,k+1);
vanleer_z_a.c:	if(dqp*dqm<=0) slope[ll] = 0;
vanleer_z_a.c:#ifndef DONOR
vanleer_z_a.c:	else  slope[ll] = 2.*dqp*dqm/(dqm+dqp);
vanleer_z_a.c:#else
vanleer_z_a.c:	else  slope[ll] = 0.0;
vanleer_z_a.c:#endif
vanleer_z_a.c:#ifdef X
vanleer_z_a.c:#endif
vanleer_z_a.c:#ifdef Y
vanleer_z_a.c:#endif
vanleer_z_a.c:#ifdef Z
vanleer_z_a.c:#endif
vanleer_z_b.c://#define __GPU
vanleer_z_b.c://#define __NOPROTO
vanleer_z_b.c:#include "fargo3d.h"
vanleer_z_b.c:void VanLeerZ_b_cpu(real dt, Field *Q, Field *Qs){
vanleer_z_b.c:  INPUT(Slope);
vanleer_z_b.c:  INPUT(Vz_temp);
vanleer_z_b.c:  real* q = Q->field_cpu;
vanleer_z_b.c:  real* qs = Qs->field_cpu;
vanleer_z_b.c:  real* slope = Slope->field_cpu;
vanleer_z_b.c:  real* vz = Vz_temp -> field_cpu;
vanleer_z_b.c:  int stride = Stride_cpu;
vanleer_z_b.c:  int size_x = Nx+2*NGHX;
vanleer_z_b.c:  int size_y = Ny+2*NGHY;
vanleer_z_b.c:  int size_z = Nz+2*NGHZ-1;
vanleer_z_b.c:// real ymin(Ny+2*NGHY+1);
vanleer_z_b.c:// real zmin(Nz+2*NGHZ+1);
vanleer_z_b.c:#ifdef Z
vanleer_z_b.c:  for (k=1; k<size_z; k++) {
vanleer_z_b.c:#endif
vanleer_z_b.c:#ifdef Y
vanleer_z_b.c:    for (j=0; j<size_y; j++) {
vanleer_z_b.c:#endif
vanleer_z_b.c:#ifdef X
vanleer_z_b.c:      for (i=0; i<size_x; i++) {
vanleer_z_b.c:#endif
vanleer_z_b.c:	  qs[ll] = q[llzm] + 0.5 * (zone_size_z(j,k-1)
vanleer_z_b.c:				  -vz[ll]*dt)*slope[llzm];
vanleer_z_b.c:	else
vanleer_z_b.c:	  qs[ll] = q[ll] - 0.5 * (zone_size_z(j,k)
vanleer_z_b.c:	  			  +vz[ll]*dt)*slope[ll];
vanleer_z_b.c:#ifdef X
vanleer_z_b.c:#endif
vanleer_z_b.c:#ifdef Y
vanleer_z_b.c:#endif
vanleer_z_b.c:#ifdef Z
vanleer_z_b.c:#endif
vanleerx_ppa.c:#include "fargo3d.h"
vanleerx_ppa.c:void VanLeerX_PPA(Field *Q, Field *Qs, Field *Vx_t, real dt) {
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_a(Q));
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_b(Q));
vanleerx_ppa.c:#ifdef PPA_STEEPENER
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_steep (Q));
vanleerx_ppa.c:#endif
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_c(Q));
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_d(dt,Q,Qs,Vx_t));
vanleerx_ppa.c:void VanLeerX_PPA_2D(Field *Q, Field *Qs, Field2D *Vx_t, real dt) {
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_a(Q));
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_b(Q));
vanleerx_ppa.c:#ifdef PPA_STEEPENER
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_steep(Q));
vanleerx_ppa.c:#endif
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_c(Q));
vanleerx_ppa.c:  FARGO_SAFE(VanLeerX_PPA_d_2d(dt,Q,Qs,Vx_t));
viscosity.c:#include "fargo3d.h"
viscosity.c:void viscosity(real dt){
viscosity.c:#ifdef CARTESIAN
viscosity.c:  FARGO_SAFE(visctensor_cart());
viscosity.c:#endif
viscosity.c:#ifdef CYLINDRICAL
viscosity.c:  FARGO_SAFE(visctensor_cyl());
viscosity.c:#endif
viscosity.c:#ifdef SPHERICAL
viscosity.c:  FARGO_SAFE(visctensor_sph());
viscosity.c:#endif
visctensor_cart.c://#define __GPU
visctensor_cart.c://#define __NOPROTO
visctensor_cart.c:#include "fargo3d.h"
visctensor_cart.c:void visctensor_cart_cpu(){
visctensor_cart.c:  INPUT(Density);
visctensor_cart.c:#ifdef X
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:#else
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:#else
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:#else
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:  real* rho = Density->field_cpu;
visctensor_cart.c:#ifdef X
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:  real* vx = Vx_half->field_cpu;
visctensor_cart.c:#else
visctensor_cart.c:  real* vx = Vx->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:  real* vy = Vy_half->field_cpu;
visctensor_cart.c:#else
visctensor_cart.c:  real* vy = Vy->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:#ifdef COLLISIONPREDICTOR
visctensor_cart.c:  real* vz = Vz_half->field_cpu;
visctensor_cart.c:#else
visctensor_cart.c:  real* vz = Vz->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef X
visctensor_cart.c:  real* tauxx = Mmx->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:  real* tauyy = Mmy->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:  real* tauzz = Mmz->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(X) && defined(Z)
visctensor_cart.c:  real* tauxz = Mpx->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(Y) && defined(X)
visctensor_cart.c:  real* tauyx = Mpy->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(Z) && defined(Y)
visctensor_cart.c:  real* tauzy = Mpz->field_cpu;
visctensor_cart.c:#endif
visctensor_cart.c:  int stride = Stride_cpu;
visctensor_cart.c:  int size_x = XIP; 
visctensor_cart.c:  int size_y = Ny+2*NGHY-1;
visctensor_cart.c:  int size_z = Nz+2*NGHZ-1;
visctensor_cart.c:  real div_v;
visctensor_cart.c:// real NU(1);
visctensor_cart.c:// real Sxi(Nx);
visctensor_cart.c:// real Sxj(Ny+2*NGHY);
visctensor_cart.c:// real Syj(Ny+2*NGHY);
visctensor_cart.c:// real Szj(Ny+2*NGHY);
visctensor_cart.c:// real Sxk(Nz+2*NGHZ);
visctensor_cart.c:// real Syk(Nz+2*NGHZ);
visctensor_cart.c:// real Szk(Nz+2*NGHZ);
visctensor_cart.c:// real xmin(Nx+1);
visctensor_cart.c:// real ymin(Ny+2*NGHY+1);
visctensor_cart.c:// real zmin(Nz+2*NGHZ+1);
visctensor_cart.c:// real InvVj(Ny+2*NGHY);
visctensor_cart.c:// real InvDiffXmed(Nx);
visctensor_cart.c:#ifdef Z
visctensor_cart.c:  for(k=1; k<size_z; k++) {
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:    for(j=1; j<size_y; j++) {
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef X
visctensor_cart.c:      for(i=XIM; i<size_x; i++) {
visctensor_cart.c:#endif
visctensor_cart.c://Evaluate centered divergence.
visctensor_cart.c:#ifdef X
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef X
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(X) && defined(Z)
visctensor_cart.c:	tauxz[l] = NU*.25*(rho[l]+rho[lzm]+rho[lxm]+rho[lxm-stride])*((vx[l]-vx[lzm])/(zmed(k)-zmed(k-1)) + (vz[l]-vz[lxm])*Inv_zone_size_xmed(i,j,k)); //centered on lower, left "radial" edge in y
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(Y) && defined(X)
visctensor_cart.c:	tauyx[l] = NU*.25*(rho[l]+rho[lxm]+rho[lym]+rho[lxm-pitch])*((vy[l]-vy[lxm])*Inv_zone_size_xmed(i,j,k) + (vx[l]-vx[lym])/(ymed(j)-ymed(j-1))); //centered on left, inner vertical edge in z
visctensor_cart.c:#endif
visctensor_cart.c:#if defined(Z) && defined(Y)
visctensor_cart.c:	tauzy[l] = NU*.25*(rho[l]+rho[lym]+rho[lzm]+rho[lym-stride])*((vz[l]-vz[lym])/(ymed(j)-ymed(j-1)) + (vy[l]-vy[lzm])/(zmed(k)-zmed(k-1))); //centered on lower, inner edge in x ("azimuthal")
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef X
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Y
visctensor_cart.c:#endif
visctensor_cart.c:#ifdef Z
visctensor_cart.c:#endif
visctensor_cyl.c://#define __GPU
visctensor_cyl.c://#define __NOPROTO
visctensor_cyl.c:#include "fargo3d.h"
visctensor_cyl.c:void visctensor_cyl_cpu(){
visctensor_cyl.c:  INPUT(Density);
visctensor_cyl.c:#ifdef ALPHAVISCOSITY
visctensor_cyl.c:  INPUT(Energy);
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:#else
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:#else
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:#else
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:  real* rho = Density->field_cpu;
visctensor_cyl.c:#ifdef ALPHAVISCOSITY
visctensor_cyl.c:  real* energy = Energy->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:  real* vx = Vx_half->field_cpu;
visctensor_cyl.c:#else
visctensor_cyl.c:  real* vx = Vx->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:  real* vy = Vy_half->field_cpu;
visctensor_cyl.c:#else
visctensor_cyl.c:  real* vy = Vy->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:#ifdef COLLISIONPREDICTOR
visctensor_cyl.c:  real* vz = Vz_half->field_cpu;
visctensor_cyl.c:#else
visctensor_cyl.c:  real* vz = Vz->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:  real* tauxx = Mmx->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:  real* tauyy = Mmy->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:  real* tauzz = Mmz->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(X) && defined(Z)
visctensor_cyl.c:  real* tauxz = Mpx->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(Y) && defined(X)
visctensor_cyl.c:  real* tauyx = Mpy->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(Z) && defined(Y)
visctensor_cyl.c:  real* tauzy = Mpz->field_cpu;
visctensor_cyl.c:#endif
visctensor_cyl.c:  int stride = Stride_cpu;
visctensor_cyl.c:  int size_x = XIP; 
visctensor_cyl.c:  int size_y = Ny+2*NGHY-1;
visctensor_cyl.c:  int size_z = Nz+2*NGHZ-1;
visctensor_cyl.c:  real div_v;
visctensor_cyl.c:  real viscosity;
visctensor_cyl.c:  real viscositym;
visctensor_cyl.c:  real viscosityzm;
visctensor_cyl.c:  real viscosityzmym;
visctensor_cyl.c:// real NU(1);
visctensor_cyl.c:// real GAMMA(1);
visctensor_cyl.c:// real ALPHA(1);
visctensor_cyl.c:// real Sxi(Nx);
visctensor_cyl.c:// real Sxj(Ny+2*NGHY);
visctensor_cyl.c:// real Syj(Ny+2*NGHY);
visctensor_cyl.c:// real Szj(Ny+2*NGHY);
visctensor_cyl.c:// real Sxk(Nz+2*NGHZ);
visctensor_cyl.c:// real Syk(Nz+2*NGHZ);
visctensor_cyl.c:// real Szk(Nz+2*NGHZ);
visctensor_cyl.c:// real xmin(Nx+1);
visctensor_cyl.c:// real ymin(Ny+2*NGHY+1);
visctensor_cyl.c:// real zmin(Nz+2*NGHZ+1);
visctensor_cyl.c:// real InvVj(Ny+2*NGHY);
visctensor_cyl.c:// real InvDiffXmed(Nx);
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:  for(k=1; k<size_z; k++) {
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:    for(j=1; j<size_y; j++) {
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:      for(i=XIM; i<size_x; i++) {
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef ALPHAVISCOSITY
visctensor_cyl.c:#ifdef ISOTHERMAL
visctensor_cyl.c:	viscosity     = ALPHA*energy[l]*energy[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_cyl.c:	viscositym    = ALPHA*0.0625*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_cyl.c:	viscosityzmym = ALPHA*0.0625*(energy[l]+energy[lym]+energy[lzm]+energy[lym-stride])*(energy[l]+energy[lym]+energy[lzm]+energy[lym-stride])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_cyl.c:	viscosityzm   = ALPHA*0.0625*( energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride] )*( energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride] )*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_cyl.c:#else
visctensor_cyl.c:	viscosity     = ALPHA*GAMMA*(GAMMA-1.0)*energy[l]/rho[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_cyl.c:	viscositym    = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])/(rho[l]+rho[lxm]+rho[lym]+rho[lxm-pitch])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_cyl.c:	viscosityzmym = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lym]+energy[lzm]+energy[lym-stride])/(rho[l]+rho[lym]+rho[lzm]+rho[lym-stride])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_cyl.c:	viscosityzm   = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride])/(rho[l]+rho[lzm]+rho[lxm]+rho[lxm-stride])*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_cyl.c:#endif
visctensor_cyl.c:#else
visctensor_cyl.c:#endif
visctensor_cyl.c://Evaluate centered divergence.
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(X)
visctensor_cyl.c:	tauxx[l] = viscosity*rho[l]*(2.0*(vx[lxp]-vx[l])/zone_size_x(i,j,k) - div_v);
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(Y) && defined(X)
visctensor_cyl.c:	tauxx[l] += viscosity*rho[l]*(vy[lyp]+vy[l])/ymed(j);
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(X) && defined(Z)
visctensor_cyl.c:	tauxz[l] = viscosityzm*.25*(rho[l]+rho[lzm]+rho[lxm]+rho[lxm-stride])*((vx[l]-vx[lzm])/(zmed(k)-zmed(k-1)) + (vz[l]-vz[lxm])*InvDiffXmed(i)/ymed(j)); //centered on lower, left "radial" edge in y
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(Y) && defined(X)
visctensor_cyl.c:	tauyx[l] = viscositym*.25*(rho[l]+rho[lxm]+rho[lym]+rho[lxm-pitch])*((vy[l]-vy[lxm])*InvDiffXmed(i)/ymin(j) + (vx[l]-vx[lym])/(ymed(j)-ymed(j-1))-.5*(vx[l]+vx[lym])/ymin(j)); //centered on left, inner vertical edge in z
visctensor_cyl.c:#endif
visctensor_cyl.c:#if defined(Z) && defined(Y)
visctensor_cyl.c:	tauzy[l] = viscosityzmym*.25*(rho[l]+rho[lym]+rho[lzm]+rho[lym-stride])*((vz[l]-vz[lym])/(ymed(j)-ymed(j-1)) + (vy[l]-vy[lzm])/(zmed(k)-zmed(k-1))); //centered on lower, inner edge in x ("azimuthal")
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef X
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Y
visctensor_cyl.c:#endif
visctensor_cyl.c:#ifdef Z
visctensor_cyl.c:#endif
visctensor_sph.c://#define __GPU
visctensor_sph.c://#define __NOPROTO
visctensor_sph.c:#include "fargo3d.h"
visctensor_sph.c:void visctensor_sph_cpu(){
visctensor_sph.c:  INPUT(Density);
visctensor_sph.c:#ifdef ALPHAVISCOSITY
visctensor_sph.c:  INPUT(Energy);
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef X
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:#else
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:#else
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:#else
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:  real* rho = Density->field_cpu;
visctensor_sph.c:#ifdef ALPHAVISCOSITY
visctensor_sph.c:  real* energy = Energy->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef X
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:  real* vx = Vx_half->field_cpu;
visctensor_sph.c:#else
visctensor_sph.c:  real* vx = Vx->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:  real* vy = Vy_half->field_cpu;
visctensor_sph.c:#else
visctensor_sph.c:  real* vy = Vy->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:#ifdef COLLISIONPREDICTOR
visctensor_sph.c:  real* vz = Vz_half->field_cpu;
visctensor_sph.c:#else
visctensor_sph.c:  real* vz = Vz->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef X
visctensor_sph.c:  real* tauxx = Mmx->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:  real* tauyy = Mmy->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:  real* tauzz = Mmz->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(X) && defined(Z)
visctensor_sph.c:  real* tauxz = Mpx->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Y) && defined(X)
visctensor_sph.c:  real* tauyx = Mpy->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Z) && defined(Y)
visctensor_sph.c:  real* tauzy = Mpz->field_cpu;
visctensor_sph.c:#endif
visctensor_sph.c:  int stride = Stride_cpu;
visctensor_sph.c:  int size_x = XIP; 
visctensor_sph.c:  int size_y = Ny+2*NGHY-1;
visctensor_sph.c:  int size_z = Nz+2*NGHZ-1;
visctensor_sph.c:  real div_v;
visctensor_sph.c:  real viscosity;
visctensor_sph.c:  real viscositym;
visctensor_sph.c:  real viscosityzm;
visctensor_sph.c:  real viscosityzmym;
visctensor_sph.c:// real NU(1);
visctensor_sph.c:// real GAMMA(1);
visctensor_sph.c:// real ALPHA(1);
visctensor_sph.c:// real Sxi(Nx);
visctensor_sph.c:// real Sxj(Ny+2*NGHY);
visctensor_sph.c:// real Syj(Ny+2*NGHY);
visctensor_sph.c:// real Szj(Ny+2*NGHY);
visctensor_sph.c:// real Sxk(Nz+2*NGHZ);
visctensor_sph.c:// real Syk(Nz+2*NGHZ);
visctensor_sph.c:// real Szk(Nz+2*NGHZ);
visctensor_sph.c:// real xmin(Nx+1);
visctensor_sph.c:// real ymin(Ny+2*NGHY+1);
visctensor_sph.c:// real zmin(Nz+2*NGHZ+1);
visctensor_sph.c:// real InvVj(Ny+2*NGHY);
visctensor_sph.c:// real InvDiffXmed(Nx);
visctensor_sph.c:#ifdef Z
visctensor_sph.c:  for(k=1; k<size_z; k++) {
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:    for(j=1; j<size_y; j++) {
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef X
visctensor_sph.c:      for(i=XIM; i<size_x; i++) {
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef ALPHAVISCOSITY
visctensor_sph.c:#ifdef ISOTHERMAL
visctensor_sph.c:	viscosity     = ALPHA*energy[l]*energy[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_sph.c:	viscositym    = ALPHA*0.0625*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_sph.c:	viscosityzm   = ALPHA*0.0625*(energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride])*(energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride])*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_sph.c:	viscosityzmym = ALPHA*0.0625*(energy[l]+energy[lzm]+energy[lym]+energy[lym-stride])*(energy[l]+energy[lzm]+energy[lym]+energy[lym-stride])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_sph.c:#else
visctensor_sph.c:	viscosity     = ALPHA*GAMMA*(GAMMA-1.0)*energy[l]/rho[l]*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));	
visctensor_sph.c:	viscositym    = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lxm]+energy[lym]+energy[lxm-pitch])/(rho[l]+rho[lxm]+rho[lym]+rho[lxm-pitch])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_sph.c:	viscosityzm   = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lzm]+energy[lxm]+energy[lxm-stride])/(rho[l]+rho[lzm]+rho[lxm]+rho[lxm-stride])*sqrt(ymed(j)*ymed(j)*ymed(j)/(G*MSTAR));
visctensor_sph.c:	viscosityzmym = ALPHA*GAMMA*(GAMMA-1.0)*(energy[l]+energy[lym]+energy[lzm]+energy[lym-stride])/(rho[l]+rho[lym]+rho[lzm]+rho[lym-stride])*sqrt(ymin(j)*ymin(j)*ymin(j)/(G*MSTAR));
visctensor_sph.c:#endif
visctensor_sph.c:#else
visctensor_sph.c:#endif
visctensor_sph.c://Evaluate centered divergence.
visctensor_sph.c:#ifdef X
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:#endif
visctensor_sph.c:	// Computing taus. Diagonal terms are zone centered
visctensor_sph.c:#if defined(X)
visctensor_sph.c:	tauxx[l] = viscosity*rho[l]*(2.0*(vx[lxp]-vx[l])/zone_size_x(i,j,k) - div_v);
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Y) && defined(X)
visctensor_sph.c:	tauxx[l] += viscosity*rho[l]*(vy[lyp]+vy[l])/ymed(j);
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Z) && defined(X)
visctensor_sph.c:	tauxx[l] += viscosity*rho[l]*(vz[lzp]+vz[l])*cos(zmed(k))/(sin(zmed(k))*ymed(j));
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:	tauzz[l] = viscosity*rho[l]*(2.0*(vz[lzp]-vz[l])/(ymed(j)*(zmin(k+1)-zmin(k))) - div_v);
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Y) && defined(Z)
visctensor_sph.c:	tauzz[l] += viscosity*rho[l]*(vy[l]+vy[lyp])/ymed(j);
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(X) && defined(Z)
visctensor_sph.c:	tauxz[l] = viscosityzm*.25*(rho[l]+rho[lzm]+rho[lxm]+rho[lxm-stride])*((vx[l]/sin(zmed(k))-vx[lzm]/sin(zmed(k-1)))*sin(zmin(k))/(ymed(j)*(zmed(k)-zmed(k-1))) + ((vz[l]-vz[lxm])*InvDiffXmed(i)/(sin(zmin(k))*ymed(j)))); //centered on lower, left "radial" edge in y
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Y) && defined(X)
visctensor_sph.c:	tauyx[l] = viscositym*.25*(rho[l]+rho[lxm]+rho[lym]+rho[lxm-pitch])*((vy[l]-vy[lxm])*InvDiffXmed(i)/(ymin(j)*sin(zmed(k))) + (vx[l]-vx[lym])/(ymed(j)-ymed(j-1))-.5*(vx[l]+vx[lym])/ymin(j)); //centered on left, inner vertical edge in z
visctensor_sph.c:#endif
visctensor_sph.c:#if defined(Z) && defined(Y)
visctensor_sph.c:	tauzy[l] = viscosityzmym*.25*(rho[l]+rho[lym]+rho[lzm]+rho[lym-stride])*((vz[l]-vz[lym])/(ymed(j)-ymed(j-1)) -.5*(vz[l]+vz[lym])/ymin(j) + (vy[l]-vy[lzm])/(ymin(j)*(zmed(k)-zmed(k-1)))); //centered on lower, inner edge in x ("azimuthal")
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef X
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Y
visctensor_sph.c:#endif
visctensor_sph.c:#ifdef Z
visctensor_sph.c:#endif
